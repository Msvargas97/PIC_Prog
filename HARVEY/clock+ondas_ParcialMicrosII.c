/* Main.c file generated by New Project wizard
 *
 * Created: sáb nov 16 2013
 * Processor: PIC18F47J53
 * Compiler: CCS for PIC
 */
#include <18F47J53.h>
#include <math.h>
#FUSES NOWDT         //WDT disabled (enabled by SWDTEN bit)                    
#FUSES PLL3          //Divide by 3 (12 MHz oscillator input)            
#FUSES NOPLLEN       //PLL Disabled
#FUSES NOSTVREN      //stack overflow/underflow reset enabled                
#FUSES NOXINST       //Extended instruction set disabled            
#FUSES NOCPUDIV      //No CPU system clock divide         
#FUSES NOPROTECT     //Program memory is not code-protected          
#FUSES HSPLL         //HS oscillator, PLL enabled, HSPLL used by USB           
#FUSES SOSC_HIGH     //High Power T1OSC/SOSC circuit selected
#FUSES CLOCKOUT      //CLKO output enabled on the RA6 pin 
#FUSES NOFCMEN       //Fail-Safe Clock Monitor disabled
#FUSES NOIESO        //Two-Speed Start-up disabled
#FUSES WDT32768      //Watchdog Postscaler 1:32768
#FUSES DSWDTOSC_int  //DSWDT uses INTOSC/INTRC as clock
#FUSES RTCOSC_int    //RTCC uses INTRC as clock
#FUSES NODSBOR       //Zero-Power BOR disabled in Deep Sleep
#FUSES NODSWDT       //Deep Sleep Watchdog Timer Disabled
#FUSES DSWDT8192     //Deep Sleep Watchdog Postscaler: 1:8,192 (8.5 seconds)   
#FUSES NOIOL1WAY     //IOLOCK bit can be set and cleared
#FUSES ADC12         //ADC 10 or 12 Bit Select:12 - Bit ADC Enabed 
#FUSES MSSPMSK7      //MSSP 7 Bit address masking
#FUSES NOWPFP        //Write Protect Program Flash Page 0
#FUSES NOWPCFG       //Write/Erase last page protect Disabled
#FUSES WPDIS         //WPFP[5:0], WPEND, and WPCFG bits ignored 
#FUSES WPEND         //Start protection at page 0
#FUSES LS48MHZ       //Low Speed USB mode with 48 MHz System clock at 48 MHz USB CLKEN divide-by is set to 8 
#use delay(clock=48000000)
#pin_select U2TX=PIN_D2 //Selecciona hardware UART2
#pin_select U2RX=PIN_D3 //Selecciona hardware UART2
#define LOADER_END   0xFFF                        
#build(reset=LOADER_END+1, interrupt=LOADER_END+9)   //Protege posiciones de memoria desde la 0x0000 hasta la 0x1000   
#org 0, LOADER_END {}
#bit PLLEN = 0xf9b.6
#use  I2C(master,I2C1, SLOW,FORCE_HW )          // I2C usando hardware
//#use  rs232(baud=9600,parity=N,UART1,bits=8,timeout=30)
/********************************************************/
/*------- Espacio para declaracion de constantes  ------*/
/********************************************************/
#define DAC_CS     PIN_B6
#define DAC_CLK    PIN_B7
#define DAC_DI     PIN_C7
#define DAC_LDAC   PIN_C6
#define segundos     0
#define minutos      1
#define horas        2
#define dia_semana   3
#define dia_mes      4
#define mes          5
#define anho         6
#define control      7 

char DS1307 [64],buffer_DS1307[6];
#include "Configura_LCD_4-8_bits.c"
#include "waveGenerator.c"
#include <stdlib.h>
#bit INTF_BIT = 0x0B.1 // INTCON BIT 1 = 
/********************************************************/
/*--- Espacio para declaracion de variables globales  --*/
/********************************************************/
char waveSelect;
char input[10];
int1 antiRebote = false,status_b3;
unsigned int16 i,j;
unsigned char keyChar;
int1 BanderaStart;
float frequency;
unsigned char bitcount;
unsigned char auxkeyChar,exit;
char BUFF[30],startTimeDate[6];

unsigned char const unshifted[68][2] = 
{
   0x0d,9,
   0x0e,'º',0x15,'q',0x16,'1',0x1a,'z',0x1b,'s',0x1c,'a',0x1d,'w',
   0x1e,'2',0x21,'c',0x22,'x',0x23,'d',0x24,'e',0x25,'4',0x26,'3',
   0x29,' ',0x2a,'v',0x2b,'f',0x2c,'t',0x2d,'r',0x2e,'5',0x31,'n',
   0x32,'b',0x33,'h',0x34,'g',0x35,'y',0x36,'6',0x39,',',0x3a,'m',
   0x3b,'j',0x3c,'u',0x3d,'7',0x3e,'8',0x41,',',0x42,'k',0x43,'i',
   0x44,'o',0x45,'0',0x46,'9',0x49,'.',0x4a,'-',0x4b,'l',0x4c,'ñ',
   0x4d,'p',0x4e,' ',0x52,'´',0x54,'`',0x55,'¡',0x5a,13,0x5b,'\n',
   0x5d,'ç',0x61,'<',0x66,' ',0x69,'1',0x6b,'4',0x6c,'7',0x70,'0',
   0x71,'.',0x72,'2',0x73,'5',0x74,'6',0x75,'8',0x79,'+',0x7a,'3',
   0x7b,'-',0x7c,'*',0x7d,'9',
   0,0
};

/********************************************************/
/********************************************************/
/*-------------- Espacio para funciones  ---------------*/
/********************************************************/
void write_ds1307(void) {
char ds1307_register;
  i2c_start();                              //Genera señal de Start
  i2c_write(0xD0);                          //Envia apuntador de dispositivo I2C
  i2c_write(0x00);                          //Envia direccion LSB
  for(ds1307_register=0;ds1307_register<64;ds1307_register++){
    i2c_write(DS1307 [ds1307_register]);    //Envia dato
  }
  i2c_stop();                               //Genera señal de Stop
}
/******************************************************************************/
/******************************************************************************/
void read_ds1307(void) {
char ds1307_register;
i2c_start();
i2c_write(0xd0);
i2c_write(0);
i2c_stop();
i2c_start();
i2c_write(0xd1);
   for(ds1307_register=0;ds1307_register<63;ds1307_register++){
      DS1307 [ds1307_register]= i2c_read();   // Toma lectura desde DS1307
    if(ds1307_register <= anho){
    if(  DS1307 [ds1307_register] >= 0x10 &&   DS1307 [ds1307_register]<=0x19)   DS1307 [ds1307_register] =   DS1307 [ds1307_register]-6;
    else if(  DS1307 [ds1307_register] >= 0x20 &&   DS1307 [ds1307_register]<=0x29)   DS1307 [ds1307_register] =   DS1307 [ds1307_register]-12;
    else if(  DS1307 [ds1307_register] >= 0x30 &&   DS1307 [ds1307_register]<=0x39)   DS1307 [ds1307_register] =   DS1307 [ds1307_register]-18;
    else if(  DS1307 [ds1307_register] >= 0x40 &&   DS1307 [ds1307_register]<=0x49)   DS1307 [ds1307_register] =   DS1307 [ds1307_register]-24;
    else if(  DS1307 [ds1307_register] >= 0x50 &&   DS1307 [ds1307_register]<=0x59)   DS1307 [ds1307_register] =   DS1307 [ds1307_register]-30;
    if(ds1307_register == horas ) buffer_DS1307[0] = DS1307[ds1307_register];
    if(ds1307_register == minutos ) buffer_DS1307[1] = DS1307[ds1307_register];
    if(ds1307_register == segundos ) buffer_DS1307[2] = DS1307[ds1307_register];
    if(ds1307_register == dia_semana ) buffer_DS1307[3] = DS1307[ds1307_register];
    if(ds1307_register == mes ) buffer_DS1307[4] = DS1307[ds1307_register];
    if(ds1307_register == anho ) buffer_DS1307[5] = DS1307[ds1307_register];
   }
   }
DS1307 [63]=i2c_read(0);                     // Toma lectura desde DS1307 
i2c_stop();                                  // Genera señal de STOP    
}
void init_dac()
{
   output_high (DAC_CS) ;
   output_high (DAC_LDAC) ;
   output_high (DAC_CLK) ;
   output_high (DAC_DI) ;
}
void write_dac(int16 data) 
{
   BYTE cmd[3];
   BYTE i;
   cmd[0] = data;
   cmd[1] = (data>>8);
   cmd[2] = 0x01;
   
   output_high (DAC_LDAC) ;
   output_low (DAC_CLK) ;
   output_low (DAC_CS) ;
   for (i = 0; i <= 23;  ++i)
   {
      if (i < 4|| (i > 7&&i < 12) )
      shift_left (cmd, 3, 0) ;
      else
      {
         output_bit (DAC_DI, shift_left (cmd, 3, 0));
         output_high (DAC_CLK) ;
         output_low (DAC_CLK) ;
      }
   }
   output_high (DAC_CS) ;
   output_low (DAC_LDAC) ;
   //delay_us (1) ;
   output_HIGH (DAC_LDAC) ;
}
void init_kb(void)
{
   bitcount=11;
   //set_tris_b(0b00001111);

   //--------Los pins indicados(B0 y B3)son configurados como entradas.
   output_float(PIN_B0);
   output_float(PIN_B3);
   status_b3=0;

   //--------Desde que se activó el modo PULLUPS del puerto B,el estado
   //--------normal del pin B0 es ALTO. La gestión de la interrupción externa
   //--------se gestiona cuando se produce un cambio de nivel ALTO a BAJO.
   ext_int_edge(H_TO_L);
   INTF_BIT=0;
}

void decode(unsigned char sc)
{
   unsigned char i;
   for(i=0;unshifted[i][0]!=sc&&unshifted[i][0];i++);
   if(unshifted[i][0]==sc)
   {
      auxkeyChar=unshifted[i][1];
   }

   if(sc==0x5A)auxkeyChar='*';
}
void print_wave(){
      while(!BanderaStart){ 
         for(j=0;j<SAMPLES;j++){
        write_dac (wave.values[j]);
        delay_us(wave.period);
         } 
      }
}
unsigned char barrer_keyChardo()
{
   
   static unsigned char aux;

   if(auxkeyChar)
   {
      init_kb();
      aux=auxkeyChar;
      auxkeyChar=0;
      }else{
      aux=0;
   }

   return aux;
}
 #int_ext
void int_ext_isr(void)
{
   unsigned char data;

   //--------Los bit 3 a 10 se considerran datos. Paridad,start y stop
   //--------son ignorados
   if(bitcount<11&&bitcount>2)
   {
      data=(data>>1);//desplaza el dato ?
      status_b3=input(PIN_B3);

      if((status_b3)==1)
      {
         data=data|0x80;
      }
   }

   //--------Todos los bits se han recibido
   if(--bitcount==0)
   {
      decode(data);
      data=0;
      bitcount=11;
      if(antiRebote)delay_ms(100); //Tiempo para esperar entre keyChar y keyChar
   }
} 

/******************************************************************************/
/******************************************************************************/
/*--------------------- Espacio de codigo principal --------------------------*/
/******************************************************************************/ 
#zero_ram
void main()
{
   PLLEN = 1;          //Habilita PLL para generar 48MHz de oscilador*/\
   init_dac();
   lcd_init_4bits();
   init_kb();
   //Activa las interrupciones globales y la externa para 
   enable_interrupts(int_EXT);
  enable_interrupts(GLOBAL);
   //Inicializa variables 
   waveSelect=0;
   printf(lcd_putc_4bits,"\f     WELCOME \ncontinue[ENTER]");
   while(keyChar!='*'){
   keyChar=barrer_keyChardo();
   }
   printf(lcd_putc_4bits,"\f    Loading...\n");
   for(j=0;j<16;j++){
   lcd_putc_4bits(0xFF);
   delay_ms(25);
   }
      lcd_ubicaxy_4bits(1,1);
   printf(lcd_putc_4bits,"      100%c     ",'%');
   delay_ms(1000);
   printf(lcd_putc_4bits,"\fEscoger una Onda");
   delay_ms(1000);
   printf(lcd_putc_4bits,"\nS=Sinusoidal  ");
   delay_ms(1500);
   printf(lcd_putc_4bits,"\nC=Cuadrada   ");
   delay_ms(1500);
   printf(lcd_putc_4bits,"\nD=D de Sierra ");
   delay_ms(1500);
   printf(lcd_putc_4bits,"\nT=Triangular  ");
   delay_ms(1500);
   printf(lcd_putc_4bits,"\n1.S 2.C 3.D 4.T  ");
   while(exit<3)
   {
      static unsigned int8 cont;
     //Lee el keyChardo
      keyChar=barrer_keyChardo();
      
      //Si se pulsa una keyChar
      if(keyChar)
      {  //Si la keyChar es un numero
         if(waveSelect&&keyChar>=48&&keyChar<=57&&cont<4)
         {
            if(cont<4)lcd_putc_4bits(keyChar);
            input[cont]=keyChar;
            cont++;
         }

         if(keyChar>='1'&&keyChar<='4'&&waveSelect==0)
         {  
            
            printf(lcd_putc_4bits,"\fFrecuencia:");
            printf(lcd_putc_4bits,"\nTipo:");
            //Submenu para asignar frecuencia
            switch(keyChar)
            {
               case '1': waveSelect='S';printf(lcd_putc_4bits,"Sinusoidal  ");antiRebote=true;break;
               case '2': waveSelect='C';printf(lcd_putc_4bits,"Cuadrada    ");antiRebote=true;break;
               case '3': waveSelect='D';printf(lcd_putc_4bits,"D. Sierra   ");antiRebote=true;break;
               case '4': waveSelect='T';printf(lcd_putc_4bits,"Triangular  ");antiRebote=true;break;
            }
           
            lcd_ubicaxy_4bits(12,1);
             init_kb();
            //Enciende el cursor
            lcdCursorOn();
         }
        //keyChar ENTER
         if(keyChar=='*')
         {
            exit++;
            cont=0;
         }

         if(exit==1)
         {
            lcdCursorOff();
            frequency=atof(input);
            printf(lcd_putc_4bits,"\f       OK!        ");
            delay_ms(1000);
            exit=4;
         }
      }
   }
   
   switch(waveSelect)
   {
      case 'S': seno(frequency); //Crea el vector segun el tipo de onda
      break;
      case 'C': square(frequency);
      break;
      case 'D': sawTooth(frequency);
      break;
      case 'T': triangular(frequency);
      break;
   }
   //Menu2
   printf( lcd_putc_4bits,"\fProgramar\nTiempo y Fecha..."); 
   delay_ms(1500);
   printf( lcd_putc_4bits,"\fHora:\nFecha:" ); 
   lcd_ubicaxy_4bits(6,1);
   lcdCursorOn();
   int8 ButtonEnter,contador1,contador,j;
   while(1)
   {
      keyChar=barrer_keyChardo();//Lectura del keyChardo
      if(keyChar) //Si se presiona una keyChar
      {
        //Si la keyChar es un numero         
         if((keyChar>=48 && keyChar<=57))
         {
         //Guarda la keyChar en eel buffer y aumenta la posicion
         BUFF[j]=keyChar;
           j++;
            if(j==2)
            {
            //Convierte el buffer a un caracter entero de 8 bits
            j=0;
               startTimeDate[contador]=atoi(BUFF);
               contador++;
            }
            switch(contador1)
            {
               case 2:
               case 4: printf(lcd_putc_4bits,":");break;
               case 8:
               case 10: printf(lcd_putc_4bits,"-");break;
            }
            contador1++;

              lcd_putc_4bits(keyChar);
              if(contador1 == 6){
             lcd_ubicaxy_4bits(7,2);
            }
         }
       
         //Si se presiona ENTER
         if(keyChar=='*')
         {
        switch(ButtonEnter){
        case 0:
               lcd_ubicaxy_4bits(2,1);
               lcdCursorOff();
               printf(lcd_putc_4bits,"\f      SAVE!\n");
               delay_ms(700);
               break;
         }
         ButtonEnter++;
         if(ButtonEnter==1) break;

      }
   }
   }
   //deshabilita el teclado
   disable_interrupts(int_EXT);
   disable_interrupts(global);
    printf(lcd_putc_4bits,"\fHora y tiempo\nActual...");
    delay_ms(1500);
   while(1)
   {
   read_ds1307();
     // reloj i2c
      printf(lcd_putc_4bits,"\fHora:%u:%u:%u\nFecha:%u/%u/20%u",\
      DS1307[horas],DS1307[minutos],DS1307[segundos],DS1307[dia_mes],DS1307[mes],DS1307[anho]);      
       
      BanderaStart = false; //Bandera de comparacion
      for(i=0;i<3;i++){
      //Compara el valor ingresado con la hora actual
      if(startTimeDate[i] != buffer_DS1307[i]){
      BanderaStart = true;
      }
      }
      if(!BanderaStart ) {
      output_high(PIN_E2);
      }
      
      print_wave();
      delay_ms(900);    
   }
}//end main
     
