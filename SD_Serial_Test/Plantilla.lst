CCS PCH C Compiler, Version 5.015, 5967               04-Ene.-17 16:54

               Filename:   E:\PIC Prog\SD_Serial_Test\Plantilla.lst

               ROM used:   20690 bytes (16%)
                           Largest free fragment is 65528
               RAM used:   1218 (32%) at main() level
                           1671 (44%) worst case
               Stack used: 25 locations (16 in main + 9 for interrupts)
               Stack size: 31

*
01000:  GOTO   5FC4
*
01008:  MOVWF  04
0100A:  MOVFF  FD8,05
0100E:  MOVFF  FE0,06
01012:  MOVLB  0
01014:  MOVFF  FE9,0C
01018:  MOVFF  FEA,07
0101C:  MOVFF  FE1,08
01020:  MOVFF  FE2,09
01024:  MOVFF  FD9,0A
01028:  MOVFF  FDA,0B
0102C:  MOVFF  FF3,12
01030:  MOVFF  FF4,13
01034:  MOVFF  FFA,14
01038:  MOVFF  FFB,15
0103C:  MOVFF  00,0E
01040:  MOVFF  01,0F
01044:  MOVFF  02,10
01048:  MOVFF  03,11
0104C:  BTFSS  FA0.4
0104E:  GOTO   1058
01052:  BTFSC  FA1.4
01054:  GOTO   20B0
01058:  MOVFF  0E,00
0105C:  MOVFF  0F,01
01060:  MOVFF  10,02
01064:  MOVFF  11,03
01068:  MOVFF  0C,FE9
0106C:  MOVFF  07,FEA
01070:  BSF    07.7
01072:  MOVFF  08,FE1
01076:  MOVFF  09,FE2
0107A:  MOVFF  0A,FD9
0107E:  MOVFF  0B,FDA
01082:  MOVFF  12,FF3
01086:  MOVFF  13,FF4
0108A:  MOVFF  14,FFA
0108E:  MOVFF  15,FFB
01092:  MOVF   04,W
01094:  MOVFF  06,FE0
01098:  MOVFF  05,FD8
0109C:  RETFIE 0
.................... #include "EMm47J53_StackConfig.h" 
.................... /* 
.................... ** ########################################################################## 
.................... **     Filename  : EMm47J53_StackConfig.h 
.................... **     Processor : PIC18F47J53 
.................... **     FileFormat: V1.00 
.................... **     DataSheet : PIC18F47J53 
.................... **     Compiler  : CCS Compiler V4.114 
.................... **     Date/Time : 14.12.2011, 11:00 
.................... ** 
.................... ** 
.................... ** 
.................... ** 
.................... **     (c) Copyright OCTOPLUS.2008-2011 
.................... **     OCTOPLUS.  
.................... **     Ernesto Andres Rincon Cruz 
.................... **     Republica de Colombia 
.................... **     http      : www.octoplusaz.com 
.................... **     mail      : soporte@octoplusaz.com 
.................... **  
.................... ** 
.................... **     Nota:  Todas las funciones estan debidamente probadas usando el  
.................... **            modulo EMm47J53 corriendo a una frecuencia de bus interno  
.................... **            de 12MHz. Para mas informacion www.octoplusaz.com/foros 
.................... ** ########################################################################### 
.................... */ 
.................... #ifndef _INC_OCTOPLUS_STACK_CONFIG_H 
.................... #define _INC_OCTOPLUS_STACK_CONFIG_H 
.................... #include <18F47J53.h> 
.................... //////////// Standard Header file for the PIC18F47J53 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F47J53 
0109E:  CLRF   FF7
010A0:  ADDLW  B2
010A2:  MOVWF  FF6
010A4:  MOVLW  10
010A6:  ADDWFC FF7,F
010A8:  MOVLW  00
010AA:  MOVWF  FF8
010AC:  TBLRD*+
010AE:  MOVF   FF5,W
010B0:  RETURN 0
010B2:  DATA 00,03
010B4:  DATA 02,FF
010B6:  DATA FF,FF
010B8:  DATA FF,FF
010BA:  DATA FF,FF
010BC:  DATA FF,FF
010BE:  DATA FF,FF
010C0:  DATA FF,FF
010C2:  CLRF   FF7
010C4:  ADDLW  D6
010C6:  MOVWF  FF6
010C8:  MOVLW  10
010CA:  ADDWFC FF7,F
010CC:  MOVLW  00
010CE:  MOVWF  FF8
010D0:  TBLRD*+
010D2:  MOVF   FF5,W
010D4:  RETURN 0
010D6:  DATA 00,FF
010D8:  DATA 02,FF
010DA:  DATA FF,FF
010DC:  DATA FF,FF
010DE:  DATA FF,FF
010E0:  DATA FF,FF
010E2:  DATA FF,FF
010E4:  DATA FF,FF
010E6:  CLRF   FF7
010E8:  ADDLW  FA
010EA:  MOVWF  FF6
010EC:  MOVLW  10
010EE:  ADDWFC FF7,F
010F0:  MOVLW  00
010F2:  MOVWF  FF8
010F4:  TBLRD*+
010F6:  MOVF   FF5,W
010F8:  RETURN 0
010FA:  DATA 40,00
010FC:  DATA 0B,00
010FE:  DATA 40,00
01100:  DATA 00,00
01102:  DATA 00,00
01104:  DATA 00,00
01106:  DATA 00,00
01108:  DATA 00,00
0110A:  DATA 00,00
0110C:  DATA 00,00
0110E:  DATA 00,00
01110:  DATA 00,00
01112:  DATA 00,00
01114:  DATA 00,00
01116:  DATA 00,00
01118:  DATA 00,00
0111A:  CLRF   FF7
0111C:  ADDLW  2E
0111E:  MOVWF  FF6
01120:  MOVLW  11
01122:  ADDWFC FF7,F
01124:  MOVLW  00
01126:  MOVWF  FF8
01128:  TBLRD*+
0112A:  MOVF   FF5,W
0112C:  RETURN 0
0112E:  DATA 40,00
01130:  DATA 00,00
01132:  DATA 40,00
01134:  DATA 00,00
01136:  DATA 00,00
01138:  DATA 00,00
0113A:  DATA 00,00
0113C:  DATA 00,00
0113E:  DATA 00,00
01140:  DATA 00,00
01142:  DATA 00,00
01144:  DATA 00,00
01146:  DATA 00,00
01148:  DATA 00,00
0114A:  DATA 00,00
0114C:  DATA 00,00
0114E:  CLRF   FF7
01150:  ADDLW  62
01152:  MOVWF  FF6
01154:  MOVLW  11
01156:  ADDWFC FF7,F
01158:  MOVLW  00
0115A:  MOVWF  FF8
0115C:  TBLRD*+
0115E:  MOVF   FF5,W
01160:  RETURN 0
01162:  DATA 09,02
01164:  DATA 43,00
01166:  DATA 02,01
01168:  DATA 00,80
0116A:  DATA 32,09
0116C:  DATA 04,00
0116E:  DATA 00,01
01170:  DATA 02,02
01172:  DATA 01,00
01174:  DATA 05,24
01176:  DATA 00,10
01178:  DATA 01,04
0117A:  DATA 24,02
0117C:  DATA 02,05
0117E:  DATA 24,06
01180:  DATA 00,01
01182:  DATA 05,24
01184:  DATA 01,00
01186:  DATA 01,07
01188:  DATA 05,81
0118A:  DATA 03,0B
0118C:  DATA 00,FA
0118E:  DATA 09,04
01190:  DATA 01,00
01192:  DATA 02,0A
01194:  DATA 00,00
01196:  DATA 00,07
01198:  DATA 05,02
0119A:  DATA 02,40
0119C:  DATA 00,01
0119E:  DATA 07,05
011A0:  DATA 82,02
011A2:  DATA 40,00
011A4:  DATA 01,00
011A6:  CLRF   FF7
011A8:  ADDLW  BA
011AA:  MOVWF  FF6
011AC:  MOVLW  11
011AE:  ADDWFC FF7,F
011B0:  MOVLW  00
011B2:  MOVWF  FF8
011B4:  TBLRD*+
011B6:  MOVF   FF5,W
011B8:  RETURN 0
011BA:  DATA 02,00
011BC:  CLRF   FF7
011BE:  ADDLW  D0
011C0:  MOVWF  FF6
011C2:  MOVLW  11
011C4:  ADDWFC FF7,F
011C6:  MOVLW  00
011C8:  MOVWF  FF8
011CA:  TBLRD*+
011CC:  MOVF   FF5,W
011CE:  RETURN 0
011D0:  DATA 12,17
011D2:  DATA 1B,20
011D4:  DATA FF,FF
011D6:  DATA FF,FF
011D8:  CLRF   FF7
011DA:  ADDLW  EC
011DC:  MOVWF  FF6
011DE:  MOVLW  11
011E0:  ADDWFC FF7,F
011E2:  MOVLW  00
011E4:  MOVWF  FF8
011E6:  TBLRD*+
011E8:  MOVF   FF5,W
011EA:  RETURN 0
011EC:  DATA 12,01
011EE:  DATA 10,01
011F0:  DATA 02,00
011F2:  DATA 00,40
011F4:  DATA 05,24
011F6:  DATA 0B,00
011F8:  DATA 00,01
011FA:  DATA 01,02
011FC:  DATA 00,01
011FE:  CLRF   FF7
01200:  ADDLW  12
01202:  MOVWF  FF6
01204:  MOVLW  12
01206:  ADDWFC FF7,F
01208:  MOVLW  00
0120A:  MOVWF  FF8
0120C:  TBLRD*+
0120E:  MOVF   FF5,W
01210:  RETURN 0
01212:  DATA 04,03
01214:  DATA 09,04
01216:  DATA 08,03
01218:  DATA 43,00
0121A:  DATA 43,00
0121C:  DATA 53,00
0121E:  DATA 20,03
01220:  DATA 43,00
01222:  DATA 43,00
01224:  DATA 53,00
01226:  DATA 20,00
01228:  DATA 55,00
0122A:  DATA 53,00
0122C:  DATA 42,00
0122E:  DATA 20,00
01230:  DATA 74,00
01232:  DATA 6F,00
01234:  DATA 20,00
01236:  DATA 55,00
01238:  DATA 41,00
0123A:  DATA 52,00
0123C:  DATA 54,00
*
02180:  DATA 0D,0A
02182:  DATA 2D,2D
02184:  DATA 25,73
02186:  DATA 2D,2D
02188:  DATA 00,00
0218A:  DATA 0D,0A
0218C:  DATA 0D,0A
0218E:  DATA 20,20
02190:  DATA 20,20
02192:  DATA 20,20
02194:  DATA 20,20
02196:  DATA 20,00
02198:  DATA 0D,0A
0219A:  DATA 0D,0A
0219C:  DATA 2D,2D
0219E:  DATA 46,41
021A0:  DATA 54,20
021A2:  DATA 53,74
021A4:  DATA 61,74
021A6:  DATA 73,2D
021A8:  DATA 2D,0D
021AA:  DATA 0A,00
021AC:  DATA 46,69
021AE:  DATA 72,73
021B0:  DATA 74,20
021B2:  DATA 46,41
021B4:  DATA 54,20
021B6:  DATA 73,74
021B8:  DATA 61,72
021BA:  DATA 74,73
021BC:  DATA 20,61
021BE:  DATA 74,3A
021C0:  DATA 20,30
021C2:  DATA 78,25
021C4:  DATA 6C,58
021C6:  DATA 0D,0A
021C8:  DATA 00,00
021CA:  DATA 44,61
021CC:  DATA 74,61
021CE:  DATA 20,53
021D0:  DATA 74,61
021D2:  DATA 72,74
021D4:  DATA 73,20
021D6:  DATA 41,74
021D8:  DATA 3A,20
021DA:  DATA 30,78
021DC:  DATA 25,6C
021DE:  DATA 58,0D
021E0:  DATA 0A,00
021E2:  DATA 52,6F
021E4:  DATA 6F,74
021E6:  DATA 20,44
021E8:  DATA 69,72
021EA:  DATA 65,63
021EC:  DATA 74,6F
021EE:  DATA 72,79
021F0:  DATA 20,49
021F2:  DATA 73,20
021F4:  DATA 41,74
021F6:  DATA 3A,20
021F8:  DATA 30,78
021FA:  DATA 25,6C
021FC:  DATA 58,0D
021FE:  DATA 0A,00
02200:  DATA 42,79
02202:  DATA 74,65
02204:  DATA 73,20
02206:  DATA 50,65
02208:  DATA 72,20
0220A:  DATA 43,6C
0220C:  DATA 75,73
0220E:  DATA 74,65
02210:  DATA 72,3A
02212:  DATA 20,30
02214:  DATA 78,25
02216:  DATA 6C,58
02218:  DATA 0D,0A
0221A:  DATA 00,00
0221C:  DATA 0D,0A
0221E:  DATA 0D,0A
02220:  DATA 2D,2D
02222:  DATA 00,00
02224:  DATA 20,49
02226:  DATA 6E,66
02228:  DATA 6F,2D
0222A:  DATA 2D,00
0222C:  DATA 0D,0A
0222E:  DATA 41,74
02230:  DATA 74,72
02232:  DATA 69,62
02234:  DATA 75,74
02236:  DATA 65,73
02238:  DATA 3A,20
0223A:  DATA 30,78
0223C:  DATA 25,58
0223E:  DATA 00,00
02240:  DATA 0D,0A
02242:  DATA 43,72
02244:  DATA 65,61
02246:  DATA 74,65
02248:  DATA 64,3A
0224A:  DATA 20,00
0224C:  DATA 0D,0A
0224E:  DATA 4D,6F
02250:  DATA 64,69
02252:  DATA 66,69
02254:  DATA 65,64
02256:  DATA 3A,20
02258:  DATA 00,00
0225A:  DATA 0D,0A
0225C:  DATA 53,74
0225E:  DATA 61,72
02260:  DATA 74,69
02262:  DATA 6E,67
02264:  DATA 20,63
02266:  DATA 6C,75
02268:  DATA 73,74
0226A:  DATA 65,72
0226C:  DATA 3A,20
0226E:  DATA 25,6C
02270:  DATA 58,00
02272:  DATA 0D,0A
02274:  DATA 53,74
02276:  DATA 61,72
02278:  DATA 74,69
0227A:  DATA 6E,67
0227C:  DATA 20,61
0227E:  DATA 64,64
02280:  DATA 72,65
02282:  DATA 73,73
02284:  DATA 3A,20
02286:  DATA 25,6C
02288:  DATA 58,00
0228A:  DATA 0D,0A
0228C:  DATA 53,69
0228E:  DATA 7A,65
02290:  DATA 3A,20
02292:  DATA 25,6C
02294:  DATA 75,20
02296:  DATA 42,79
02298:  DATA 74,65
0229A:  DATA 73,0D
0229C:  DATA 0A,00
0229E:  DATA 0D,0A
022A0:  DATA 4D,61
022A2:  DATA 6B,69
022A4:  DATA 6E,67
022A6:  DATA 20,66
022A8:  DATA 69,6C
022AA:  DATA 65,20
022AC:  DATA 27,25
022AE:  DATA 73,27
022B0:  DATA 3A,20
022B2:  DATA 00,00
022B4:  DATA 45,72
022B6:  DATA 72,6F
022B8:  DATA 72,20
022BA:  DATA 63,72
022BC:  DATA 65,61
022BE:  DATA 74,69
022C0:  DATA 6E,67
022C2:  DATA 20,66
022C4:  DATA 69,6C
022C6:  DATA 65,00
022C8:  DATA 43,6F
022CA:  DATA 75,6C
022CC:  DATA 64,20
022CE:  DATA 6E,6F
022D0:  DATA 74,20
022D2:  DATA 69,6E
022D4:  DATA 69,74
022D6:  DATA 20,74
022D8:  DATA 68,65
022DA:  DATA 20,4D
022DC:  DATA 4D,43
022DE:  DATA 2F,53
022E0:  DATA 44,21
022E2:  DATA 21,21
022E4:  DATA 21,00
022E6:  DATA 20,25
022E8:  DATA 6C,64
022EA:  DATA 20,0A
022EC:  DATA 0D,00
022EE:  DATA 20,25
022F0:  DATA 58,20
022F2:  DATA 0A,0D
022F4:  DATA 00,00
022F6:  DATA 20,25
022F8:  DATA 34,58
022FA:  DATA 20,0A
022FC:  DATA 0D,00
022FE:  DATA 20,25
02300:  DATA 6C,58
02302:  DATA 20,0A
02304:  DATA 0D,00
*
02BC6:  MOVLB  4
02BC8:  MOVF   xBF,W
02BCA:  MULWF  xC1
02BCC:  MOVFF  FF3,01
02BD0:  MOVFF  FF4,00
02BD4:  MULWF  xC2
02BD6:  MOVF   FF3,W
02BD8:  ADDWF  00,F
02BDA:  MOVF   xC0,W
02BDC:  MULWF  xC1
02BDE:  MOVF   FF3,W
02BE0:  ADDWFC 00,W
02BE2:  MOVWF  02
02BE4:  MOVLB  0
02BE6:  RETURN 0
02BE8:  MOVLB  6
02BEA:  CLRF   x20
02BEC:  CLRF   x21
02BEE:  MOVLW  01
02BF0:  MOVWF  x22
02BF2:  CLRF   FDA
02BF4:  CLRF   FD9
02BF6:  MOVLW  06
02BF8:  MOVWF  x25
02BFA:  MOVLW  18
02BFC:  MOVWF  x24
02BFE:  MOVLW  06
02C00:  MOVWF  FEA
02C02:  MOVLW  1C
02C04:  MOVWF  FE9
02C06:  MOVFF  625,FE2
02C0A:  MOVFF  624,FE1
02C0E:  MOVFF  622,623
02C12:  BCF    FD8.0
02C14:  MOVF   FE5,W
02C16:  MULWF  FEE
02C18:  MOVF   FF3,W
02C1A:  ADDWFC x20,F
02C1C:  MOVF   FF4,W
02C1E:  ADDWFC x21,F
02C20:  DECFSZ x23,F
02C22:  BRA    2C12
02C24:  MOVFF  620,FDE
02C28:  MOVFF  621,620
02C2C:  CLRF   x21
02C2E:  BTFSC  FD8.0
02C30:  INCF   x21,F
02C32:  INCF   x24,F
02C34:  BTFSC  FD8.2
02C36:  INCF   x25,F
02C38:  INCF   x22,F
02C3A:  MOVF   x22,W
02C3C:  SUBLW  05
02C3E:  BNZ   2BFE
02C40:  MOVLB  0
02C42:  RETURN 0
*
02F1E:  TBLRD*+
02F20:  MOVF   FF5,F
02F22:  BZ    2F44
02F24:  MOVFF  FF6,4AC
02F28:  MOVFF  FF7,4AD
02F2C:  MOVFF  FF8,4AE
02F30:  MOVFF  FF5,4B0
02F34:  RCALL  2F04
02F36:  MOVFF  4AC,FF6
02F3A:  MOVFF  4AD,FF7
02F3E:  MOVFF  4AE,FF8
02F42:  BRA    2F1E
02F44:  RETURN 0
02F46:  TBLRD*+
02F48:  MOVFF  FF6,4AD
02F4C:  MOVFF  FF7,4AE
02F50:  MOVFF  FF8,4AF
02F54:  MOVFF  FF5,4B0
02F58:  RCALL  2F04
02F5A:  MOVFF  4AD,FF6
02F5E:  MOVFF  4AE,FF7
02F62:  MOVFF  4AF,FF8
02F66:  MOVLB  4
02F68:  DECFSZ xAC,F
02F6A:  BRA    2F6E
02F6C:  BRA    2F72
02F6E:  MOVLB  0
02F70:  BRA    2F46
02F72:  MOVLB  0
02F74:  RETURN 0
02F76:  MOVF   FEF,F
02F78:  BZ    2F98
02F7A:  MOVFF  FEA,4AD
02F7E:  MOVFF  FE9,4AC
02F82:  MOVFF  FEF,4B0
02F86:  RCALL  2F04
02F88:  MOVFF  4AD,FEA
02F8C:  MOVFF  4AC,FE9
02F90:  INCF   FE9,F
02F92:  BTFSC  FD8.2
02F94:  INCF   FEA,F
02F96:  BRA    2F76
02F98:  GOTO   5F78 (RETURN)
*
03116:  BTFSC  FD8.1
03118:  BRA    3122
0311A:  MOVLW  05
0311C:  MOVWF  FEA
0311E:  MOVLW  EE
03120:  MOVWF  FE9
03122:  CLRF   00
03124:  CLRF   01
03126:  CLRF   02
03128:  CLRF   03
0312A:  MOVLB  5
0312C:  CLRF   xEE
0312E:  CLRF   xEF
03130:  CLRF   xF0
03132:  CLRF   xF1
03134:  MOVF   xED,W
03136:  IORWF  xEC,W
03138:  IORWF  xEB,W
0313A:  IORWF  xEA,W
0313C:  BZ    3196
0313E:  MOVLW  20
03140:  MOVWF  xF2
03142:  BCF    FD8.0
03144:  RLCF   xE6,F
03146:  RLCF   xE7,F
03148:  RLCF   xE8,F
0314A:  RLCF   xE9,F
0314C:  RLCF   xEE,F
0314E:  RLCF   xEF,F
03150:  RLCF   xF0,F
03152:  RLCF   xF1,F
03154:  MOVF   xED,W
03156:  SUBWF  xF1,W
03158:  BNZ   316A
0315A:  MOVF   xEC,W
0315C:  SUBWF  xF0,W
0315E:  BNZ   316A
03160:  MOVF   xEB,W
03162:  SUBWF  xEF,W
03164:  BNZ   316A
03166:  MOVF   xEA,W
03168:  SUBWF  xEE,W
0316A:  BNC   318A
0316C:  MOVF   xEA,W
0316E:  SUBWF  xEE,F
03170:  MOVF   xEB,W
03172:  BTFSS  FD8.0
03174:  INCFSZ xEB,W
03176:  SUBWF  xEF,F
03178:  MOVF   xEC,W
0317A:  BTFSS  FD8.0
0317C:  INCFSZ xEC,W
0317E:  SUBWF  xF0,F
03180:  MOVF   xED,W
03182:  BTFSS  FD8.0
03184:  INCFSZ xED,W
03186:  SUBWF  xF1,F
03188:  BSF    FD8.0
0318A:  RLCF   00,F
0318C:  RLCF   01,F
0318E:  RLCF   02,F
03190:  RLCF   03,F
03192:  DECFSZ xF2,F
03194:  BRA    3142
03196:  MOVFF  5EE,FEF
0319A:  MOVFF  5EF,FEC
0319E:  MOVFF  5F0,FEC
031A2:  MOVFF  5F1,FEC
031A6:  MOVLB  0
031A8:  RETURN 0
*
05304:  MOVFF  3AA,FEA
05308:  MOVFF  3A9,FE9
0530C:  MOVLB  5
0530E:  MOVFF  5AC,FEF
05312:  INCF   FE9,F
05314:  BTFSC  FD8.2
05316:  INCF   FEA,F
05318:  CLRF   FEF
0531A:  MOVLB  3
0531C:  INCF   xA9,F
0531E:  BTFSC  FD8.2
05320:  INCF   xAA,F
05322:  MOVLB  0
05324:  GOTO   53AC (RETURN)
05328:  MOVF   FE9,W
0532A:  MOVLB  5
0532C:  MOVWF  xA4
0532E:  MOVLW  3B
05330:  MOVWF  xAB
05332:  MOVLW  9A
05334:  MOVWF  xAA
05336:  MOVLW  CA
05338:  MOVWF  xA9
0533A:  CLRF   xA8
0533C:  MOVLW  0A
0533E:  MOVWF  xA6
05340:  BSF    FD8.1
05342:  MOVLW  05
05344:  MOVWF  FEA
05346:  MOVLW  A0
05348:  MOVWF  FE9
0534A:  MOVFF  5A3,5E9
0534E:  MOVFF  5A2,5E8
05352:  MOVFF  5A1,5E7
05356:  MOVFF  5A0,5E6
0535A:  MOVFF  5AB,5ED
0535E:  MOVFF  5AA,5EC
05362:  MOVFF  5A9,5EB
05366:  MOVFF  5A8,5EA
0536A:  MOVLB  0
0536C:  CALL   3116
05370:  MOVF   01,W
05372:  MOVF   00,F
05374:  BNZ   539C
05376:  MOVLB  5
05378:  MOVF   xA6,W
0537A:  XORLW  01
0537C:  BTFSS  FD8.2
0537E:  BRA    5384
05380:  MOVLB  0
05382:  BRA    539C
05384:  MOVF   xA4,W
05386:  BZ    53A0
05388:  ANDLW  0F
0538A:  SUBWF  xA6,W
0538C:  BZ    5390
0538E:  BC    53AE
05390:  BTFSC  xA4.7
05392:  BRA    53AE
05394:  BTFSC  xA4.6
05396:  BRA    53A0
05398:  MOVLW  20
0539A:  BRA    53A2
0539C:  MOVLB  5
0539E:  CLRF   xA4
053A0:  MOVLW  30
053A2:  ADDWF  00,F
053A4:  MOVFF  00,5AC
053A8:  MOVLB  0
053AA:  BRA    5304
053AC:  MOVLB  5
053AE:  BCF    FD8.1
053B0:  MOVFF  5AB,5E9
053B4:  MOVFF  5AA,5E8
053B8:  MOVFF  5A9,5E7
053BC:  MOVFF  5A8,5E6
053C0:  CLRF   xED
053C2:  CLRF   xEC
053C4:  CLRF   xEB
053C6:  MOVLW  0A
053C8:  MOVWF  xEA
053CA:  MOVLB  0
053CC:  CALL   3116
053D0:  MOVFF  03,5AB
053D4:  MOVFF  02,5AA
053D8:  MOVFF  01,5A9
053DC:  MOVFF  00,5A8
053E0:  MOVLB  5
053E2:  DECFSZ xA6,F
053E4:  BRA    5340
053E6:  MOVLB  0
053E8:  GOTO   5692 (RETURN)
*
059DA:  MOVLB  5
059DC:  MOVF   x6D,W
059DE:  XORWF  x6E,W
059E0:  ANDLW  80
059E2:  MOVWF  x70
059E4:  BTFSS  x6D.7
059E6:  BRA    59EC
059E8:  COMF   x6D,F
059EA:  INCF   x6D,F
059EC:  BTFSS  x6E.7
059EE:  BRA    59F4
059F0:  COMF   x6E,F
059F2:  INCF   x6E,F
059F4:  MOVF   x6E,W
059F6:  CLRF   01
059F8:  SUBWF  x6D,W
059FA:  BC    5A02
059FC:  MOVFF  56D,00
05A00:  BRA    5A1A
05A02:  CLRF   00
05A04:  MOVLW  08
05A06:  MOVWF  x6F
05A08:  RLCF   x6D,F
05A0A:  RLCF   00,F
05A0C:  MOVF   x6E,W
05A0E:  SUBWF  00,W
05A10:  BTFSC  FD8.0
05A12:  MOVWF  00
05A14:  RLCF   01,F
05A16:  DECFSZ x6F,F
05A18:  BRA    5A08
05A1A:  BTFSS  x70.7
05A1C:  BRA    5A22
05A1E:  COMF   01,F
05A20:  INCF   01,F
05A22:  MOVLB  0
05A24:  RETURN 0
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
.................... #FUSES NOWDT         //WDT disabled (enabled by SWDTEN bit)                     
.................... #FUSES PLL3          //Divide by 3 (12 MHz oscillator input)             
.................... #FUSES NOPLLEN       //PLL Disabled 
.................... #FUSES NOSTVREN      //stack overflow/underflow reset enabled                 
.................... #FUSES NOXINST       //Extended instruction set disabled             
.................... #FUSES NOCPUDIV      //No CPU system clock divide          
.................... #FUSES NOPROTECT     //Program memory is not code-protected           
.................... #FUSES HSPLL         //HS oscillator, PLL enabled, HSPLL used by USB            
.................... #FUSES SOSC_HIGH     //High Power T1OSC/SOSC circuit selected 
.................... #FUSES CLOCKOUT      //CLKO output enabled on the RA6 pin  
.................... #FUSES NOFCMEN       //Fail-Safe Clock Monitor disabled 
.................... #FUSES NOIESO        //Two-Speed Start-up disabled 
.................... #FUSES WDT32768      //Watchdog Postscaler 1:32768 
.................... #FUSES DSWDTOSC_INT  //DSWDT uses INTOSC/INTRC as clock 
.................... #FUSES RTCOSC_INT    //RTCC uses INTRC as clock 
.................... #FUSES NODSBOR       //Zero-Power BOR disabled in Deep Sleep 
.................... #FUSES NODSWDT       //Deep Sleep Watchdog Timer Disabled 
.................... #FUSES DSWDT8192     //Deep Sleep Watchdog Postscaler: 1:8,192 (8.5 seconds)    
.................... #FUSES NOIOL1WAY     //IOLOCK bit can be set and cleared 
.................... #FUSES ADC12         //ADC 10 or 12 Bit Select:12 - Bit ADC Enabed  
.................... #FUSES MSSPMSK7      //MSSP 7 Bit address masking 
.................... #FUSES NOWPFP        //Write Protect Program Flash Page 0 
.................... #FUSES NOWPCFG       //Write/Erase last page protect Disabled 
.................... #FUSES WPDIS         //WPFP[5:0], WPEND, and WPCFG bits ignored  
.................... #FUSES WPEND         //Start protection at page 0 
.................... #FUSES LS48MHZ       //Low Speed USB mode with 48 MHz System clock at 48 MHz USB CLKEN divide-by is set to 8  
.................... #use delay(clock=48000000) 
*
02400:  MOVLW  04
02402:  MOVWF  FEA
02404:  MOVLW  C1
02406:  MOVWF  FE9
02408:  MOVF   FEF,W
0240A:  BZ    2428
0240C:  MOVLW  0F
0240E:  MOVWF  01
02410:  CLRF   00
02412:  DECFSZ 00,F
02414:  BRA    2412
02416:  DECFSZ 01,F
02418:  BRA    2410
0241A:  MOVLW  8F
0241C:  MOVWF  00
0241E:  DECFSZ 00,F
02420:  BRA    241E
02422:  NOP   
02424:  DECFSZ FEF,F
02426:  BRA    240C
02428:  RETURN 0
....................  
.................... #pin_select U2TX=PIN_D2 //Selecciona hardware UART2 
.................... #pin_select U2RX=PIN_D3 //Selecciona hardware UART2 
....................  
....................  
.................... #define LOADER_END   0xFFF                         
.................... #build(reset=LOADER_END+1, interrupt=LOADER_END+9)   //Protege posiciones de memoria desde la 0x0000 hasta la 0x1000    
.................... #org 0, LOADER_END {} 
....................  
.................... #bit PLLEN = 0xf9b.6 
....................  
.................... #define mcu_init()\ 
.................... do{\ 
....................  PLLEN = 1;          /*Habilita PLL para generar 48MHz de oscilador*/\ 
.................... }while(0) 
....................  
.................... #endif /* _INC_OCTOPLUS_STACK_CONFIG_H */ 
....................  
.................... #use rs232(baud=9600,UART1) 
.................... #define DEC 0x00 
.................... #define HEX 0x01 
.................... /********************************************************/ 
.................... /*------- Espacio para declaracion de constantes  ------*/ 
.................... /********************************************************/ 
....................  
....................  
.................... /********************************************************/ 
.................... /*--- Espacio para declaracion de variables globales  --*/ 
.................... /********************************************************/ 
....................  
.................... /********************************************************/ 
.................... /********************************************************/ 
.................... /*-------------- Espacio para funciones  ---------------*/ 
.................... /********************************************************/ 
.................... #include <usb_cdc.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                            usb_cdc.h                            //// 
.................... ////                                                                 //// 
.................... //// Library for adding a virtual COM port on your PC over USB using //// 
.................... //// the standard Communication Device Class (CDC) specification.    //// 
.................... //// Including this file in your code will add all USB code,         //// 
.................... //// interrupts, descriptors and handlers required.  No other        //// 
.................... //// modifications need to be made.                                  //// 
.................... ////                                                                 //// 
.................... //// This library creates a virtual RS232 link between the PC and    //// 
.................... //// the PIC, therefore the library provided will be familiar to     //// 
.................... //// anyone with standard UART stream I/O:                           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          //// 
.................... ////      character received and waiting in the receive buffer.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  //// 
.................... ////      there is no data in the receive buffer it will wait until  //// 
.................... ////      there is data in the receive buffer.  If you do not want   //// 
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   //// 
.................... ////      check if there is data before calling usb_cdc_getc().      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       //// 
.................... ////      buffer.  If the transmit buffer is full it will wait until //// 
.................... ////      the transmit buffer is not full before putting the char    //// 
.................... ////      into the transmit buffer.  The transmit buffer is read by  //// 
.................... ////      the PC very quickly, and therefore the buffer should only  //// 
.................... ////      be full for a few milli-seconds.  If you are concerned     //// 
.................... ////      and don't want to be stuck in a long or infinite loop,     //// 
.................... ////      use usb_cdc_putready() to see if there is space in the     //// 
.................... ////      transmit buffer before putting data into the transmit      //// 
.................... ////      buffer.                                                    //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_puts(*ptr) - Sends the null terminated string to the    //// 
.................... ////     the transmit buffer.  Unlike usb_cdc_putc() or              //// 
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    //// 
.................... ////     one packet (whereas the other functions will flush the      //// 
.................... ////     buffer as soon as the endpoint is free).                    //// 
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    //// 
.................... ////     was still in use.                                           //// 
.................... ////     Will stop copying characters from ptr to the endpoint       //// 
.................... ////     buffer once it is full (but it will still return TRUE).     //// 
.................... ////     'ptr' needs to be smaller than the transmit buffer.         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putd(*ptr, len) - Sends 'len' byte from 'ptr' to the    //// 
.................... ////     transmit buffer.  Unlike usb_cdc_putc() or                  //// 
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    //// 
.................... ////     one packet (whereas the other functions will flush the      //// 
.................... ////     buffer as soon as the endpoint is free).                    //// 
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    //// 
.................... ////     was still in use.                                           //// 
.................... ////     Will stop copying characters from ptr to the endpoint       //// 
.................... ////     buffer once it is full (but it will still return TRUE).     //// 
.................... ////     'len' needs to be smaller than the transmit buffer.         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putready() - Returns the number of bytes available      //// 
.................... ////     in the TX buffer for storing characters.  If this returns   //// 
.................... ////     0 then the buffer is full and waiting for the host (PC)     //// 
.................... ////     to read the buffer.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putempty() - Returns TRUE if the transmit buffers are   //// 
.................... ////     empty and fully flushed/transmitted to host (PC).           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_connected() - Returns TRUE if we received a             //// 
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   //// 
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        //// 
.................... ////      message when the program starts and it opens the virtual   //// 
.................... ////      COM port.  This is a simple way to determine if the PC     //// 
.................... ////      is ready to display data on a serial terminal program,     //// 
.................... ////      but is not garaunteed to work all the time or on other     //// 
.................... ////      terminal programs.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   //// 
.................... ////      if the transmit buffer is full it will skip the char.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  //// 
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_break - If the PC has sent a break command, this will   //// 
.................... ////       hold the break time (in milli-seconds).  If the PC sends  //// 
.................... ////       a value of 0xFFFF the device is supposed to hold the      //// 
.................... ////       break until it sends a value of 0                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. //// 
.................... ////       Of most relevance is the field dte_present, which is the  //// 
.................... ////       DTR setting.                                              //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_serial_state(state) - Transmit to the host our          //// 
.................... ////       SERIAL_STATE.  This holds information such as DCD, DSR,   //// 
.................... ////       ring, break and more.  See the documentation above        //// 
.................... ////       usb_cdc_serial_state() for more information, including    //// 
.................... ////       format of state structure.                                //// 
.................... ////                                                                 //// 
.................... //// The following functions are also provided, and are ports of the //// 
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   //// 
.................... //// documentation:                                                  //// 
.................... ////   get_float_usb() - Read a float number from the user           //// 
.................... ////   get_long_usb() - Read a long number from the user             //// 
.................... ////   get_int_usb() - Read an integer number from the user          //// 
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. //// 
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             //// 
.................... ////   gethex1_usb() - Read a HEX character                          //// 
.................... ////                                                                 //// 
.................... //// USB_CDC_ISR() can be defined if you want a specific routine to  //// 
.................... //// be called when there is incoming CDC (virtual com port) data.   //// 
.................... //// This is useful if you want to update legacy RS232 code that     //// 
.................... //// was using #int_rda to handle incoming data in the RS232 ISR.    //// 
.................... //// However, see the INTERRUPT LIMITATIONS section below.           //// 
.................... ////                                                                 //// 
.................... //// Normally usb_cdc_putc() and usb_cdc_putc_fast() will attempt    //// 
.................... ////  to flush the data as soon as possible.  However at times       //// 
.................... ////  this can be ineffecient and flush a packet with only 1 byte.   //// 
.................... ////  The USB_CDC_DELAYED_FLUSH option will attempt to flush         //// 
.................... ////  at the beginning of usb_cdc_putc() and usb_cdc_putc_fast()     //// 
.................... ////  if the local buffer is full.  USB_CDC_DELAYED_FLUSH will       //// 
.................... ////  also attempt to flush the packet on each call to usb_task().   //// 
.................... ////  It is recommended to only use USB_CDC_DELAYED_FLUSH option     //// 
.................... ////  if you have a main loop that periodically calls usb_task().    //// 
.................... ////                                                                 //// 
.................... //// This driver will load all the rest of the USB code, and a set   //// 
.................... //// of descriptors that will properly describe a CDC device for a   //// 
.................... //// virtual COM port (usb_desc_cdc.h)                               //// 
.................... ////                                                                 //// 
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      //// 
.................... //// standard CDC drivers for a virtual COM port in Windows          //// 
.................... //// NT/2000/XP and above.                                           //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// BUFFER SIZES                                                    //// 
.................... //// -------------------------------------------------------------   //// 
.................... //// USB_CDC_DATA_IN_SIZE controls the PIC->PC buffer size.  The     //// 
.................... ////  total buffer size will be ((USB_CDC_DATA_IN_SIZE*2)-1).        //// 
.................... ////  Full speed devices limit this value to be 64.  To increase     //// 
.................... ////  the size of the local PIC buffer you can also define           //// 
.................... ////  USB_CDC_DATA_LOCAL_SIZE.  If USB_CDC_DATA_LOCAL_SIZE is        //// 
.................... ////  defined then the total PIC->PC buffer size would be            //// 
.................... ////  USB_CDC_DATA_LOCAL_SIZE+USB_CDC_DATA_IN_SIZE.                  //// 
.................... ////  If USB_CDC_DATA_IN_SIZE is not defined, the default value      //// 
.................... ////  of 64 is used.  If USB_CDC_DATA_LOCAL_SIZE is not defined      //// 
.................... ////  then this option isn't used.                                   //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// INTERRUPT LIMITATIONS                                           //// 
.................... //// -------------------------------------------------------------   //// 
.................... //// This section is only relevant if you are using USB interrupts   //// 
.................... ////  and not the USB_ISR_POLLING option.                            //// 
.................... ////                                                                 //// 
.................... //// USB handling is complex, often requiring several packet         //// 
.................... ////  transmissions to accomplish transfer of one block of data.     //// 
.................... ////  Most of this processing is done in the USB ISR.  Because       //// 
.................... ////  of this you cannot call usb_cdc_putc() inside another ISR, the //// 
.................... ////  USB ISR or when ISRs are disabled.  To workaround this problem,   //// 
.................... ////  use usb_cdc_putc_fast() and the USB_CDC_DELAYED_FLUSH option.  //// 
.................... ////  This isn't perfect, because if you use usb_cdc_putc_fast() to  //// 
.................... ////  overflow the TX buffer than data will be lost.                 //// 
.................... ////                                                                 //// 
.................... //// You also cannot call usb_cdc_getc() inside another ISR, the USB //// 
.................... ////  ISR, USB_CDC_ISR() or when interrupts are disabled UNLESS      //// 
.................... ////  usb_cdc_kbhit() returns TRUE.  It is for this reason           //// 
.................... ////  ex_usb_serial3.c uses a statemachine for reception of data.    //// 
.................... ////                                                                 //// 
.................... //// ex_usb_serial3.c shows an example of working around these       //// 
.................... ////  ISR limitations.  Failure to follow these limitations can      //// 
.................... ////  cause the PIC to lockup.  These limtations only need to be     //// 
.................... ////  followed in the conditions listed above (writing code in the   //// 
.................... ////  ISR or interrupts are disabled).                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// VERSION HISTORY                                                 //// 
.................... ////                                                                 //// 
.................... //// May 31st, 2013:                                                 //// 
.................... ////  usb_cdc_putready() now returns the number of bytes available.  //// 
.................... ////                                                                 //// 
.................... //// May 23rd, 2013:                                                 //// 
.................... ////  Added usb_cdc_putd().                                          //// 
.................... ////                                                                 //// 
.................... //// February 18th, 2013:                                            //// 
.................... ////  Enhanced PIC16 support added.                                  //// 
.................... ////  Added USB_CDC_ISR(), USB_CDC_DELAYED_FLUSH and                 //// 
.................... ////     USB_CDC_DATA_LOCAL_SIZE.                                    //// 
.................... ////                                                                 //// 
.................... //// September 13th, 2012:                                           //// 
.................... ////  Fixed a possible corruption that would occur on 16bit PICs     //// 
.................... ////     (PIC24, dsPIC33).                                           //// 
.................... ////  Added usb_cdc_putempty().                                      //// 
.................... ////                                                                 //// 
.................... //// December 16th, 2011:                                            //// 
.................... ////  Added __USB_CDC_HELPERS_ONLY__.  If defined, this library will //// 
.................... ////     only include the get string helper functions.  This is      //// 
.................... ////     a rarely used option, used only if you already wrote your   //// 
.................... ////     own getc() and putc() routines.                             //// 
.................... ////  usb_cdc_flush_tx_buffer() checks len buffer before flushing .  //// 
.................... ////  usb_isr_tok_in_cdc_data_dne() doesn't check len, now that      //// 
.................... ////     usb_cdc_flush_tx_buffer() is checking len.                  //// 
.................... ////                                                                 //// 
.................... //// Oct 27th, 2011:                                                 //// 
.................... ////  Added SERIAL_STATE support.  See usb_cdc_serial_state() for    //// 
.................... ////     documentation.  In order for this to work,                  //// 
.................... ////     USB_CDC_COMM_IN_SIZE has to be 11 bytes or bigger.          //// 
.................... ////                                                                 //// 
.................... //// Oct 15th, 2010:                                                 //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?  //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     //// 
.................... ////     will not be used.  usb_task() must be called periodically   //// 
.................... ////     in your main loop.  If it is not called faster than once    //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).   //// 
.................... ////                                                                 //// 
.................... //// Jan 28, 2010:                                                   //// 
.................... ////  Added usb_cdc_puts(str), which will fit the entire str into    //// 
.................... ////     one packet.                                                 //// 
.................... ////                                                                 //// 
.................... //// Jan 25, 2010:                                                   //// 
.................... ////  Ignore incoming 0 length packets.                              //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// April 7th, 2009:                                                //// 
.................... ////   Vista 'code 10' issues resolved.                              //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 26th, 2007:                                                 //// 
.................... ////              usb_cdc_put_buffer_free() should be more stable.   //// 
.................... ////              Fixed a hang-up that would happen if you sent      //// 
.................... ////                 exactly 64 bytes.                               //// 
.................... ////                                                                 //// 
.................... //// Nov 6th, 2007:                                                  //// 
.................... ////              Compatabible with latest pic18_usb.h, which        //// 
.................... ////                 reduces RAM footprint of USB driver.            //// 
.................... ////              This driver now fits on 18F4450/2450 PICs.         //// 
.................... ////                                                                 //// 
.................... //// October 27th, 2005: Changed the way incoming packets are        //// 
.................... ////               handled in that CDC driver will not flush         //// 
.................... ////               endpoint until user has handled all data.  This   //// 
.................... ////               will prevent overflows as the USB will NAK        //// 
.................... ////               incoming packets until it is ready to receive     //// 
.................... ////               more.                                             //// 
.................... ////            When using 18F4550 family, the RX buffer is          //// 
.................... ////               mapped directly to the endpoint buffer - this     //// 
.................... ////               saves a chunk of RAM.                             //// 
.................... ////            When using the 18F4550 family, you can increase      //// 
.................... ////               the TX and RX size over 64 bytes.                 //// 
.................... ////            No longer send 0len packets in the TBE interrupt.    //// 
.................... ////            Hopefully fixed bugs that caused random crashes      //// 
.................... ////               if you tried sending more than 64 bytes.          //// 
.................... ////                                                                 //// 
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   //// 
.................... ////                   buffer.                                       //// 
.................... ////                                                                 //// 
.................... //// July 1st, 2005: Initial Release.                                //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
....................  
.................... #if !defined(__USB_CDC_HELPERS_ONLY__) 
....................  
.................... //api for the user: 
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got) 
.................... #define usb_cdc_putempty() ((usb_cdc_put_buffer_nextin==0) && usb_cdc_put_buffer_free()) 
.................... #define usb_cdc_putready() (sizeof(usb_cdc_put_buffer)-usb_cdc_put_buffer_nextin) 
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding) 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
.................... void usb_cdc_get_discard(void); 
....................  
.................... //functions automatically called by USB handler code 
.................... void usb_isr_tkn_cdc(void); 
.................... void usb_cdc_init(void); 
.................... void usb_isr_tok_out_cdc_control_dne(void); 
.................... void usb_isr_tok_in_cdc_data_dne(void); 
.................... void usb_isr_tok_out_cdc_data_dne(void); 
....................  
.................... void usb_cdc_flush_tx_buffer(void); 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // Include the CCS USB Libraries.  See the comments at the top of these 
.................... // files for more information 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... #ifndef __USB_PIC_PERIF__ 
.................... #define __USB_PIC_PERIF__   1 
.................... #endif 
....................  
.................... #if __USB_PIC_PERIF__ 
....................    #if defined(__PCM__) 
....................     #include <pic16f_usb.h>   //Microchip PIC16Fxxxx hardware layer for usb.c 
....................    #elif defined(__PCH__) 
....................     #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.h                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC18 family chips.  Current //// 
.................... //// supported families are:                                         //// 
.................... ////     PIC18F2455/2550/4455/4550                                   //// 
.................... ////     PIC18F2450/4450                                             //// 
.................... ////     PIC18F2458/2553/4458/4553                                   //// 
.................... ////     PIC18F13K50/14K50                                           //// 
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     //// 
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       //// 
.................... ////     PIC18FxxK50                                                 //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      //// 
.................... //// that are specific to only this HW peripheral that you may       //// 
.................... //// find useful to use in your application.                         //// 
.................... ////                                                                 //// 
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    //// 
.................... ////  Due to the limited USB RAM of this family, a limitation of     //// 
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   //// 
.................... ////  The HW actually supports more endpoints, but to simplify       //// 
.................... ////  driver development this driver will only support the first 3   //// 
.................... ////  so there is an easier memory block to work with.               //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on Vusb, even if you are      //// 
.................... ////  using the internal 3.3V USB regulator.                         //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Feb 22, 2013:                                                   //// 
.................... ////  Added support for 18F45K50 family.                             //// 
.................... ////                                                                 //// 
.................... //// Dec 16, 2010:                                                   //// 
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_H__ 
.................... #DEFINE __PIC18_USB_H__ 
....................  
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   1 
.................... #endif 
....................  
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH 
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50")) 
....................    //due to limited ram, force max packet length to 8 for this chip 
....................    #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................    #if USB_USE_FULL_SPEED==0 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
.................... #endif 
....................  
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8)) 
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8 
....................  #error Max Endpoint 0 length can't be less than 8! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64 
....................  #error Max Endpoint 0 length can't be greater than 64! 
.................... #endif 
....................  
.................... #include <usb_hw_layer.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_hw_layer.h                            //// 
.................... ////                                                                   //// 
.................... //// HW Layer for the USB Stack.                                       //// 
.................... ////                                                                   //// 
.................... //// HW drivers for the USB stack must support this API.               //// 
.................... ////                                                                   //// 
.................... //// The HW driver must also have a token handler that will call       //// 
.................... //// usb_token_reset() when the device is init/reset, will call        //// 
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          //// 
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    //// 
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     //// 
.................... //// See usb.h for documentation of these functions.                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __USB_HW_LAYER_H__ 
.................... #define __USB_HW_LAYER_H__ 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
....................  
.................... // USER LEVEL FUNCTIONS: 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_cs(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt. 
.................... /*  
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* If the user does call this function while USB is connected, the USB  
.................... /* peripheral will be disabled only momentarily because usb_task() will 
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB 
.................... /* reset of the device. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_put_packet() 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to (0..15). 
.................... /*        ptr - points to data to send. 
.................... /*        len - amount of data to send. 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid,  
.................... /*                 or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only  
.................... /*         reason it will return FALSE is if because the TX buffer is still full  
.................... /*         from the last time it tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a  
.................... /*          difference between a packet and a message.  If you wanted to send a  
.................... /*          512 byte message on an endpoint that only supported 64 byte packets, 
.................... /*          this would be accomplished this by sending 8 64-byte packets,  
.................... /*          followed by a 0 length packet.  If the last (or only packet) being  
.................... /*          sent is less than the max packet size defined in your descriptor  
.................... /*          then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message  
.................... /*          correctly and know if a 0 lenght packet needs to be sent. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer and saved to ptr. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB endpoint buffer. 
.................... /*          Until this is called, if there is data in the receive buffer the 
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion 
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be 
.................... /*          allowed to send a new packet.  Only receives one packet, if you need  
.................... /*          to receive multiple packets or handle 0-length terminator packets, 
.................... /*          then use usb_gets(). 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max); 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check (0..15) 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /*          See API section of USB.H for more information. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_kbhit(unsigned int8 en); 
....................  
.................... /****************************************************************************** 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_tbe(unsigned int8 en); 
....................  
.................... //////////////// END USER LEVEL FUNCTIONS ///////////////////////////////////// 
....................  
....................  
.................... /// 
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by 
.................... ///            the USB stack, and are not meant to be called by the  
.................... ///            user/application. 
.................... /// 
....................  
.................... /***************************************************************************** 
.................... /* usb_stall_ep() 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will 
.................... /*          send STALL packet if the host tries to access this endpoint's  
.................... /*          buffer. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_stall_ep(unsigned int8 endpoint); 
....................  
....................  
.................... /***************************************************************************** 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_unstall_ep(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_endpoint_stalled() 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and  
.................... /*          Clear_Feature Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.   
.................... /*          The host will now talk to use with the following address. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_address(unsigned int8 address); 
....................  
.................... /****************************************************************************** 
.................... /* usb_set_configured() 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_configured(unsigned int8 config); 
....................  
.................... /****************************************************************************** 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints (all endpoints but 0) 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_disable_endpoints(void); 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoint() 
.................... /* 
.................... /* Input: Endpoint to disable (0..15) 
.................... /* 
.................... /* Summary: Disables specified endpoint 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoint(unsigned int8 en); 
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: One of these 3 functions will be called by the USB stack after 
.................... /*          handling a SETUP packet. 
.................... /*           
.................... /*          After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /*          The operation of these functions depends on how SETUP packets 
.................... /*          are handled in the hardware layer. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(unsigned int8 len); 
.................... void usb_request_get_data(void); 
.................... void usb_request_stall(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //////////////////////// EXTRA USER FUNCTIONS ///////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC). 
.................... /*          This routine is useful if you want to setup an endpoint by 
.................... /*          writing to the buffer directly. 
.................... /*          This routine is not necessary if you use usb_put_packet(). 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for release 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not 
.................... /*          want to use usb_get_packet(), instead you want to handle with 
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size(). 
.................... /*          This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_rx_packet_size() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark to check 
.................... /* 
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer. 
.................... /* 
.................... /* Summary: Read the number of data stored in the receive buffer.  When you 
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The 
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint. 
.................... /*    This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... int16 usb_rx_packet_size(int8 endpoint); 
....................  
.................... #ENDIF 
....................  
....................    #else 
....................     #include <pic24_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
....................    #endif 
.................... #else 
....................    #include <usbn960x.h> 
.................... #endif 
.................... #ifndef __USB_DESCRIPTORS__ 
.................... #include <usb_desc_cdc.h>   //USB Configuration and Device descriptors for this USB device 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_cdc.h                            //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Oct 27th, 2011:                                                   //// 
.................... ////   Increased USB_CDC_COMM_IN_SIZE default size to 11 so we can     //// 
.................... ////     send SERIAL_STATE messages in one packet.                     //// 
.................... ////                                                                   //// 
.................... //// April 7th, 2009:                                                  //// 
.................... ////   Vista 'code 10' issues resolved.                                //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// 10/28/05:                                                         //// 
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        //// 
.................... ////    packets.                                                       //// 
.................... ////    Changed device to USB 1.10                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... ///////// config options, although it's best to leave alone for this demo ///// 
.................... #ifndef  USB_CONFIG_PID 
....................    #define  USB_CONFIG_PID       0x000b 
....................    //#define  USB_CONFIG_PID       0x0033    //pre 5.013 value 
.................... #endif 
.................... #ifndef  USB_CONFIG_VID 
....................    #define  USB_CONFIG_VID       0x2405 
....................    //#define  USB_CONFIG_VID       0x0461    //pre 5.013 value 
.................... #endif 
.................... #ifndef  USB_CONFIG_BUS_POWER 
....................    #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500) 
.................... #endif 
.................... #ifndef  USB_CONFIG_VERSION 
....................    #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99 
.................... #endif 
.................... //////// end config /////////////////////////////////////////////////////////// 
....................  
.................... #DEFINE USB_HID_DEVICE  FALSE 
.................... #DEFINE USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #ifndef USB_CDC_COMM_IN_SIZE 
.................... #define USB_CDC_COMM_IN_SIZE           11 
.................... #endif 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #ifndef USB_CDC_DATA_IN_SIZE 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #endif 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #ifndef USB_CDC_DATA_OUT_SIZE 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #endif 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................         #if USB_CONFIG_BUS_POWER 
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #else 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #endif 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8 
....................  
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58 
....................          1,  //polling interval, in ms.   ==59 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67 
....................          1,  //polling interval, in ms.   ==68 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFF,0xFF,0xFF,0xFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10 
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12 
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #if !defined(USB_STRINGS_OVERWRITTEN) 
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
.................... // Strings are saved as unicode. 
.................... // These strings are mostly only displayed during the add hardware wizard. 
.................... // Once the operating system drivers have been installed it will usually display 
.................... // the name from the drivers .INF. 
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1  - manufacturer 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 - product 
....................          32, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................          ' ',0, 
....................          'U',0, 
....................          'S',0, 
....................          'B',0, 
....................          ' ',0, 
....................          't',0, 
....................          'o',0, 
....................          ' ',0, 
....................          'U',0, 
....................          'A',0, 
....................          'R',0, 
....................          'T',0 
.................... }; 
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN) 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... struct { 
....................    int1 got; 
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100 
....................    unsigned int16 len; 
....................    unsigned int16 index; 
....................   #else 
....................    unsigned int8 len; 
....................    unsigned int8 index; 
....................   #endif 
.................... } usb_cdc_get_buffer_status; 
....................  
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The functions that are meant to be     //// 
.................... //// called by the user (init, put packet, get packet, etc) are        //// 
.................... //// documented in USB.H.                                              //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must must provide the API as described in usb_hw_layer.h.         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// June 8th, 2011:                                                   //// 
.................... ////  Problem with usb_gets() and usb_puts() and specifying timeout=0  //// 
.................... ////     (for no timeout) resolved.                                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// November 13th, 2009:                                              //// 
.................... ////  usb_endpoint_is_valid() has an extra check.                      //// 
.................... ////                                                                   //// 
.................... //// June 9th, 2009:                                                   //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// Dec 14, 2007:                                                     //// 
.................... ////  usb_kbhit() moved to device driver.                              //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #if defined(__DO_DEBUG_USB) 
....................    #define debug_usb printf 
....................    void debug_putc(char c) {uart_putc(c);} 
....................    void debug_display_ram(unsigned int8 len, unsigned int8 *ptr) { 
....................       unsigned int8 max=16; 
....................       debug_usb(debug_putc,"[%U - ",len); 
....................       //if (max>len) {max=len;} 
....................       max = len; 
....................       while(max--) { 
....................          debug_usb(debug_putc,"%02X",*ptr); 
....................          len--; 
....................          ptr++; 
....................       } 
....................       if (len) {debug_usb(debug_putc,"...");} 
....................       debug_usb(debug_putc,"] "); 
....................    } 
.................... #else 
....................    #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................    #define debug_putc(c) 
....................    #define debug_display_ram(x,y) 
.................... #endif 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #if defined(__PIC16F_USB_H__) 
....................  #include <pic16f_usb.c> 
.................... #endif 
....................  
.................... #if defined(__PIC18_USB_H__) 
....................  #include <pic18_usb.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     //// 
.................... //// documentation about the PIC18 hardware layer.                   //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Feb 22, 2013:                                                   //// 
.................... ////  Added support for 18F45K50 family.                             //// 
.................... ////                                                                 //// 
.................... //// July 9th, 2012:                                                 //// 
.................... ////  Removed the clearing of the UOWN bit inside token done ISR     //// 
.................... ////     for non-setup packets on endpoint 0 or all other            //// 
.................... ////     endpoints.  This really only affects people using           //// 
.................... ////     usb_put_packet() or usb_get_packet() inside of other        //// 
.................... ////     interrupts.                                                 //// 
.................... ////                                                                 //// 
.................... //// Sep 22, 2011:                                                   //// 
.................... ////  Added USB_NO_ISR_PREPROCESSOR.  This is a rarely used option   //// 
.................... ////     primarily developed for users developing code where         //// 
.................... ////     usb_isr() is called by a #int_global instead of #int_usb.   //// 
.................... ////                                                                 //// 
.................... //// Dec 16, 2010:                                                   //// 
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           //// 
.................... ////                                                                 //// 
.................... //// Oct 15th, 2010:                                                 //// 
.................... ////  Added initial 18F47J53 family support.                         //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     //// 
.................... ////     will not be used.  usb_task() must be called periodically   //// 
.................... ////     in your main loop.  If it is not called faster than once    //// 
.................... ////     per millisecond, USB may not work.                          //// 
.................... ////                                                                 //// 
.................... //// Nov 13th, 2009:                                                 //// 
.................... ////  usb_disable_endpoint() won't touch BD status registers for     //// 
.................... ////     endpoints that aren't allocated.                            //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_C__ 
.................... #DEFINE __PIC18_USB_C__ 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #bit USBIE=getenv("BIT:USBIE") 
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \ 
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \ 
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \ 
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50")) 
....................  #define __USB_87J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F45K50") ||  \ 
....................        (getenv("DEVICE")=="PIC18F25K50") ||  \ 
....................        (getenv("DEVICE")=="PIC18F24K50") || \ 
....................        (getenv("DEVICE")=="PIC18LF45K50") ||  \ 
....................        (getenv("DEVICE")=="PIC18LF25K50") ||  \ 
....................        (getenv("DEVICE")=="PIC18LF24K50")) 
....................  #define __USB_45K50__ 
....................  #define USB_TOTAL_RAM_SPACE  1024 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16  
....................  #define USB_PIC_NO_USB_GPIO  //D+ and D- are not shared with any GPIO 
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \ 
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \ 
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50")) 
....................  #define __USB_46J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450")) 
....................  #define __USB_4450__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || \ 
....................        (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50")) 
....................  #define __USB_K50__ //backwards compatability 
....................  #define __USB_14K50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100) 
....................  #define USB_RAM_START  0x200 
....................  #define USB_NUM_UEP 8 
....................  //technically this device supports 8 endpoints, but for RAM reasons you should 
....................  //attempt to only use the first 3 endpoints. 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \ 
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \ 
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \ 
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") \ 
....................        ) 
....................  #define __USB_4550__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F26J53") || (getenv("DEVICE")=="PIC18F27J53") || \ 
....................        (getenv("DEVICE")=="PIC18F46J53") || (getenv("DEVICE")=="PIC18F47J53") \ 
....................        ) 
....................  #define __USB_18FJ53__ 
....................  #define USB_TOTAL_RAM_SPACE  (0xE00) //0x000:0xDFF.  save 0x00:0xFF for compiler use 
....................  #define USB_BDT_START  0xD00 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library. 
.................... #endif 
....................  
.................... #if !defined(USB_BDT_START) 
.................... #define USB_BDT_START   USB_RAM_START 
.................... #endif 
....................  
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  15 
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  14 
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  13 
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  12 
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  11 
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  10 
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  9 
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  8 
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  7 
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  6 
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  5 
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  4 
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  3 
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  2 
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  1 
.................... #else 
....................  #define USB_LAST_DEFINED_ENDPOINT  0 
.................... #endif 
....................  
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8) 
....................  
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\ 
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\ 
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\ 
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\ 
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\ 
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\ 
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\ 
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\ 
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\ 
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\ 
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if defined(USB_RAM_START) 
....................    #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE) 
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle 
....................    #endif 
.................... #else 
....................    #if (USB_DATA_BUFFER_NEEDED > USB_TOTAL_RAM_SPACE) 
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle 
....................    #endif 
.................... #endif 
....................  
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT) 
....................  #error You are trying to use an invalid endpoint for this hardware! 
.................... #endif 
....................  
.................... #if defined(USB_RAM_START) 
.................... #define USB_DATA_BUFFER_LOCATION ((int16)USB_RAM_START+USB_CONTROL_REGISTER_SIZE) 
.................... #else 
.................... #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM) 
.................... #endif 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8 stat; 
....................    unsigned int8 cnt; 
....................    unsigned int16 addr; 
.................... } STRUCT_BD; 
....................  
.................... #if defined(USB_RAM_START) 
.................... struct 
.................... { 
....................    struct 
....................    { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
....................    } bd[USB_LAST_DEFINED_ENDPOINT+1]; 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... #locate g_USBRAM=USB_RAM_START 
.................... #define g_USBBDT g_USBRAM.bd 
.................... #else 
.................... struct 
.................... { 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... struct 
.................... { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
.................... } g_USBBDT[USB_LAST_DEFINED_ENDPOINT+1]; 
.................... #locate g_USBBDT=USB_BDT_START 
.................... #endif 
....................  
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer 
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer 
....................  
.................... //these buffer definitions needed for CDC library 
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer 
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer 
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer 
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #if !defined(USB_USE_ERROR_COUNTER) 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #if !defined(USB_PING_PONG_MODE) 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    unsigned int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #if defined(__USB_4550__) || defined(__USB_4450__) 
....................    #byte UFRML   =  0xF66 
....................    #byte UFRMH   =  0xF67 
....................    #byte UIR     =  0xF68 
....................    #byte UIE     =  0xF69 
....................    #byte UEIR    =  0xF6A 
....................    #byte UEIE    =  0xF6B 
....................    #byte U1STAT   =  0xF6C 
....................    #byte UCON    =  0xF6D 
....................    #byte UADDR   =  0xF6E 
....................    #byte UCFG    =  0xF6F 
....................    #define  UEP0_LOC 0xF70 
.................... #elif defined(__USB_46J50__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #elif defined(__USB_14K50__) 
....................    #byte UFRML   =  0xF5D 
....................    #byte UFRMH   =  0xF5E 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF60 
....................    #byte UEIR    =  0xF5F 
....................    #byte UEIE    =  0xF5B 
....................    #byte U1STAT   =  0xF63 
....................    #byte UCON    =  0xF64 
....................    #byte UADDR   =  0xF5C 
....................    #byte UCFG    =  0xF61 
....................    #define  UEP0_LOC 0xF53 
.................... #elif defined(__USB_18FJ53__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #else 
....................    #byte UFRML = getenv("SFR:UFRML") 
....................    #byte UFRMH = getenv("SFR:UFRMH") 
....................    #byte UIR = getenv("SFR:UIR") 
....................    #byte UIE = getenv("SFR:UIE") 
....................    #byte UEIR = getenv("SFR:UEIR") 
....................    #byte UEIE = getenv("SFR:UEIE") 
....................    #byte U1STAT = getenv("SFR:USTAT") 
....................    #byte UCON = getenv("SFR:UCON") 
....................    #byte UADDR = getenv("SFR:UADDR") 
....................    #byte UCFG = getenv("SFR:UCFG") 
.................... #endif 
....................  
.................... unsigned int8 USTATCopy; 
....................  
.................... unsigned int8 g_UEP[USB_NUM_UEP]; 
.................... #if defined(UEP0_LOC) 
.................... #locate g_UEP=UEP0_LOC 
.................... #else 
.................... #locate g_UEP=getenv("SFR:UEP0") 
.................... #endif 
.................... #define UEP(x) g_UEP[x] 
....................  
.................... #define BIT_SOF   6 
.................... #define BIT_STALL 5 
.................... #define BIT_IDLE  4 
.................... #define BIT_TRN   3 
.................... #define BIT_ACTV  2 
.................... #define BIT_UERR  1 
.................... #define BIT_URST  0 
....................  
.................... #BIT UIR_SOF = UIR.BIT_SOF 
.................... #BIT UIR_STALL = UIR.BIT_STALL 
.................... #BIT UIR_IDLE = UIR.BIT_IDLE 
.................... #BIT UIR_TRN = UIR.BIT_TRN 
.................... #BIT UIR_ACTV = UIR.BIT_ACTV 
.................... #BIT UIR_UERR = UIR.BIT_UERR 
.................... #BIT UIR_URST = UIR.BIT_URST 
....................  
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #bit UCON_PBRST=UCON.6 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    g_USBBDT[x].out.stat 
....................  #define EP_BDxCNT_O(x)   g_USBBDT[x].out.cnt 
....................  #define EP_BDxADR_O(x)   g_USBBDT[x].out.addr 
....................  #define EP_BDxST_I(x)    g_USBBDT[x].in.stat 
....................  #define EP_BDxCNT_I(x)   g_USBBDT[x].in.cnt 
....................  #define EP_BDxADR_I(x)   g_USBBDT[x].in.addr 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET 
.................... #else 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #if defined(__USB_4550__) 
....................  #define __USB_UCFG_UOEMON  0x40 
.................... #endif 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #if !defined(__USB_14K50__) 
....................  #define __USB_UCFG_UTRDIS  0x08 
.................... #endif 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if defined(USB_EXTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  0 
.................... #endif 
....................  
.................... #if defined(USB_INTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if !defined(__USB_UCFG_MY_UPUEN) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #if defined(__USB_UCFG_UTRDIS) 
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS 
.................... #else 
....................  #define __UCFG_VAL_DISABLED__   0 
.................... #endif 
....................  
....................  
.................... unsigned int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... #if defined(USB_ISR_POLLING) 
.................... void usb_isr(void); 
.................... #endif 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... // see usb_hw_layer.h for more documentation 
.................... int1 usb_kbhit(unsigned int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7))); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_tbe(unsigned int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7))); 
*
01C70:  CLRF   03
01C72:  MOVLB  6
01C74:  MOVF   x6B,W
01C76:  ADDLW  26
01C78:  MOVWF  FE9
01C7A:  MOVLW  0F
01C7C:  ADDWFC 03,W
01C7E:  MOVWF  FEA
01C80:  MOVF   FEF,F
01C82:  BZ    1CA8
01C84:  MOVF   x6B,W
01C86:  MULLW  08
01C88:  MOVF   FF3,W
01C8A:  CLRF   x6D
01C8C:  MOVWF  x6C
01C8E:  MOVLW  04
01C90:  ADDWF  x6C,F
01C92:  MOVLW  00
01C94:  ADDWFC x6D,F
01C96:  MOVFF  66C,FE9
01C9A:  MOVLW  0D
01C9C:  ADDWF  x6D,W
01C9E:  MOVWF  FEA
01CA0:  MOVFF  FEF,66E
01CA4:  BTFSS  x6E.7
01CA6:  BRA    1CAC
01CA8:  MOVLW  00
01CAA:  BRA    1CAE
01CAC:  MOVLW  01
01CAE:  MOVWF  01
01CB0:  MOVLB  0
01CB2:  RETURN 0
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_detach(void) 
.................... { 
....................    UCON = 0;  //disable USB hardware 
*
02306:  CLRF   F65
....................    UIE = 0;   //disable USB interrupts 
02308:  MOVLB  F
0230A:  CLRF   x36
....................    UCFG = __UCFG_VAL_DISABLED__; 
0230C:  MOVLW  08
0230E:  MOVWF  x39
....................  
....................    // set D+/D- to inputs 
....................   #if defined(__USB_87J50__) 
....................    set_tris_f(get_tris_f() | 0x18); 
....................   #elif defined(__USB_14K50__) 
....................    set_tris_a(get_tris_a() | 0x3); 
....................   #elif !defined(USB_PIC_NO_USB_GPIO) 
....................    set_tris_c(get_tris_c() | 0x30); //pin_c4 and pin_c5 
02310:  MOVF   F94,W
02312:  IORLW  30
02314:  MOVLB  4
02316:  MOVWF  F94
....................   #endif 
....................    
....................    usb_state = USB_STATE_DETACHED; 
02318:  MOVLB  1
0231A:  CLRF   x2E
0231C:  CLRF   17
0231E:  BTFSC  FF2.7
02320:  BSF    17.7
02322:  BCF    FF2.7
....................     
....................    usb_token_reset();              //clear the chapter9 stack 
02324:  MOVLB  0
02326:  CALL   1408
0232A:  BTFSC  17.7
0232C:  BSF    FF2.7
0232E:  GOTO   2334 (RETURN)
....................    //__usb_kbhit_status=0; 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_attach(void)  
*
02338:  CLRF   17
0233A:  BTFSC  FF2.7
0233C:  BSF    17.7
0233E:  BCF    FF2.7
.................... { 
....................    usb_token_reset(); 
02340:  CALL   1408
02344:  BTFSC  17.7
02346:  BSF    FF2.7
....................    UCON = 0; 
02348:  CLRF   F65
....................    UCFG = __UCFG_VAL_ENABLED__; 
0234A:  MOVLW  14
0234C:  MOVLB  F
0234E:  MOVWF  x39
....................    UIE = 0;                                // Mask all USB interrupts 
02350:  CLRF   x36
....................    UCON_USBEN = 1;                     // Enable module & attach to bus 
02352:  BSF    F65.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
02354:  MOVLW  01
02356:  MOVLB  1
02358:  MOVWF  x2E
0235A:  MOVLB  0
0235C:  GOTO   2366 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init_cs(void) 
.................... { 
....................    usb_detach(); 
*
02332:  BRA    2306
02334:  GOTO   238C (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_task(void)  
.................... { 
....................   #if defined(USB_ISR_POLLING) 
....................    if (interrupt_active(INT_USB)) 
....................    { 
....................       usb_isr(); 
....................    } 
....................   #endif 
....................  
....................   #if defined(USB_CDC_DELAYED_FLUSH) 
....................    if (usb_enumerated()) 
....................    { 
....................       usb_cdc_flush_out_buffer(); 
....................    } 
....................   #endif 
....................  
....................    if (usb_attached())  
....................    { 
....................       if (UCON_USBEN==0)  
*
02360:  BTFSC  F65.3
02362:  BRA    2366
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
02364:  BRA    2338
....................       } 
....................    } 
....................    else  
....................    { 
....................       if (UCON_USBEN==1)   
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0))  
02366:  MOVLB  1
02368:  DECFSZ x2E,W
0236A:  BRA    2386
0236C:  BTFSC  F65.5
0236E:  BRA    2386
....................    { 
....................       UIR=0; 
02370:  CLRF   F62
....................       UIE=0; 
02372:  MOVLB  F
02374:  CLRF   x36
....................      #if !defined(USB_ISR_POLLING) 
....................       enable_interrupts(INT_USB); 
02376:  BSF    FA0.4
....................       enable_interrupts(GLOBAL); 
02378:  MOVLW  C0
0237A:  IORWF  FF2,F
....................      #endif 
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR 
0237C:  MOVLW  11
0237E:  MOVWF  x36
....................       usb_state=USB_STATE_POWERED; 
02380:  MOVLW  02
02382:  MOVLB  1
02384:  MOVWF  x2E
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
02386:  MOVLB  0
02388:  RETURN 0
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init(void)  
.................... { 
....................    usb_init_cs(); 
0238A:  BRA    2332
....................  
....................    do  
....................    { 
....................       usb_task(); 
0238C:  RCALL  2360
....................    } while (usb_state != USB_STATE_POWERED); 
0238E:  MOVLB  1
02390:  MOVF   x2E,W
02392:  SUBLW  02
02394:  BTFSC  FD8.2
02396:  BRA    239C
02398:  MOVLB  0
0239A:  BRA    238C
0239C:  MOVLB  0
0239E:  GOTO   609C (RETURN)
.................... } 
....................  
....................  
.................... // see pic18_usb.h for documentation 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    if (usb_tbe(endpoint))  
*
01CB4:  MOVFF  666,66B
01CB8:  RCALL  1C70
01CBA:  MOVF   01,F
01CBC:  BZ    1D88
....................    { 
....................       EP_BDxCNT_I(endpoint)=len; 
01CBE:  MOVLB  6
01CC0:  MOVF   x66,W
01CC2:  MULLW  08
01CC4:  MOVF   FF3,W
01CC6:  CLRF   x6C
01CC8:  MOVWF  x6B
01CCA:  MOVLW  04
01CCC:  ADDWF  x6B,F
01CCE:  MOVLW  00
01CD0:  ADDWFC x6C,F
01CD2:  MOVLW  01
01CD4:  ADDWF  x6B,W
01CD6:  MOVWF  01
01CD8:  MOVLW  00
01CDA:  ADDWFC x6C,W
01CDC:  MOVWF  03
01CDE:  MOVFF  01,FE9
01CE2:  MOVLW  0D
01CE4:  ADDWF  03,W
01CE6:  MOVWF  FEA
01CE8:  MOVFF  667,FEF
....................  
....................       debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE)  
01CEC:  MOVF   x69,W
01CEE:  SUBLW  02
01CF0:  BNZ   1D20
....................       { 
....................          i = EP_BDxST_I(endpoint); 
01CF2:  MOVF   x66,W
01CF4:  MULLW  08
01CF6:  MOVF   FF3,W
01CF8:  CLRF   x6C
01CFA:  MOVWF  x6B
01CFC:  MOVLW  04
01CFE:  ADDWF  x6B,F
01D00:  MOVLW  00
01D02:  ADDWFC x6C,F
01D04:  MOVFF  66B,FE9
01D08:  MOVLW  0D
01D0A:  ADDWF  x6C,W
01D0C:  MOVWF  FEA
01D0E:  MOVFF  FEF,66A
....................          if (bit_test(i,6)) 
01D12:  BTFSS  x6A.6
01D14:  BRA    1D1A
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
01D16:  CLRF   x69
01D18:  BRA    1D1E
....................          else 
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
01D1A:  MOVLW  01
01D1C:  MOVWF  x69
....................       } 
01D1E:  BRA    1D46
....................       else if (tgl == USB_DTS_USERX)  
01D20:  MOVF   x69,W
01D22:  SUBLW  04
01D24:  BNZ   1D46
....................       { 
....................          i = EP_BDxST_O(endpoint); 
01D26:  MOVF   x66,W
01D28:  MULLW  08
01D2A:  MOVF   FF3,W
01D2C:  CLRF   x6C
01D2E:  MOVWF  FE9
01D30:  MOVLW  0D
01D32:  ADDWF  x6C,W
01D34:  MOVWF  FEA
01D36:  MOVFF  FEF,66A
....................          if (bit_test(i,6)) 
01D3A:  BTFSS  x6A.6
01D3C:  BRA    1D44
....................             tgl = USB_DTS_DATA1; 
01D3E:  MOVLW  01
01D40:  MOVWF  x69
01D42:  BRA    1D46
....................          else 
....................             tgl = USB_DTS_DATA0; 
01D44:  CLRF   x69
....................       } 
....................       if (tgl == USB_DTS_DATA1)  
01D46:  DECFSZ x69,W
01D48:  BRA    1D50
....................          i=0xC8;  //DATA1, UOWN 
01D4A:  MOVLW  C8
01D4C:  MOVWF  x6A
01D4E:  BRA    1D54
....................       else //if (tgl == USB_DTS_DATA0)  
....................          i=0x88; //DATA0, UOWN 
01D50:  MOVLW  88
01D52:  MOVWF  x6A
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
01D54:  BTFSS  x68.0
01D56:  BRA    1D5A
01D58:  BSF    x6A.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
01D5A:  BTFSS  x68.1
01D5C:  BRA    1D60
01D5E:  BSF    x6A.1
....................  
....................       debug_usb(debug_putc, " %X", i); 
....................  
....................       EP_BDxST_I(endpoint) = i;//save changes 
01D60:  MOVF   x66,W
01D62:  MULLW  08
01D64:  MOVF   FF3,W
01D66:  CLRF   x6C
01D68:  MOVWF  x6B
01D6A:  MOVLW  04
01D6C:  ADDWF  x6B,F
01D6E:  MOVLW  00
01D70:  ADDWFC x6C,F
01D72:  MOVFF  66B,FE9
01D76:  MOVLW  0D
01D78:  ADDWF  x6C,W
01D7A:  MOVWF  FEA
01D7C:  MOVFF  66A,FEF
....................        
....................       //putc('!'); 
....................        
....................       return(1); 
01D80:  MOVLW  01
01D82:  MOVWF  01
01D84:  BRA    1D8E
....................    } 
01D86:  MOVLB  0
....................    else  
....................    { 
....................       //putc('_'); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................    return(0); 
01D88:  MOVLW  00
01D8A:  MOVWF  01
01D8C:  MOVLB  6
01D8E:  MOVLB  0
01D90:  RETURN 0
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 * buff_add;     
....................  
....................    if (usb_tbe(endpoint))  
*
01EB0:  MOVFF  65E,66B
01EB4:  RCALL  1C70
01EB6:  MOVF   01,F
01EB8:  BZ    1F36
....................    { 
....................       buff_add = EP_BDxADR_I(endpoint); 
01EBA:  MOVLB  6
01EBC:  MOVF   x5E,W
01EBE:  MULLW  08
01EC0:  MOVF   FF3,W
01EC2:  CLRF   x67
01EC4:  MOVWF  x66
01EC6:  MOVLW  04
01EC8:  ADDWF  x66,F
01ECA:  MOVLW  00
01ECC:  ADDWFC x67,F
01ECE:  MOVLW  02
01ED0:  ADDWF  x66,W
01ED2:  MOVWF  01
01ED4:  MOVLW  00
01ED6:  ADDWFC x67,W
01ED8:  MOVWF  03
01EDA:  MOVFF  01,FE9
01EDE:  MOVLW  0D
01EE0:  ADDWF  03,W
01EE2:  MOVWF  FEA
01EE4:  MOVFF  FEC,665
01EE8:  MOVF   FED,F
01EEA:  MOVFF  FEF,664
....................       memcpy(buff_add, ptr, len);      
01EEE:  MOVFF  665,FEA
01EF2:  MOVFF  664,FE9
01EF6:  MOVFF  660,FE2
01EFA:  MOVFF  65F,FE1
01EFE:  MOVFF  662,02
01F02:  MOVFF  661,01
01F06:  MOVF   01,F
01F08:  BZ    1F0E
01F0A:  INCF   02,F
01F0C:  BRA    1F12
01F0E:  MOVF   02,F
01F10:  BZ    1F1E
01F12:  MOVFF  FE6,FEE
01F16:  DECFSZ 01,F
01F18:  BRA    1F12
01F1A:  DECFSZ 02,F
01F1C:  BRA    1F12
....................        
....................       return(usb_flush_in(endpoint, len, tgl)); 
01F1E:  MOVFF  65E,666
01F22:  MOVFF  662,668
01F26:  MOVFF  661,667
01F2A:  MOVFF  663,669
01F2E:  MOVLB  0
01F30:  RCALL  1CB4
01F32:  MOVF   01,W
01F34:  BRA    1F3A
....................    } 
....................    else  
....................    { 
....................       //putc('-'); 
....................       //printf("%X", EP_BDxST_I(endpoint)); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................  
....................    return(0); 
01F36:  MOVLW  00
01F38:  MOVWF  01
01F3A:  RETURN 0
.................... } 
....................  
.................... // see pic18_usb.h for documentation 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int16 len; 
....................  
....................   #if USB_IGNORE_RX_DTS 
....................    if (tgl == USB_DTS_STALL)  
....................    { 
....................       debug_usb(debug_putc, '*'); 
....................       EP_BDxCNT_O(endpoint) = 0x84; 
....................       EP_BDxST_I(endpoint) = 0x84; 
....................       return; 
....................    } 
....................    else 
....................       i=0x80; 
....................   #else 
....................    i = EP_BDxST_O(endpoint); 
*
01BA2:  MOVLB  6
01BA4:  MOVF   x5E,W
01BA6:  MULLW  08
01BA8:  MOVF   FF3,W
01BAA:  CLRF   x64
01BAC:  MOVWF  FE9
01BAE:  MOVLW  0D
01BB0:  ADDWF  x64,W
01BB2:  MOVWF  FEA
01BB4:  MOVFF  FEF,660
....................    if (tgl == USB_DTS_TOGGLE)  
01BB8:  MOVF   x5F,W
01BBA:  SUBLW  02
01BBC:  BNZ   1BCA
....................    { 
....................       if (bit_test(i,6)) 
01BBE:  BTFSS  x60.6
01BC0:  BRA    1BC6
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
01BC2:  CLRF   x5F
01BC4:  BRA    1BCA
....................       else 
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
01BC6:  MOVLW  01
01BC8:  MOVWF  x5F
....................    } 
....................    if (tgl == USB_DTS_STALL)  
01BCA:  MOVF   x5F,W
01BCC:  SUBLW  03
01BCE:  BNZ   1BF6
....................    { 
....................       i = 0x84; 
01BD0:  MOVLW  84
01BD2:  MOVWF  x60
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints 
01BD4:  MOVF   x5E,W
01BD6:  MULLW  08
01BD8:  MOVF   FF3,W
01BDA:  CLRF   x64
01BDC:  MOVWF  x63
01BDE:  MOVLW  04
01BE0:  ADDWF  x63,F
01BE2:  MOVLW  00
01BE4:  ADDWFC x64,F
01BE6:  MOVFF  663,FE9
01BEA:  MOVLW  0D
01BEC:  ADDWF  x64,W
01BEE:  MOVWF  FEA
01BF0:  MOVLW  84
01BF2:  MOVWF  FEF
....................    } 
01BF4:  BRA    1C04
....................    else if (tgl == USB_DTS_DATA1) 
01BF6:  DECFSZ x5F,W
01BF8:  BRA    1C00
....................       i = 0xC8;  //DATA1, UOWN 
01BFA:  MOVLW  C8
01BFC:  MOVWF  x60
01BFE:  BRA    1C04
....................    else //if (tgl == USB_DTS_DATA0)  
....................       i = 0x88; //DATA0, UOWN 
01C00:  MOVLW  88
01C02:  MOVWF  x60
....................   #endif 
....................  
....................    //bit_clear(__usb_kbhit_status,endpoint); 
....................  
....................    len = usb_ep_rx_size[endpoint]; 
01C04:  BCF    FD8.0
01C06:  RLCF   x5E,W
01C08:  CLRF   03
01C0A:  MOVFF  FF2,663
01C0E:  BCF    FF2.7
01C10:  MOVLB  0
01C12:  CALL   111A
01C16:  TBLRD*+
01C18:  MOVFF  FF5,03
01C1C:  MOVLB  6
01C1E:  BTFSC  x63.7
01C20:  BSF    FF2.7
01C22:  MOVWF  x61
01C24:  MOVFF  03,662
....................    EP_BDxCNT_O(endpoint) = len; 
01C28:  MOVF   x5E,W
01C2A:  MULLW  08
01C2C:  MOVF   FF3,W
01C2E:  CLRF   x64
01C30:  MOVWF  x63
01C32:  MOVLW  01
01C34:  ADDWF  x63,W
01C36:  MOVWF  01
01C38:  MOVLW  00
01C3A:  ADDWFC x64,W
01C3C:  MOVWF  03
01C3E:  MOVFF  01,FE9
01C42:  MOVLW  0D
01C44:  ADDWF  03,W
01C46:  MOVWF  FEA
01C48:  MOVFF  661,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
01C4C:  BTFSS  x62.0
01C4E:  BRA    1C52
01C50:  BSF    x60.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
01C52:  BTFSS  x62.1
01C54:  BRA    1C58
01C56:  BSF    x60.1
....................  
....................    EP_BDxST_O(endpoint) = i; 
01C58:  MOVF   x5E,W
01C5A:  MULLW  08
01C5C:  MOVF   FF3,W
01C5E:  CLRF   x64
01C60:  MOVWF  FE9
01C62:  MOVLW  0D
01C64:  ADDWF  x64,W
01C66:  MOVWF  FEA
01C68:  MOVFF  660,FEF
01C6C:  MOVLB  0
01C6E:  RETURN 0
.................... } 
....................  
.................... // see pic18_usb.h for documentation 
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint)  
.................... { 
....................    return(EP_BDxCNT_O(endpoint)); 
*
01E04:  MOVLB  6
01E06:  MOVF   x5E,W
01E08:  MULLW  08
01E0A:  MOVF   FF3,W
01E0C:  CLRF   x60
01E0E:  MOVWF  x5F
01E10:  MOVLW  01
01E12:  ADDWF  x5F,W
01E14:  MOVWF  01
01E16:  MOVLW  00
01E18:  ADDWFC x60,W
01E1A:  MOVWF  03
01E1C:  MOVFF  01,FE9
01E20:  MOVLW  0D
01E22:  ADDWF  03,W
01E24:  MOVWF  FEA
01E26:  CLRF   03
01E28:  MOVFF  FEF,01
01E2C:  MOVFF  03,02
01E30:  MOVLB  0
01E32:  GOTO   1E56 (RETURN)
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB. 
....................  
.................... /***************************************************************************** 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC  
.................... /*          RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /*****************************************************************************/ 
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max)  
.................... { 
....................    unsigned int8 * al; 
....................    unsigned int8 st; 
....................    unsigned int16 i; 
....................  
....................    al = EP_BDxADR_O(endpoint); 
....................    i = EP_BDxCNT_O(endpoint); 
....................    st = EP_BDxST_O(endpoint); 
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
....................    if (bit_test(st,1)) {bit_set(i,9);} 
....................  
....................    if (i < max) {max = i;} 
....................     
....................    memcpy(ptr, al ,max); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max) 
.................... { 
....................    max = usb_get_packet_buffer(endpoint, ptr, max); 
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_stall_ep(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
019BE:  MOVLB  6
019C0:  BCF    x5E.0
019C2:  BTFSC  x5D.7
019C4:  BSF    x5E.0
....................    endpoint &= 0x7F; 
019C6:  BCF    x5D.7
....................     
....................    if (direction)  
019C8:  BTFSS  x5E.0
019CA:  BRA    19EE
....................    { 
....................       EP_BDxST_I(endpoint) = 0x84; 
019CC:  MOVF   x5D,W
019CE:  MULLW  08
019D0:  MOVF   FF3,W
019D2:  CLRF   x60
019D4:  MOVWF  x5F
019D6:  MOVLW  04
019D8:  ADDWF  x5F,F
019DA:  MOVLW  00
019DC:  ADDWFC x60,F
019DE:  MOVFF  65F,FE9
019E2:  MOVLW  0D
019E4:  ADDWF  x60,W
019E6:  MOVWF  FEA
019E8:  MOVLW  84
019EA:  MOVWF  FEF
....................    } 
019EC:  BRA    1A02
....................    else  
....................    { 
....................       EP_BDxST_O(endpoint) = 0x84; 
019EE:  MOVF   x5D,W
019F0:  MULLW  08
019F2:  MOVF   FF3,W
019F4:  CLRF   x60
019F6:  MOVWF  FE9
019F8:  MOVLW  0D
019FA:  ADDWF  x60,W
019FC:  MOVWF  FEA
019FE:  MOVLW  84
01A00:  MOVWF  FEF
....................    } 
01A02:  MOVLB  0
01A04:  GOTO   1A92 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_unstall_ep(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
01976:  MOVLB  6
01978:  BCF    x5E.0
0197A:  BTFSC  x5D.7
0197C:  BSF    x5E.0
....................    endpoint &= 0x7F; 
0197E:  BCF    x5D.7
....................     
....................    if (direction)  
01980:  BTFSS  x5E.0
01982:  BRA    19A6
....................    { 
....................      #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint) = 0x80; 
....................      #else 
....................       EP_BDxST_I(endpoint) = 0x88; 
01984:  MOVF   x5D,W
01986:  MULLW  08
01988:  MOVF   FF3,W
0198A:  CLRF   x60
0198C:  MOVWF  x5F
0198E:  MOVLW  04
01990:  ADDWF  x5F,F
01992:  MOVLW  00
01994:  ADDWFC x60,F
01996:  MOVFF  65F,FE9
0199A:  MOVLW  0D
0199C:  ADDWF  x60,W
0199E:  MOVWF  FEA
019A0:  MOVLW  88
019A2:  MOVWF  FEF
....................      #endif 
....................    } 
019A4:  BRA    19B8
....................    else  
....................    { 
....................       EP_BDxST_O(endpoint) = 0x00; 
019A6:  MOVF   x5D,W
019A8:  MULLW  08
019AA:  MOVF   FF3,W
019AC:  CLRF   x60
019AE:  MOVWF  FE9
019B0:  MOVLW  0D
019B2:  ADDWF  x60,W
019B4:  MOVWF  FEA
019B6:  CLRF   FEF
....................    } 
019B8:  MOVLB  0
019BA:  GOTO   1A82 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................    unsigned int8 st; 
....................     
....................    direction = bit_test(endpoint,7); 
*
01A08:  MOVLB  6
01A0A:  BCF    x5E.0
01A0C:  BTFSC  x5D.7
01A0E:  BSF    x5E.0
....................    endpoint &= 0x7F; 
01A10:  BCF    x5D.7
....................     
....................    if (direction)  
01A12:  BTFSS  x5E.0
01A14:  BRA    1A38
....................    { 
....................       st=EP_BDxST_I(endpoint); 
01A16:  MOVF   x5D,W
01A18:  MULLW  08
01A1A:  MOVF   FF3,W
01A1C:  CLRF   x61
01A1E:  MOVWF  x60
01A20:  MOVLW  04
01A22:  ADDWF  x60,F
01A24:  MOVLW  00
01A26:  ADDWFC x61,F
01A28:  MOVFF  660,FE9
01A2C:  MOVLW  0D
01A2E:  ADDWF  x61,W
01A30:  MOVWF  FEA
01A32:  MOVFF  FEF,65F
....................    } 
01A36:  BRA    1A4C
....................    else  
....................    { 
....................       st=EP_BDxST_O(endpoint); 
01A38:  MOVF   x5D,W
01A3A:  MULLW  08
01A3C:  MOVF   FF3,W
01A3E:  CLRF   x61
01A40:  MOVWF  FE9
01A42:  MOVLW  0D
01A44:  ADDWF  x61,W
01A46:  MOVWF  FEA
01A48:  MOVFF  FEF,65F
....................    } 
....................     
....................    return(bit_test(st,7) && bit_test(st,2)); 
01A4C:  BTFSS  x5F.7
01A4E:  BRA    1A54
01A50:  BTFSC  x5F.2
01A52:  BRA    1A58
01A54:  MOVLW  00
01A56:  BRA    1A5A
01A58:  MOVLW  01
01A5A:  MOVWF  01
01A5C:  MOVLB  0
01A5E:  GOTO   1AA6 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_address(unsigned int8 address)  
.................... { 
....................    UADDR = address; 
*
01E82:  MOVFF  65E,F38
....................     
....................    if (address)  
01E86:  MOVLB  6
01E88:  MOVF   x5E,F
01E8A:  BZ    1E96
....................    { 
....................       usb_state = USB_STATE_ADDRESS; 
01E8C:  MOVLW  04
01E8E:  MOVLB  1
01E90:  MOVWF  x2E
....................    } 
01E92:  BRA    1E9C
01E94:  MOVLB  6
....................    else  
....................    { 
....................       usb_state = USB_STATE_POWERED; 
01E96:  MOVLW  02
01E98:  MOVLB  1
01E9A:  MOVWF  x2E
....................    } 
01E9C:  MOVLB  0
01E9E:  GOTO   1EAC (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_configured(unsigned int8 config)  
.................... { 
....................    unsigned int8 en; 
....................    unsigned int16 addy; 
....................    unsigned int8 new_uep; 
....................    unsigned int16 len; 
....................    unsigned int8 i; 
....................     
....................    if (config == 0) 
*
01658:  MOVLB  6
0165A:  MOVF   x5D,F
0165C:  BNZ   166C
....................    { 
....................       // if config=0 then set addressed state 
....................       usb_state = USB_STATE_ADDRESS; 
0165E:  MOVLW  04
01660:  MOVLB  1
01662:  MOVWF  x2E
....................       usb_disable_endpoints(); 
01664:  MOVLB  0
01666:  RCALL  1360
....................    } 
01668:  BRA    1838
0166A:  MOVLB  6
....................    else  
....................    { 
....................       // else set configed state 
....................       usb_state = USB_STATE_CONFIGURED;  
0166C:  MOVLW  05
0166E:  MOVLB  1
01670:  MOVWF  x2E
....................       addy = (unsigned int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH); 
01672:  MOVLB  6
01674:  CLRF   x66
01676:  MOVLW  22
01678:  MOVWF  x65
0167A:  MOVLW  80
0167C:  ADDWF  x65,W
0167E:  MOVWF  x5F
01680:  MOVLW  00
01682:  ADDWFC x66,W
01684:  MOVWF  x60
....................       for (en=1; en<USB_NUM_UEP; en++)  
01686:  MOVLW  01
01688:  MOVWF  x5E
0168A:  MOVF   x5E,W
0168C:  SUBLW  0F
0168E:  BTFSS  FD8.0
01690:  BRA    1838
....................       { 
....................          // enable and config endpoints based upon user configuration 
....................          usb_disable_endpoint(en); 
01692:  MOVFF  65E,666
01696:  MOVLB  0
01698:  RCALL  130C
....................          new_uep = 0; 
0169A:  MOVLB  6
0169C:  CLRF   x61
....................          if (usb_ep_rx_type[en] != USB_ENABLE_DISABLED)  
0169E:  CLRF   03
016A0:  MOVF   x5E,W
016A2:  MOVFF  FF2,665
016A6:  BCF    FF2.7
016A8:  MOVLB  0
016AA:  RCALL  10C2
016AC:  MOVLB  6
016AE:  BTFSC  x65.7
016B0:  BSF    FF2.7
016B2:  SUBLW  FF
016B4:  BZ    1770
....................          { 
....................             new_uep = 0x04; 
016B6:  MOVLW  04
016B8:  MOVWF  x61
....................             len = usb_ep_rx_size[en]; 
016BA:  BCF    FD8.0
016BC:  RLCF   x5E,W
016BE:  CLRF   03
016C0:  MOVFF  FF2,665
016C4:  BCF    FF2.7
016C6:  MOVLB  0
016C8:  RCALL  111A
016CA:  TBLRD*+
016CC:  MOVFF  FF5,03
016D0:  MOVLB  6
016D2:  BTFSC  x65.7
016D4:  BSF    FF2.7
016D6:  MOVWF  x62
016D8:  MOVFF  03,663
....................             EP_BDxCNT_O(en) = len; 
016DC:  MOVF   x5E,W
016DE:  MULLW  08
016E0:  MOVF   FF3,W
016E2:  CLRF   x66
016E4:  MOVWF  x65
016E6:  MOVLW  01
016E8:  ADDWF  x65,W
016EA:  MOVWF  01
016EC:  MOVLW  00
016EE:  ADDWFC x66,W
016F0:  MOVWF  03
016F2:  MOVFF  01,FE9
016F6:  MOVLW  0D
016F8:  ADDWF  03,W
016FA:  MOVWF  FEA
016FC:  MOVFF  662,FEF
....................             EP_BDxADR_O(en) = addy; 
01700:  MOVF   x5E,W
01702:  MULLW  08
01704:  MOVF   FF3,W
01706:  CLRF   x66
01708:  MOVWF  x65
0170A:  MOVLW  02
0170C:  ADDWF  x65,W
0170E:  MOVWF  01
01710:  MOVLW  00
01712:  ADDWFC x66,W
01714:  MOVWF  03
01716:  MOVFF  01,FE9
0171A:  MOVLW  0D
0171C:  ADDWF  03,W
0171E:  MOVWF  FEA
01720:  MOVFF  660,FEC
01724:  MOVF   FED,F
01726:  MOVFF  65F,FEF
....................             addy += usb_ep_rx_size[en]; 
0172A:  BCF    FD8.0
0172C:  RLCF   x5E,W
0172E:  CLRF   03
01730:  MOVFF  FF2,665
01734:  BCF    FF2.7
01736:  MOVLB  0
01738:  RCALL  111A
0173A:  TBLRD*+
0173C:  MOVFF  FF5,03
01740:  MOVLB  6
01742:  BTFSC  x65.7
01744:  BSF    FF2.7
01746:  ADDWF  x5F,F
01748:  MOVF   03,W
0174A:  ADDWFC x60,F
....................            #if USB_IGNORE_RX_DTS 
....................             i = 0x80; 
....................            #else 
....................             i = 0x88; 
0174C:  MOVLW  88
0174E:  MOVWF  x64
....................            #endif 
....................             if (bit_test(len,8)) {bit_set(i,0);} 
01750:  BTFSS  x63.0
01752:  BRA    1756
01754:  BSF    x64.0
....................             if (bit_test(len,9)) {bit_set(i,1);} 
01756:  BTFSS  x63.1
01758:  BRA    175C
0175A:  BSF    x64.1
....................             EP_BDxST_O(en) = i; 
0175C:  MOVF   x5E,W
0175E:  MULLW  08
01760:  MOVF   FF3,W
01762:  CLRF   x66
01764:  MOVWF  FE9
01766:  MOVLW  0D
01768:  ADDWF  x66,W
0176A:  MOVWF  FEA
0176C:  MOVFF  664,FEF
....................          } 
....................          if (usb_ep_tx_type[en] != USB_ENABLE_DISABLED)  
01770:  CLRF   03
01772:  MOVF   x5E,W
01774:  MOVFF  FF2,665
01778:  BCF    FF2.7
0177A:  MOVLB  0
0177C:  RCALL  109E
0177E:  MOVLB  6
01780:  BTFSC  x65.7
01782:  BSF    FF2.7
01784:  SUBLW  FF
01786:  BZ    17FE
....................          { 
....................             new_uep |= 0x02; 
01788:  BSF    x61.1
....................             EP_BDxADR_I(en) = addy; 
0178A:  MOVF   x5E,W
0178C:  MULLW  08
0178E:  MOVF   FF3,W
01790:  CLRF   x66
01792:  MOVWF  x65
01794:  MOVLW  04
01796:  ADDWF  x65,F
01798:  MOVLW  00
0179A:  ADDWFC x66,F
0179C:  MOVLW  02
0179E:  ADDWF  x65,W
017A0:  MOVWF  01
017A2:  MOVLW  00
017A4:  ADDWFC x66,W
017A6:  MOVWF  03
017A8:  MOVFF  01,FE9
017AC:  MOVLW  0D
017AE:  ADDWF  03,W
017B0:  MOVWF  FEA
017B2:  MOVFF  660,FEC
017B6:  MOVF   FED,F
017B8:  MOVFF  65F,FEF
....................             addy += usb_ep_tx_size[en]; 
017BC:  BCF    FD8.0
017BE:  RLCF   x5E,W
017C0:  CLRF   03
017C2:  MOVFF  FF2,665
017C6:  BCF    FF2.7
017C8:  MOVLB  0
017CA:  RCALL  10E6
017CC:  TBLRD*+
017CE:  MOVFF  FF5,03
017D2:  MOVLB  6
017D4:  BTFSC  x65.7
017D6:  BSF    FF2.7
017D8:  ADDWF  x5F,F
017DA:  MOVF   03,W
017DC:  ADDWFC x60,F
....................             EP_BDxST_I(en) = 0x40; 
017DE:  MOVF   x5E,W
017E0:  MULLW  08
017E2:  MOVF   FF3,W
017E4:  CLRF   x66
017E6:  MOVWF  x65
017E8:  MOVLW  04
017EA:  ADDWF  x65,F
017EC:  MOVLW  00
017EE:  ADDWFC x66,F
017F0:  MOVFF  665,FE9
017F4:  MOVLW  0D
017F6:  ADDWF  x66,W
017F8:  MOVWF  FEA
017FA:  MOVLW  40
017FC:  MOVWF  FEF
....................          } 
....................          if (new_uep == 0x06) {new_uep = 0x0E;} 
017FE:  MOVF   x61,W
01800:  SUBLW  06
01802:  BNZ   1808
01804:  MOVLW  0E
01806:  MOVWF  x61
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;} 
01808:  CLRF   03
0180A:  MOVF   x5E,W
0180C:  MOVFF  FF2,665
01810:  BCF    FF2.7
01812:  MOVLB  0
01814:  RCALL  109E
01816:  MOVLB  6
01818:  BTFSC  x65.7
0181A:  BSF    FF2.7
0181C:  SUBLW  01
0181E:  BZ    1822
01820:  BSF    x61.4
....................           
....................          UEP(en) = new_uep; 
01822:  CLRF   03
01824:  MOVF   x5E,W
01826:  ADDLW  26
01828:  MOVWF  FE9
0182A:  MOVLW  0F
0182C:  ADDWFC 03,W
0182E:  MOVWF  FEA
01830:  MOVFF  661,FEF
01834:  INCF   x5E,F
01836:  BRA    168A
01838:  MOVLB  0
....................       } 
....................    } 
0183A:  GOTO   18D0 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoint(unsigned int8 en)  
.................... { 
....................    UEP(en) = ENDPT_DISABLED; 
*
0130C:  CLRF   03
0130E:  MOVLB  6
01310:  MOVF   x66,W
01312:  ADDLW  26
01314:  MOVWF  FE9
01316:  MOVLW  0F
01318:  ADDWFC 03,W
0131A:  MOVWF  FEA
0131C:  CLRF   FEF
....................     
....................    if (usb_endpoint_is_valid(en)) 
0131E:  MOVFF  666,667
01322:  MOVLB  0
01324:  RCALL  12AA
01326:  MOVF   01,F
01328:  BZ    135E
....................    { 
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary       
0132A:  MOVLB  6
0132C:  MOVF   x66,W
0132E:  MULLW  08
01330:  MOVF   FF3,W
01332:  CLRF   x68
01334:  MOVWF  FE9
01336:  MOVLW  0D
01338:  ADDWF  x68,W
0133A:  MOVWF  FEA
0133C:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary 
0133E:  MOVF   x66,W
01340:  MULLW  08
01342:  MOVF   FF3,W
01344:  CLRF   x68
01346:  MOVWF  x67
01348:  MOVLW  04
0134A:  ADDWF  x67,F
0134C:  MOVLW  00
0134E:  ADDWFC x68,F
01350:  MOVFF  667,FE9
01354:  MOVLW  0D
01356:  ADDWF  x68,W
01358:  MOVWF  FEA
0135A:  CLRF   FEF
0135C:  MOVLB  0
....................    } 
0135E:  RETURN 0
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoints(void)  
.................... { 
....................    unsigned int8 i; 
....................     
....................    for (i=1; i<USB_NUM_UEP; i++) 
01360:  MOVLW  01
01362:  MOVLB  6
01364:  MOVWF  x65
01366:  MOVF   x65,W
01368:  SUBLW  0F
0136A:  BNC   137A
....................       usb_disable_endpoint(i); 
0136C:  MOVFF  665,666
01370:  MOVLB  0
01372:  RCALL  130C
01374:  MOVLB  6
01376:  INCF   x65,F
01378:  BRA    1366
0137A:  MOVLB  0
0137C:  RETURN 0
....................        
....................    //__usb_kbhit_status=0; 
.................... } 
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... static void usb_clear_trn(void) 
.................... { 
....................    //UIR_TRN = 0; 
....................    //delay_cycles(6); 
....................    UIR &= ~(1 << BIT_TRN); 
*
0143A:  BCF    F62.3
0143C:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt  
.................... /*       method), then you must call this function rapidly.  If there is more  
.................... /*       than 10ms latency the PC may think the USB device is stalled and 
.................... /*       disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this  
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the  
.................... /*       USB interrupt. 
.................... /******************************************************************************/ 
.................... #if !defined(USB_ISR_POLLING) && !defined(USB_NO_ISR_PREPROCESSOR) 
.................... #int_usb NOCLEAR 
.................... #endif 
.................... void usb_isr(void) 
.................... { 
....................    unsigned int8 TRNAttempts; 
....................     
....................    clear_interrupt(INT_USB); 
*
020B0:  BCF    FA1.4
....................     
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though 
020B2:  MOVLB  1
020B4:  MOVF   x2E,F
020B6:  BTFSC  FD8.2
020B8:  BRA    217A
....................    if (UIR)  
020BA:  MOVF   F62,F
020BC:  BTFSC  FD8.2
020BE:  BRA    217A
....................    { 
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................  
....................       //activity detected.  (only enable after sleep) 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();} 
020C0:  BTFSS  F62.2
020C2:  BRA    20D6
020C4:  MOVLB  F
020C6:  BTFSC  x36.2
020C8:  BRA    20CE
020CA:  MOVLB  1
020CC:  BRA    20D6
020CE:  MOVLB  0
020D0:  GOTO   123E
020D4:  MOVLB  1
....................  
....................       if (UCON_SUSPND) return; 
020D6:  BTFSC  F65.1
020D8:  BRA    217A
....................  
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
020DA:  BTFSS  F62.5
020DC:  BRA    20F0
020DE:  MOVLB  F
020E0:  BTFSC  x36.5
020E2:  BRA    20E8
020E4:  MOVLB  1
020E6:  BRA    20F0
020E8:  MOVLB  0
020EA:  GOTO   128C
020EE:  MOVLB  1
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
020F0:  BTFSS  F62.1
020F2:  BRA    2106
020F4:  MOVLB  F
020F6:  BTFSC  x36.1
020F8:  BRA    20FE
020FA:  MOVLB  1
020FC:  BRA    2106
020FE:  MOVLB  0
02100:  GOTO   12A2
02104:  MOVLB  1
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
02106:  BTFSS  F62.0
02108:  BRA    211C
0210A:  MOVLB  F
0210C:  BTFSC  x36.0
0210E:  BRA    2114
02110:  MOVLB  1
02112:  BRA    211C
02114:  MOVLB  0
02116:  GOTO   143E
0211A:  MOVLB  1
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
0211C:  BTFSS  F62.4
0211E:  BRA    2132
02120:  MOVLB  F
02122:  BTFSC  x36.4
02124:  BRA    212A
02126:  MOVLB  1
02128:  BRA    2132
0212A:  MOVLB  0
0212C:  GOTO   1478
02130:  MOVLB  1
....................        
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
02132:  BTFSS  F62.6
02134:  BRA    2148
02136:  MOVLB  F
02138:  BTFSC  x36.6
0213A:  BRA    2140
0213C:  MOVLB  1
0213E:  BRA    2148
02140:  MOVLB  0
02142:  GOTO   1486
02146:  MOVLB  1
....................  
....................       TRNAttempts = 0; 
02148:  MOVLB  6
0214A:  CLRF   x5A
....................       do 
....................       { 
....................          if (UIR_TRN && UIE_TRN)  
0214C:  BTFSS  F62.3
0214E:  BRA    216A
02150:  MOVLB  F
02152:  BTFSC  x36.3
02154:  BRA    215A
02156:  MOVLB  6
02158:  BRA    216A
....................          { 
....................             USTATCopy = U1STAT; 
0215A:  MOVFF  F64,12D
....................             usb_clear_trn(); 
0215E:  MOVLB  0
02160:  CALL   143A
....................             usb_isr_tok_dne(); 
02164:  BRA    1FA2
....................          } 
02166:  BRA    216E
02168:  MOVLB  6
....................          else 
....................             break; 
0216A:  BRA    2178
0216C:  MOVLB  0
....................       } while (TRNAttempts++ < 4); 
0216E:  MOVLB  6
02170:  MOVF   x5A,W
02172:  INCF   x5A,F
02174:  SUBLW  03
02176:  BC    214C
02178:  MOVLB  1
....................  
....................      #if defined(USB_CDC_ISR) 
....................       //has to be done here, can't be done until TRN is empty. 
....................       if (usb_cdc_kbhit()) 
....................       { 
....................          USB_CDC_ISR(); 
....................       } 
....................      #endif 
....................    } 
0217A:  MOVLB  0
0217C:  GOTO   1058
.................... } 
....................  
.................... // SOF interrupt not handled.  user must add this depending on application 
.................... void usb_isr_sof(void)  
.................... { 
....................    debug_usb(debug_putc, "\r\nSOF"); 
....................     
....................    //UIR_SOF = 0; 
....................    UIR &= ~(1 << BIT_SOF); 
*
01486:  BCF    F62.6
01488:  GOTO   2146 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /******************************************************************************/ 
.................... void usb_isr_rst(void)  
.................... { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR = 0; 
*
0143E:  CLRF   F63
....................    UIR = 0; 
01440:  CLRF   F62
....................    UEIE = 0x9F; 
01442:  MOVLW  9F
01444:  MOVLB  F
01446:  MOVWF  x37
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE; 
01448:  MOVLW  3D
0144A:  MOVWF  x36
....................  
....................    UADDR = 0; 
0144C:  CLRF   x38
....................  
....................    usb_disable_endpoints(); 
0144E:  MOVLB  0
01450:  RCALL  1360
....................     
....................    usb_token_reset(); 
01452:  RCALL  1408
....................  
....................    UEP(0) = ENDPT_CONTROL | 0x10; 
01454:  MOVLW  16
01456:  MOVLB  F
01458:  MOVWF  x26
....................  
....................    while (UIR_TRN)  
0145A:  BTFSS  F62.3
0145C:  BRA    1466
....................    { 
....................       usb_clear_trn(); 
0145E:  MOVLB  0
01460:  RCALL  143A
01462:  MOVLB  F
01464:  BRA    145A
....................    } 
....................  
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled 
01466:  BCF    F65.4
....................  
....................    usb_init_ep0_setup(); 
01468:  MOVLB  0
0146A:  RCALL  1252
....................  
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state 
0146C:  MOVLW  03
0146E:  MOVLB  1
01470:  MOVWF  x2E
01472:  MOVLB  0
01474:  GOTO   211A (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void)  
.................... { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
01252:  MOVLW  40
01254:  MOVLB  D
01256:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION; 
01258:  MOVLB  6
0125A:  CLRF   x5C
0125C:  MOVLW  22
0125E:  MOVFF  65C,D03
01262:  MOVFF  FE8,D02
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
01266:  MOVLW  88
01268:  MOVLB  D
0126A:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
0126C:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH; 
0126E:  MOVLB  6
01270:  CLRF   x5C
01272:  MOVLW  22
01274:  MOVWF  x5B
01276:  MOVLW  40
01278:  ADDWF  x5B,W
0127A:  MOVLB  D
0127C:  MOVWF  x06
0127E:  MOVLW  00
01280:  MOVLB  6
01282:  ADDWFC x5C,W
01284:  MOVLB  D
01286:  MOVWF  x07
01288:  MOVLB  0
0128A:  RETURN 0
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr(void) 
.................... { 
....................   #if USB_USE_ERROR_COUNTER 
....................    int ints; 
....................   #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
....................   #if USB_USE_ERROR_COUNTER 
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) )  
....................    {  
....................       //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) )  
....................    {   
....................       //increment crc5 error counter 
....................       debug_usb(debug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) )  
....................    { 
....................       //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) )  
....................    {   
....................       //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) )  
....................    {   
....................       //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) )  
....................    {  
....................       //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
....................   #endif 
....................  
....................    UEIR = 0; 
*
012A2:  CLRF   F63
....................     
....................    //UIR_UERR = 0; 
....................    UIR &= ~(1 << BIT_UERR); 
012A4:  BCF    F62.1
012A6:  GOTO   2104 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_uidle(void) 
.................... { 
....................    debug_usb(debug_putc, "I"); 
....................  
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
01478:  MOVLB  F
0147A:  BSF    x36.2
....................     
....................    //UIR_IDLE = 0; //clear idle interrupt flag 
....................    UIR &= ~(1 << BIT_IDLE); 
0147C:  BCF    F62.4
....................     
....................    UCON_SUSPND = 1; //set suspend. we are now suspended 
0147E:  BSF    F65.1
01480:  MOVLB  0
01482:  GOTO   2130 (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_activity(void) 
.................... { 
....................    debug_usb(debug_putc, "A"); 
....................  
....................    UCON_SUSPND = 0; //turn off low power suspending 
*
0123E:  BCF    F65.1
....................    UIE_ACTV = 0; //clear activity interupt enabling 
01240:  MOVLB  F
01242:  BCF    x36.2
....................     
....................    while(UIR_ACTV) 
01244:  BTFSS  F62.2
01246:  BRA    124C
....................    { 
....................       //UIR_ACTV = 0; 
....................       UIR &= ~(1 << BIT_ACTV); 
01248:  BCF    F62.2
0124A:  BRA    1244
....................    } 
0124C:  MOVLB  0
0124E:  GOTO   20D4 (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_stall(void)  
.................... { 
....................    debug_usb(debug_putc, "S"); 
....................     
....................     
....................    if (bit_test(UEP(0),0))  
*
0128C:  MOVLB  F
0128E:  BTFSS  x26.0
01290:  BRA    129A
....................    { 
....................       usb_init_ep0_setup(); 
01292:  MOVLB  0
01294:  RCALL  1252
....................       bit_clear(UEP(0), 0); 
01296:  MOVLB  F
01298:  BCF    x26.0
....................    } 
....................     
....................    //UIR_STALL = 0; 
....................    UIR &= ~(1 << BIT_STALL); 
0129A:  BCF    F62.5
0129C:  MOVLB  0
0129E:  GOTO   20EE (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;} 
*
0148C:  MOVFF  660,12F
01490:  RETURN 0
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;} 
*
01AC0:  MOVLW  FE
01AC2:  MOVLB  1
01AC4:  MOVWF  x2F
01AC6:  MOVLB  0
01AC8:  RETURN 0
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;} 
*
01492:  MOVLB  1
01494:  SETF   x2F
01496:  MOVLB  0
01498:  RETURN 0
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_tok_dne(void)  
.................... { 
....................    unsigned int8 en; 
....................  
....................    en = USTATCopy>>3; 
*
01FA2:  MOVLB  1
01FA4:  RRCF   x2D,W
01FA6:  MOVLB  6
01FA8:  MOVWF  x5B
01FAA:  RRCF   x5B,F
01FAC:  RRCF   x5B,F
01FAE:  MOVLW  1F
01FB0:  ANDWF  x5B,F
....................  
....................    debug_usb(debug_putc, "T "); 
....................    debug_usb(debug_putc, "%X ", USTATCopy); 
....................  
....................    if (USTATCopy == USTAT_OUT_SETUP_E0)  
01FB2:  MOVLB  1
01FB4:  MOVF   x2D,F
01FB6:  BNZ   2062
....................    { 
....................       //new out or setup token in the buffer 
....................       int8 pidKey; 
....................        
....................       debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................        
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID 
01FB8:  MOVLB  D
01FBA:  MOVF   x00,W
01FBC:  ANDLW  3C
01FBE:  MOVLB  6
01FC0:  MOVWF  x5C
....................        
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion 
01FC2:  MOVLW  43
01FC4:  MOVLB  D
01FC6:  ANDWF  x00,F
....................        
....................       if (pidKey == USB_PIC_PID_SETUP)  
01FC8:  MOVLB  6
01FCA:  MOVF   x5C,W
01FCC:  SUBLW  34
01FCE:  BNZ   2022
....................       { 
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00) 
01FD0:  MOVLB  D
01FD2:  MOVF   x04,W
01FD4:  ANDLW  80
01FD6:  BZ    1FDA
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
01FD8:  CLRF   x04
....................  
....................          debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................          debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................          usb_isr_tok_setup_dne(); 
01FDA:  MOVLB  0
01FDC:  BRA    1B76
....................  
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
01FDE:  BCF    F65.4
....................  
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall()) 
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data()) 
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response()) 
....................          if (__setup_0_tx_size == 0xFF) 
01FE0:  MOVLB  1
01FE2:  INCFSZ x2F,W
01FE4:  BRA    1FF6
....................             usb_flush_out(0, USB_DTS_STALL); 
01FE6:  MOVLB  6
01FE8:  CLRF   x5E
01FEA:  MOVLW  03
01FEC:  MOVWF  x5F
01FEE:  MOVLB  0
01FF0:  RCALL  1BA2
01FF2:  BRA    201C
01FF4:  MOVLB  1
....................          else  
....................          { 
....................             usb_flush_out(0, USB_DTS_TOGGLE); 
01FF6:  MOVLB  6
01FF8:  CLRF   x5E
01FFA:  MOVLW  02
01FFC:  MOVWF  x5F
01FFE:  MOVLB  0
02000:  RCALL  1BA2
....................             if (__setup_0_tx_size != 0xFE) 
02002:  MOVLB  1
02004:  MOVF   x2F,W
02006:  SUBLW  FE
02008:  BZ    201E
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX); 
0200A:  MOVLB  6
0200C:  CLRF   x66
0200E:  CLRF   x68
02010:  MOVFF  12F,667
02014:  MOVLW  04
02016:  MOVWF  x69
02018:  MOVLB  0
0201A:  RCALL  1CB4
0201C:  MOVLB  1
....................          } 
....................          //why was this here? 
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
....................       } 
0201E:  BRA    205C
02020:  MOVLB  6
....................       else if (pidKey == USB_PIC_PID_OUT)  
02022:  MOVF   x5C,W
02024:  SUBLW  04
02026:  BNZ   205E
....................       { 
....................          usb_isr_tok_out_dne(0); 
02028:  CLRF   x5D
0202A:  MOVLB  0
0202C:  RCALL  1E64
....................          usb_flush_out(0, USB_DTS_TOGGLE); 
0202E:  MOVLB  6
02030:  CLRF   x5E
02032:  MOVLW  02
02034:  MOVWF  x5F
02036:  MOVLB  0
02038:  RCALL  1BA2
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF)) 
0203A:  MOVLB  1
0203C:  MOVF   x2F,W
0203E:  SUBLW  FE
02040:  BZ    205C
02042:  INCFSZ x2F,W
02044:  BRA    2048
02046:  BRA    205C
....................          { 
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
02048:  MOVLB  6
0204A:  CLRF   x66
0204C:  CLRF   x68
0204E:  MOVFF  12F,667
02052:  MOVLW  01
02054:  MOVWF  x69
02056:  MOVLB  0
02058:  RCALL  1CB4
0205A:  MOVLB  1
....................          } 
....................       } 
0205C:  MOVLB  6
....................       else 
....................       { 
....................          debug_usb(debug_putc, "!!! "); 
....................       } 
....................    } 
0205E:  BRA    20AA
02060:  MOVLB  1
....................    else if (USTATCopy == USTAT_IN_E0)  
02062:  MOVF   x2D,W
02064:  SUBLW  04
02066:  BNZ   2090
....................    {    
....................       //pic -> host transfer completed 
....................       //EP_BDxST_I(0) = EP_BDxST_I(0) & 0xC3;   //clear up any BDSTAL confusion 
....................       __setup_0_tx_size = 0xFF; 
02068:  SETF   x2F
....................       usb_isr_tok_in_dne(0); 
0206A:  MOVLB  6
0206C:  CLRF   x5D
0206E:  MOVLB  0
02070:  RCALL  1F70
....................       if (__setup_0_tx_size!=0xFF) 
02072:  MOVLB  1
02074:  INCFSZ x2F,W
02076:  BRA    207A
02078:  BRA    208E
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE); 
0207A:  MOVLB  6
0207C:  CLRF   x66
0207E:  CLRF   x68
02080:  MOVFF  12F,667
02084:  MOVLW  02
02086:  MOVWF  x69
02088:  MOVLB  0
0208A:  RCALL  1CB4
0208C:  MOVLB  1
....................       else 
....................       { 
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................       }   
....................    } 
0208E:  BRA    20A8
....................    else  
....................    { 
....................       if (!bit_test(USTATCopy, 2))  
02090:  BTFSC  x2D.2
02092:  BRA    20A0
....................       { 
....................          //EP_BDxST_O(en) = EP_BDxST_O(en) & 0xC3;   //clear up any BDSTAL confusion 
....................          usb_isr_tok_out_dne(en); 
02094:  MOVFF  65B,65D
02098:  MOVLB  0
0209A:  RCALL  1E64
....................       } 
0209C:  BRA    20A8
0209E:  MOVLB  1
....................       else  
....................       { 
....................          //EP_BDxST_I(en) = EP_BDxST_I(en) & 0xC3;   //clear up any BDSTAL confusion 
....................          usb_isr_tok_in_dne(en); 
020A0:  MOVFF  65B,65D
020A4:  MOVLB  0
020A6:  RCALL  1F70
020A8:  MOVLB  6
....................       } 
....................    } 
020AA:  MOVLB  0
020AC:  GOTO   2166 (RETURN)
.................... } 
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... #if defined(__PIC24_USB_H__) 
....................  #include <pic24_usb.c> 
.................... #endif 
....................  
.................... #if defined(__USBN960X_H__) 
....................  #include <usbn960x.c> 
.................... #endif 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... #if (defined(USB_USE_FULL_SPEED) && (USB_USE_FULL_SPEED==1)) 
....................    #define USB_ISO_PACKET_MAX_SIZE     1023 
....................    #define USB_NONISO_PACKET_MAX_SIZE  64 
.................... #else 
....................    #define USB_ISO_PACKET_MAX_SIZE     1023 
....................    #define USB_NONISO_PACKET_MAX_SIZE  8 
.................... #endif 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #if USB_EP1_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP1_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP1_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP1_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP1_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #if USB_EP2_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP2_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP2_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP2_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP2_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #if USB_EP3_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP3_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP3_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP3_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP3_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #if USB_EP4_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP4_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP4_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP4_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP4_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #if USB_EP5_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP5_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP5_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP5_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP5_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #if USB_EP6_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP6_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP6_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP6_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP6_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #if USB_EP7_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP7_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP7_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP7_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP7_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #if USB_EP8_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP8_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP8_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP8_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP8_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #if USB_EP9_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP9_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP9_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP9_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP9_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #if USB_EP10_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP10_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP10_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP10_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP10_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #if USB_EP11_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #if USB_EP12_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP12_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP12_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP12_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP12_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #if USB_EP13_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP13_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP13_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP13_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP13_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #if USB_EP14_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP14_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP14_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP14_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP14_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #if USB_EP15_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP15_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP15_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP15_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP15_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... unsigned int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... unsigned int16 usb_getdesc_ptr; unsigned int16 usb_getdesc_len;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... unsigned int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
.................... void usb_finish_set_address(void); 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... // see usb.h for documentation 
.................... int1 usb_enumerated(void) 
.................... { 
....................    return(USB_stack_status.curr_config); 
*
023A2:  MOVF   19,W
023A4:  MOVWF  01
023A6:  GOTO   60A0 (RETURN)
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_wait_for_enumeration(void)  
.................... { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... // see USB.H for documentation 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) { 
....................    unsigned int16 i=0; 
....................    int1 res; 
....................    unsigned int16 this_packet_len; 
....................    unsigned int16 packet_size; 
....................    unsigned int32 timeout_1us; 
....................  
....................    packet_size = usb_ep_tx_size[endpoint]; 
....................     
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size); 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len)  
....................    { 
....................       timeout_1us = (int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;} 
....................       else {this_packet_len = len-i;} 
....................       //putc('*'); 
....................       do  
....................       { 
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets 
....................          //putc('.'); 
....................          if (!res) 
....................          { 
....................             delay_us(1); 
....................             //delay_ms(500); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................       i += packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout) { 
....................    unsigned int16 ret=0; 
....................    unsigned int16 to; 
....................    unsigned int16 len; 
....................    unsigned int16 packet_size; 
....................    unsigned int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (!timeout || (to!=timeout)) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... // see usb.h for documentation 
.................... void usb_token_reset(void)  
.................... { 
....................    unsigned int i; 
....................  
....................    usb_getdesc_len = 0; 
*
01408:  MOVLB  1
0140A:  CLRF   x34
0140C:  CLRF   x33
....................     
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++)  
0140E:  MOVLB  6
01410:  CLRF   x5B
01412:  MOVF   x5B,W
01414:  SUBLW  01
01416:  BNC   142C
....................       USB_Interface[i] = 0;   //reset each interface to default 
01418:  CLRF   03
0141A:  MOVF   x5B,W
0141C:  ADDLW  35
0141E:  MOVWF  FE9
01420:  MOVLW  01
01422:  ADDWFC 03,W
01424:  MOVWF  FEA
01426:  CLRF   FEF
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) 
....................       hid_protocol[i] = 1; 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
01428:  INCF   x5B,F
0142A:  BRA    1412
....................    usb_cdc_init(); 
0142C:  MOVLB  0
0142E:  RCALL  137E
....................   #endif 
....................  
....................    USB_stack_status.curr_config = 0;      //unconfigured device 
01430:  CLRF   19
....................  
....................    USB_stack_status.status_device = 1;    //previous state.  init at none 
01432:  MOVLW  01
01434:  MOVWF  1A
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none 
01436:  CLRF   18
01438:  RETURN 0
.................... } 
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
012AA:  MOVLB  6
012AC:  BCF    x68.0
012AE:  BTFSC  x67.7
012B0:  BSF    x68.0
....................     
....................    endpoint &= 0x7F; 
012B2:  BCF    x67.7
....................     
....................    if (endpoint > 16) 
012B4:  MOVF   x67,W
012B6:  SUBLW  10
012B8:  BC    12C0
....................       return(FALSE); 
012BA:  MOVLW  00
012BC:  MOVWF  01
012BE:  BRA    1308
....................     
....................    if (direction) { //IN 
012C0:  BTFSS  x68.0
012C2:  BRA    12E8
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
012C4:  CLRF   03
012C6:  MOVF   x67,W
012C8:  MOVFF  FF2,669
012CC:  BCF    FF2.7
012CE:  MOVLB  0
012D0:  RCALL  109E
012D2:  MOVLB  6
012D4:  BTFSC  x69.7
012D6:  BSF    FF2.7
012D8:  SUBLW  FF
012DA:  BNZ   12E0
012DC:  MOVLW  00
012DE:  BRA    12E2
012E0:  MOVLW  01
012E2:  MOVWF  01
012E4:  BRA    1308
....................    } 
012E6:  BRA    1308
....................    else {   //OUT 
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
012E8:  CLRF   03
012EA:  MOVF   x67,W
012EC:  MOVFF  FF2,669
012F0:  BCF    FF2.7
012F2:  MOVLB  0
012F4:  RCALL  10C2
012F6:  MOVLB  6
012F8:  BTFSC  x69.7
012FA:  BSF    FF2.7
012FC:  SUBLW  FF
012FE:  BNZ   1304
01300:  MOVLW  00
01302:  BRA    1306
01304:  MOVLW  01
01306:  MOVWF  01
....................    } 
01308:  MOVLB  0
0130A:  RETURN 0
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint) { 
....................    if (endpoint==0) { 
*
01F70:  MOVLB  6
01F72:  MOVF   x5D,F
01F74:  BNZ   1F92
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
01F76:  DECFSZ 18,W
01F78:  BRA    1F84
01F7A:  MOVLB  0
01F7C:  CALL   149A
01F80:  BRA    1F8E
01F82:  MOVLB  6
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
01F84:  MOVF   18,W
01F86:  SUBLW  02
01F88:  BNZ   1F90
01F8A:  MOVLB  0
01F8C:  BRA    1EA2
01F8E:  MOVLB  6
....................    } 
....................   #if USB_CDC_DEVICE 
01F90:  BRA    1F9E
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
01F92:  MOVF   x5D,W
01F94:  SUBLW  02
01F96:  BNZ   1F9E
....................       usb_isr_tok_in_cdc_data_dne(); 
01F98:  MOVLB  0
01F9A:  BRA    1F6A
01F9C:  MOVLB  6
....................   } 
....................   #endif 
01F9E:  MOVLB  0
01FA0:  RETURN 0
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint) 
.................... { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
01E64:  MOVLB  6
01E66:  MOVF   x5D,F
01E68:  BNZ   1E72
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
01E6A:  MOVLB  0
01E6C:  BRA    1D92
....................      //#else   //REMOVED JUN/9/2009 
....................      //usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
01E6E:  BRA    1E7C
01E70:  MOVLB  6
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
01E72:  MOVF   x5D,W
01E74:  SUBLW  02
01E76:  BNZ   1E7E
....................       usb_isr_tok_out_cdc_data_dne(); 
01E78:  MOVLB  0
01E7A:  BRA    1E48
01E7C:  MOVLB  6
....................    } 
....................   #endif 
01E7E:  MOVLB  0
01E80:  RETURN 0
....................    //else { 
....................    //   bit_set(__usb_kbhit_status,endpoint); 
....................    //} 
.................... } 
....................  
....................  
.................... //---- process setup message stage -----------// 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_setup_dne(void)  
.................... { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
01B76:  CLRF   18
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
01B78:  MOVF   22,W
01B7A:  ANDLW  7F
01B7C:  BZ    1B8C
01B7E:  XORLW  01
01B80:  BZ    1B90
01B82:  XORLW  03
01B84:  BZ    1B94
01B86:  XORLW  23
01B88:  BZ    1B98
01B8A:  BRA    1B9C
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
01B8C:  BRA    183E
....................          break; 
01B8E:  BRA    1B9E
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
01B90:  BRA    18E0
....................          break; 
01B92:  BRA    1B9E
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
01B94:  BRA    1A62
....................          break; 
01B96:  BRA    1B9E
....................           
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc, " class"); 
....................         #if USB_HID_DEVICE && USB_CDC_DEVICE 
....................          if (usb_ep0_rx_buffer[4] == USB_HID_INTERFACE) 
....................          { 
....................             usb_isr_tkn_setup_ClassInterface(); 
....................          } 
....................          else 
....................          { 
....................             usb_isr_tkn_cdc(); 
....................          } 
....................         #elif USB_HID_DEVICE 
....................          usb_isr_tkn_setup_ClassInterface(); 
....................         #else 
....................          usb_isr_tkn_cdc(); 
01B98:  BRA    1ACA
....................         #endif 
....................          break; 
01B9A:  BRA    1B9E
.................... #endif 
....................  
....................  
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
01B9C:  RCALL  1492
....................          break; 
....................    } 
01B9E:  GOTO   1FDE (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
0183E:  MOVF   23,W
01840:  XORLW  00
01842:  BZ    185E
01844:  XORLW  01
01846:  BZ    1870
01848:  XORLW  02
0184A:  BZ    1886
0184C:  XORLW  06
0184E:  BZ    189A
01850:  XORLW  03
01852:  BZ    18AC
01854:  XORLW  0E
01856:  BZ    18B0
01858:  XORLW  01
0185A:  BZ    18C0
0185C:  BRA    18DA
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
0185E:  MOVFF  1A,62
....................             usb_ep0_tx_buffer[1]=0; 
01862:  CLRF   x63
....................             usb_request_send_response(2); 
01864:  MOVLW  02
01866:  MOVLB  6
01868:  MOVWF  x60
0186A:  MOVLB  0
0186C:  RCALL  148C
....................             break; 
0186E:  BRA    18DC
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
01870:  DECFSZ 24,W
01872:  BRA    1882
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
01874:  MOVLW  01
01876:  ANDWF  1A,F
....................                usb_put_0len_0(); 
01878:  MOVLB  6
0187A:  CLRF   x60
0187C:  MOVLB  0
0187E:  RCALL  148C
....................             } 
01880:  BRA    1884
....................             else 
....................                usb_request_stall(); 
01882:  RCALL  1492
....................             break; 
01884:  BRA    18DC
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
01886:  DECFSZ 24,W
01888:  BRA    1896
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
0188A:  BSF    1A.1
....................                usb_put_0len_0(); 
0188C:  MOVLB  6
0188E:  CLRF   x60
01890:  MOVLB  0
01892:  RCALL  148C
....................             } 
01894:  BRA    1898
....................             else 
....................                usb_request_stall(); 
01896:  RCALL  1492
....................             break; 
01898:  BRA    18DC
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
0189A:  MOVLW  02
0189C:  MOVWF  18
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
0189E:  MOVFF  24,130
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
018A2:  MOVLB  6
018A4:  CLRF   x60
018A6:  MOVLB  0
018A8:  RCALL  148C
....................             break; 
018AA:  BRA    18DC
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
018AC:  BRA    1568
....................             break; 
018AE:  BRA    18DC
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
018B0:  MOVFF  19,62
....................             usb_request_send_response(1); 
018B4:  MOVLW  01
018B6:  MOVLB  6
018B8:  MOVWF  x60
018BA:  MOVLB  0
018BC:  RCALL  148C
....................             break; 
018BE:  BRA    18DC
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
018C0:  MOVF   24,W
018C2:  SUBLW  01
018C4:  BNC   18D8
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
018C6:  MOVFF  24,19
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
018CA:  MOVFF  24,65D
018CE:  BRA    1658
....................                debug_usb(debug_putc,"SC%U", USB_stack_status.curr_config);                
....................                usb_put_0len_0(); 
018D0:  MOVLB  6
018D2:  CLRF   x60
018D4:  MOVLB  0
018D6:  RCALL  148C
....................             } 
....................             break; 
018D8:  BRA    18DC
....................  
....................       default: 
....................             usb_request_stall(); 
018DA:  RCALL  1492
....................             break; 
....................    } 
018DC:  GOTO   1B9E (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    unsigned int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
018E0:  MOVFF  19,65D
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
018E4:  MOVF   23,W
018E6:  BZ    18F2
018E8:  XORLW  0A
018EA:  BZ    1902
018EC:  XORLW  01
018EE:  BZ    1948
018F0:  BRA    1970
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
018F2:  CLRF   x62
....................             usb_ep0_tx_buffer[1]=0; 
018F4:  CLRF   x63
....................             usb_request_send_response(2); 
018F6:  MOVLW  02
018F8:  MOVLB  6
018FA:  MOVWF  x60
018FC:  MOVLB  0
018FE:  RCALL  148C
....................             break; 
01900:  BRA    1972
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
01902:  MOVLB  6
01904:  MOVF   x5D,F
01906:  BZ    1942
01908:  MOVLW  01
0190A:  SUBWF  x5D,W
0190C:  CLRF   03
0190E:  MOVFF  FF2,65E
01912:  BCF    FF2.7
01914:  MOVLB  0
01916:  RCALL  11A6
01918:  MOVLB  6
0191A:  BTFSC  x5E.7
0191C:  BSF    FF2.7
0191E:  MOVWF  01
01920:  SUBWF  26,W
01922:  BC    1942
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
01924:  CLRF   03
01926:  MOVF   26,W
01928:  ADDLW  35
0192A:  MOVWF  FE9
0192C:  MOVLW  01
0192E:  ADDWFC 03,W
01930:  MOVWF  FEA
01932:  MOVFF  FEF,62
....................                usb_request_send_response(1); //send byte back 
01936:  MOVLW  01
01938:  MOVWF  x60
0193A:  MOVLB  0
0193C:  RCALL  148C
....................             } 
0193E:  BRA    1946
01940:  MOVLB  6
....................             else 
....................                usb_request_stall(); 
01942:  MOVLB  0
01944:  RCALL  1492
....................             break; 
01946:  BRA    1972
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
01948:  MOVLB  6
0194A:  MOVF   x5D,F
0194C:  BZ    196A
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
0194E:  CLRF   03
01950:  MOVF   26,W
01952:  ADDLW  35
01954:  MOVWF  FE9
01956:  MOVLW  01
01958:  ADDWFC 03,W
0195A:  MOVWF  FEA
0195C:  MOVFF  24,FEF
....................                usb_put_0len_0(); 
01960:  CLRF   x60
01962:  MOVLB  0
01964:  RCALL  148C
....................             } 
01966:  BRA    196E
01968:  MOVLB  6
....................             else 
....................                usb_request_stall(); 
0196A:  MOVLB  0
0196C:  RCALL  1492
....................             break; 
0196E:  BRA    1972
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GDh"); 
....................             usb_Get_Descriptor(); 
....................             break; 
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
01970:  RCALL  1492
....................             break; 
....................    } 
01972:  GOTO   1B9E (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
01A62:  MOVFF  26,667
01A66:  RCALL  12AA
01A68:  MOVF   01,F
01A6A:  BZ    1ABC
....................       switch(usb_ep0_rx_buffer[1]) { 
01A6C:  MOVF   23,W
01A6E:  XORLW  01
01A70:  BZ    1A7C
01A72:  XORLW  02
01A74:  BZ    1A8C
01A76:  XORLW  03
01A78:  BZ    1A9C
01A7A:  BRA    1ABA
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
01A7C:  MOVFF  26,65D
01A80:  BRA    1976
....................                usb_put_0len_0(); 
01A82:  MOVLB  6
01A84:  CLRF   x60
01A86:  MOVLB  0
01A88:  RCALL  148C
....................                break; 
01A8A:  BRA    1ABC
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
01A8C:  MOVFF  26,65D
01A90:  BRA    19BE
....................                      usb_put_0len_0(); 
01A92:  MOVLB  6
01A94:  CLRF   x60
01A96:  MOVLB  0
01A98:  RCALL  148C
....................                      break; 
01A9A:  BRA    1ABC
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
01A9C:  CLRF   x62
....................                usb_ep0_tx_buffer[1]=0; 
01A9E:  CLRF   x63
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
01AA0:  MOVFF  26,65D
01AA4:  BRA    1A08
01AA6:  MOVF   01,F
01AA8:  BZ    1AAE
....................                   usb_ep0_tx_buffer[0]=1; 
01AAA:  MOVLW  01
01AAC:  MOVWF  x62
....................                } 
....................                usb_request_send_response(2); 
01AAE:  MOVLW  02
01AB0:  MOVLB  6
01AB2:  MOVWF  x60
01AB4:  MOVLB  0
01AB6:  RCALL  148C
....................                break; 
01AB8:  BRA    1ABC
....................  
....................          default: 
....................             usb_request_stall(); 
01ABA:  RCALL  1492
....................             break; 
....................       } 
....................    } 
01ABC:  GOTO   1B9E (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
....................             break; 
....................    } 
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
01568:  MOVLB  1
0156A:  CLRF   x32
0156C:  CLRF   x31
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
0156E:  CLRF   1B
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
01570:  MOVF   25,W
01572:  XORLW  01
01574:  MOVLB  0
01576:  BZ    1586
01578:  XORLW  03
0157A:  BZ    1594
0157C:  XORLW  01
0157E:  BZ    159E
01580:  XORLW  22
01582:  BZ    15DC
01584:  BRA    162E
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
01586:  MOVLB  1
01588:  CLRF   x34
0158A:  MOVLW  12
0158C:  MOVWF  x33
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
0158E:  MOVLW  03
01590:  MOVWF  1B
....................             break; 
01592:  BRA    1638
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
01594:  MOVLB  1
01596:  CLRF   x34
01598:  MOVLW  43
0159A:  MOVWF  x33
....................             break; 
0159C:  BRA    1638
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
0159E:  MOVLW  02
015A0:  MOVWF  1B
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
015A2:  CLRF   03
015A4:  MOVF   24,W
015A6:  ADDLW  1C
015A8:  MOVWF  FE9
015AA:  MOVLW  00
015AC:  ADDWFC 03,W
015AE:  MOVWF  FEA
015B0:  MOVLB  1
015B2:  CLRF   x32
015B4:  MOVFF  FEF,131
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
015B8:  MOVFF  132,03
015BC:  MOVF   x31,W
015BE:  MOVFF  FF2,65D
015C2:  BCF    FF2.7
015C4:  MOVLB  0
015C6:  RCALL  11FE
015C8:  MOVLB  6
015CA:  BTFSC  x5D.7
015CC:  BSF    FF2.7
015CE:  CLRF   03
015D0:  MOVFF  FE8,133
015D4:  MOVLB  1
015D6:  MOVFF  03,134
....................             break; 
015DA:  BRA    1638
....................  
....................       //case USB_DESC_DEVICE_QUALIFIER_TYPE:   //0x06 
....................       // this is needed so host can find out about differences about this 
....................       // devices ability to handle full speed verses fast speed. 
....................       // since we don't support fast speed then we ignore this. 
....................       //      break; 
....................  
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             //TODO does this work for multiple interfaces or multiple languages? 
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]]; 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]]; 
015DC:  CLRF   03
015DE:  MOVF   24,W
015E0:  MOVFF  FF2,65D
015E4:  BCF    FF2.7
015E6:  RCALL  11BC
015E8:  MOVLB  6
015EA:  BTFSC  x5D.7
015EC:  BSF    FF2.7
015EE:  CLRF   03
015F0:  MOVFF  FE8,131
015F4:  MOVLB  1
015F6:  MOVFF  03,132
....................             if (usb_getdesc_ptr!=0xFF) { 
015FA:  INCFSZ x31,W
015FC:  BRA    1602
015FE:  MOVF   x32,F
01600:  BZ    1628
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
01602:  MOVFF  132,03
01606:  MOVF   x31,W
01608:  MOVFF  FF2,65D
0160C:  BCF    FF2.7
0160E:  MOVLB  0
01610:  RCALL  114E
01612:  MOVLB  6
01614:  BTFSC  x5D.7
01616:  BSF    FF2.7
01618:  CLRF   03
0161A:  MOVFF  FE8,133
0161E:  MOVLB  1
01620:  MOVFF  03,134
....................                break; 
01624:  BRA    1638
....................             } 
01626:  BRA    1630
....................             else { 
....................                usb_request_stall(); 
01628:  MOVLB  0
0162A:  RCALL  1492
....................                return; 
0162C:  BRA    1654
0162E:  MOVLB  1
....................             } 
.................... #endif 
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
....................             if (usb_getdesc_ptr !=0xFF) { 
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
01630:  MOVLB  0
01632:  RCALL  1492
....................             return; 
01634:  BRA    1654
01636:  MOVLB  1
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
01638:  MOVF   29,F
0163A:  BNZ   164C
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
0163C:  MOVF   x34,F
0163E:  BNZ   1646
01640:  MOVF   x33,W
01642:  SUBWF  28,W
01644:  BC    164C
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
01646:  CLRF   x34
01648:  MOVFF  28,133
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
0164C:  MOVLW  01
0164E:  MOVWF  18
....................    usb_copy_desc_seg_to_ep(); 
01650:  MOVLB  0
01652:  RCALL  149A
01654:  GOTO   18DC (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0 
*
01EA2:  CLRF   19
....................  
....................    #ifdef __PIC__ 
....................    USB_stack_status.dev_req=NONE;  // no request pending 
01EA4:  CLRF   18
....................    usb_set_address(USB_address_pending); 
01EA6:  MOVFF  130,65E
01EAA:  BRA    1E82
....................    #endif 
01EAC:  GOTO   1F8E (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
*
0149A:  MOVLB  6
0149C:  CLRF   x5E
....................    unsigned int i=0; 
....................    char c; 
....................     
....................    //debug_usb(debug_putc, "!%LX! ", &usb_ep0_tx_buffer[0]); 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
0149E:  MOVLB  1
014A0:  MOVF   x33,W
014A2:  IORWF  x34,W
014A4:  BZ    1546
014A6:  MOVLB  6
014A8:  MOVF   x5E,W
014AA:  SUBLW  3F
014AC:  BTFSC  FD8.0
014AE:  BRA    14B4
014B0:  MOVLB  1
014B2:  BRA    1546
....................    { 
....................       switch(USB_stack_status.getdesc_type) { 
014B4:  MOVF   1B,W
014B6:  XORLW  00
014B8:  MOVLB  0
014BA:  BZ    14C6
014BC:  XORLW  02
014BE:  BZ    14E4
014C0:  XORLW  01
014C2:  BZ    1502
014C4:  BRA    151E
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
014C6:  MOVFF  132,03
014CA:  MOVLB  1
014CC:  MOVF   x31,W
014CE:  MOVFF  FF2,660
014D2:  BCF    FF2.7
014D4:  MOVLB  0
014D6:  RCALL  114E
014D8:  MOVLB  6
014DA:  BTFSC  x60.7
014DC:  BSF    FF2.7
014DE:  MOVWF  x5F
....................             break; 
014E0:  MOVLB  0
014E2:  BRA    151E
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
....................             break; 
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
014E4:  MOVFF  132,03
014E8:  MOVLB  1
014EA:  MOVF   x31,W
014EC:  MOVFF  FF2,660
014F0:  BCF    FF2.7
014F2:  MOVLB  0
014F4:  RCALL  11FE
014F6:  MOVLB  6
014F8:  BTFSC  x60.7
014FA:  BSF    FF2.7
014FC:  MOVWF  x5F
....................             break; 
014FE:  MOVLB  0
01500:  BRA    151E
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
01502:  MOVFF  132,03
01506:  MOVLB  1
01508:  MOVF   x31,W
0150A:  MOVFF  FF2,660
0150E:  BCF    FF2.7
01510:  MOVLB  0
01512:  RCALL  11D8
01514:  MOVLB  6
01516:  BTFSC  x60.7
01518:  BSF    FF2.7
0151A:  MOVWF  x5F
....................             //debug_usb(debug_putc, "-%X- ", c); 
....................             break; 
0151C:  MOVLB  0
....................       } 
....................       usb_getdesc_ptr++; 
0151E:  MOVLB  1
01520:  INCF   x31,F
01522:  BTFSC  FD8.2
01524:  INCF   x32,F
....................       usb_getdesc_len--; 
01526:  MOVF   x33,W
01528:  BTFSC  FD8.2
0152A:  DECF   x34,F
0152C:  DECF   x33,F
....................       usb_ep0_tx_buffer[i++]=c; 
0152E:  MOVLB  6
01530:  MOVF   x5E,W
01532:  INCF   x5E,F
01534:  ADDLW  62
01536:  MOVWF  FE9
01538:  CLRF   FEA
0153A:  BTFSC  FD8.0
0153C:  INCF   FEA,F
0153E:  MOVFF  65F,FEF
01542:  BRA    149E
01544:  MOVLB  1
....................    } 
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
01546:  MOVF   x33,W
01548:  IORWF  x34,W
0154A:  BNZ   155E
0154C:  MOVLB  6
0154E:  MOVF   x5E,W
01550:  SUBLW  40
01552:  BTFSS  FD8.2
01554:  BRA    155A
01556:  MOVLB  1
01558:  BRA    155E
....................          USB_stack_status.dev_req = NONE; 
0155A:  CLRF   18
0155C:  MOVLB  1
....................    } 
....................  
....................    usb_request_send_response(i); 
0155E:  MOVFF  65E,660
01562:  MOVLB  0
01564:  RCALL  148C
01566:  RETURN 0
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /* 
....................    Generally, you cannot use CDC on a slow speed USB device.  The primary 
....................    reason for this is that CDC uses bulk transfer endpoints, and bulk 
....................    transfer endpoints is not supported on slow speed devices per the USB 
....................    specification.  You may be able to find unofficial drivers for your 
....................    operating system that allows CDC to operate on a slow speed device, 
....................    but CCS doesn't have any that they can recommend to you. 
.................... */ 
.................... #if (USB_USE_FULL_SPEED==0) 
....................    #error CDC and slow speed is not supported.  See comments above. 
.................... #endif 
....................  
.................... struct { 
....................         unsigned int32   dwDTERrate;   //data terminal rate, in bits per second 
....................         unsigned int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2) 
....................         unsigned int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space) 
....................         unsigned int8    bDataBits;    //data bits (5,6,7,8 or 16) 
.................... } __attribute__((__packed__)) usb_cdc_line_coding; 
....................  
.................... //length of time, in ms, of break signal as we received in a SendBreak message. 
.................... //if ==0xFFFF, send break signal until we receive a 0x0000. 
.................... unsigned int16 usb_cdc_break; 
....................  
.................... unsigned int8 usb_cdc_encapsulated_cmd[8]; 
....................  
.................... #ifndef USB_CDC_DATA_LOCAL_SIZE 
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE-1]; 
.................... #else 
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_LOCAL_SIZE]; 
.................... #endif 
....................  
.................... #define usb_cdc_put_buffer_free()  usb_tbe(USB_CDC_DATA_IN_ENDPOINT) 
.................... #if sizeof(usb_cdc_put_buffer)>=0x100 
....................  #error This is not supported.  That is because ISR may change this 16bit value while your non-ISR code is reading this. 
....................  typedef unsigned int16 usb_cdc_tx_t; 
.................... #else 
....................  typedef unsigned int8 usb_cdc_tx_t; 
.................... #endif 
....................  
.................... usb_cdc_tx_t usb_cdc_put_buffer_nextin; 
....................  
....................  
.................... #if defined(__PIC__) 
....................  #define usb_cdc_get_buffer_status_buffer usb_ep2_rx_buffer 
.................... #else 
....................  unsigned int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE]; 
.................... #endif 
....................  
.................... int1 usb_cdc_got_set_line_coding; 
....................  
.................... struct  { 
....................    int1 dte_present; //1=DTE present, 0=DTE not present 
....................    int1 active;      //1=activate carrier, 0=deactivate carrier 
....................    unsigned int reserved:6; 
.................... } usb_cdc_carrier; 
....................  
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state; 
....................  
.................... /* 
.................... #if defined(__PCH__) 
....................  #byte INTCON=0xFF2 
....................  #bit INT_GIE=INTCON.7 
.................... #else 
....................  #word SR=0x42 
.................... #endif 
.................... */ 
....................  
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data] 
.................... void usb_isr_tok_out_cdc_control_dne(void) { 
....................    debug_usb(debug_putc,"CDC %X ",__usb_cdc_state); 
....................  
....................    switch (__usb_cdc_state) { 
*
01D92:  MOVLB  1
01D94:  MOVF   x8A,W
01D96:  XORLW  01
01D98:  MOVLB  0
01D9A:  BZ    1DA2
01D9C:  XORLW  03
01D9E:  BZ    1DCC
01DA0:  BRA    1DFA
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state); 
....................       case USB_CDC_OUT_COMMAND: 
....................          //usb_get_packet(0, usb_cdc_encapsulated_cmd, 8); 
....................          memcpy(usb_cdc_encapsulated_cmd, usb_ep0_rx_buffer,8); 
01DA2:  MOVLW  01
01DA4:  MOVWF  FEA
01DA6:  MOVLW  40
01DA8:  MOVWF  FE9
01DAA:  CLRF   FE2
01DAC:  MOVLW  22
01DAE:  MOVWF  FE1
01DB0:  MOVLW  08
01DB2:  MOVWF  01
01DB4:  MOVFF  FE6,FEE
01DB8:  DECFSZ 01,F
01DBA:  BRA    1DB4
....................         #if USB_MAX_EP0_PACKET_LENGTH==8 
....................          __usb_cdc_state=USB_CDC_WAIT_0LEN; 
....................          usb_request_get_data(); 
....................         #else 
....................          usb_put_0len_0(); 
01DBC:  MOVLB  6
01DBE:  CLRF   x60
01DC0:  MOVLB  0
01DC2:  CALL   148C
....................          __usb_cdc_state=0; 
01DC6:  MOVLB  1
01DC8:  CLRF   x8A
....................         #endif 
....................          break; 
01DCA:  BRA    1DFE
....................  
....................     #if USB_MAX_EP0_PACKET_LENGTH==8 
....................       case USB_CDC_WAIT_0LEN: 
....................          usb_put_0len_0(); 
....................          __usb_cdc_state=0; 
....................          break; 
....................     #endif 
....................  
....................       case USB_CDC_OUT_LINECODING: 
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7); 
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n"); 
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7); 
01DCC:  MOVLW  01
01DCE:  MOVWF  FEA
01DD0:  MOVLW  37
01DD2:  MOVWF  FE9
01DD4:  CLRF   FE2
01DD6:  MOVLW  22
01DD8:  MOVWF  FE1
01DDA:  MOVLW  07
01DDC:  MOVWF  01
01DDE:  MOVFF  FE6,FEE
01DE2:  DECFSZ 01,F
01DE4:  BRA    1DDE
....................          __usb_cdc_state=0; 
01DE6:  MOVLB  1
01DE8:  CLRF   x8A
....................          usb_put_0len_0(); 
01DEA:  MOVLB  6
01DEC:  CLRF   x60
01DEE:  MOVLB  0
01DF0:  CALL   148C
....................          break; 
01DF4:  MOVLB  1
01DF6:  BRA    1DFE
01DF8:  MOVLB  0
....................  
....................       default: 
....................          __usb_cdc_state=0; 
01DFA:  MOVLB  1
01DFC:  CLRF   x8A
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................          break; 
....................    } 
01DFE:  MOVLB  0
01E00:  GOTO   1E6E (RETURN)
.................... } 
....................  
.................... //handle IN token on 0 (setup packet) 
.................... void usb_isr_tkn_cdc(void) { 
....................    //make sure the request goes to a CDC interface 
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) { 
*
01ACA:  DECFSZ 26,W
01ACC:  BRA    1AD0
01ACE:  BRA    1AD4
01AD0:  MOVF   26,F
01AD2:  BNZ   1B72
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]); 
....................       switch(usb_ep0_rx_buffer[1]) { 
01AD4:  MOVF   23,W
01AD6:  BZ    1AEE
01AD8:  XORLW  01
01ADA:  BZ    1AFA
01ADC:  XORLW  21
01ADE:  BZ    1B1C
01AE0:  XORLW  01
01AE2:  BZ    1B2A
01AE4:  XORLW  03
01AE6:  BZ    1B50
01AE8:  XORLW  01
01AEA:  BZ    1B5E
01AEC:  BRA    1B70
....................          case 0x00:  //send_encapsulated_command 
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND; 
01AEE:  MOVLW  01
01AF0:  MOVLB  1
01AF2:  MOVWF  x8A
....................             usb_request_get_data(); 
01AF4:  MOVLB  0
01AF6:  RCALL  1AC0
....................             break; 
01AF8:  BRA    1B72
....................  
....................          case 0x01:  //get_encapsulated_command 
....................             memcpy(usb_ep0_tx_buffer, usb_cdc_encapsulated_cmd, 8); 
01AFA:  CLRF   FEA
01AFC:  MOVLW  62
01AFE:  MOVWF  FE9
01B00:  MOVLW  01
01B02:  MOVWF  FE2
01B04:  MOVLW  40
01B06:  MOVWF  FE1
01B08:  MOVLW  08
01B0A:  MOVWF  01
01B0C:  MOVFF  FE6,FEE
01B10:  DECFSZ 01,F
01B12:  BRA    1B0C
....................             usb_request_send_response(usb_ep0_rx_buffer[6]);  //send wLength bytes 
01B14:  MOVFF  28,660
01B18:  RCALL  148C
....................             break; 
01B1A:  BRA    1B72
....................  
....................          case 0x20:  //set_line_coding 
....................             debug_usb(debug_putc,"!GSLC!"); 
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING; 
01B1C:  MOVLW  02
01B1E:  MOVLB  1
01B20:  MOVWF  x8A
....................             usb_cdc_got_set_line_coding=TRUE; 
01B22:  BSF    x88.0
....................             usb_request_get_data(); 
01B24:  MOVLB  0
01B26:  RCALL  1AC0
....................             break; 
01B28:  BRA    1B72
....................  
....................          case 0x21:  //get_line_coding 
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding)); 
01B2A:  CLRF   FEA
01B2C:  MOVLW  62
01B2E:  MOVWF  FE9
01B30:  MOVLW  01
01B32:  MOVWF  FE2
01B34:  MOVLW  37
01B36:  MOVWF  FE1
01B38:  MOVLW  07
01B3A:  MOVWF  01
01B3C:  MOVFF  FE6,FEE
01B40:  DECFSZ 01,F
01B42:  BRA    1B3C
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes 
01B44:  MOVLW  07
01B46:  MOVLB  6
01B48:  MOVWF  x60
01B4A:  MOVLB  0
01B4C:  RCALL  148C
....................             break; 
01B4E:  BRA    1B72
....................  
....................          case 0x22:  //set_control_line_state 
....................             (unsigned int8)usb_cdc_carrier=usb_ep0_rx_buffer[2]; 
01B50:  MOVFF  24,189
....................             usb_put_0len_0(); 
01B54:  MOVLB  6
01B56:  CLRF   x60
01B58:  MOVLB  0
01B5A:  RCALL  148C
....................             break; 
01B5C:  BRA    1B72
....................  
....................          case 0x23:  //send_break 
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]); 
01B5E:  MOVFF  24,13F
01B62:  MOVFF  25,13E
....................             usb_put_0len_0(); 
01B66:  MOVLB  6
01B68:  CLRF   x60
01B6A:  MOVLB  0
01B6C:  RCALL  148C
....................             break; 
01B6E:  BRA    1B72
....................  
....................          default: 
....................             usb_request_stall(); 
01B70:  RCALL  1492
....................             break; 
....................       } 
....................    } 
01B72:  GOTO   1B9E (RETURN)
.................... } 
....................  
.................... //handle OUT token done interrupt on endpoint 2 [buffer incoming received chars] 
.................... void usb_isr_tok_out_cdc_data_dne(void) { 
....................    usb_cdc_get_buffer_status.got=TRUE; 
*
01E48:  BSF    1F.0
....................    usb_cdc_get_buffer_status.index=0; 
01E4A:  CLRF   21
.................... #if (defined(__PIC__) && __PIC__) 
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT); 
01E4C:  MOVLW  02
01E4E:  MOVLB  6
01E50:  MOVWF  x5E
01E52:  MOVLB  0
01E54:  BRA    1E04
01E56:  MOVFF  01,20
.................... #else 
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer( 
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE); 
.................... #endif 
....................    if (!usb_cdc_get_buffer_status.len) 
01E5A:  MOVF   20,F
01E5C:  BNZ   1E60
....................    { 
....................       usb_cdc_get_discard(); 
01E5E:  BRA    1E36
....................    } 
01E60:  GOTO   1E7C (RETURN)
....................    /* 
....................   #if defined(USB_CDC_ISR) 
....................    else 
....................    { 
....................       USB_CDC_ISR(); 
....................    } 
....................   #endif 
....................   */ 
.................... } 
....................  
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters] 
.................... void usb_isr_tok_in_cdc_data_dne(void)  
.................... { 
....................    usb_cdc_flush_tx_buffer(); 
*
01F6A:  RCALL  1F3C
01F6C:  GOTO   1F9C (RETURN)
.................... } 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0372E:  MOVLB  5
03730:  MOVFF  5C0,FE9
03734:  MOVFF  5C1,FEA
03738:  MOVFF  FEF,5C4
0373C:  MOVFF  5C3,03
03740:  MOVFF  5C2,FE9
03744:  MOVFF  5C3,FEA
03748:  MOVF   FEF,W
0374A:  SUBWF  xC4,W
0374C:  BNZ   3778
....................       if (*s1 == '\0') 
0374E:  MOVFF  5C1,03
03752:  MOVFF  5C0,FE9
03756:  MOVFF  03,FEA
0375A:  MOVF   FEF,F
0375C:  BNZ   3764
....................          return(0); 
0375E:  MOVLW  00
03760:  MOVWF  01
03762:  BRA    37A2
03764:  MOVFF  5C1,03
03768:  MOVF   xC0,W
0376A:  INCF   xC0,F
0376C:  BTFSC  FD8.2
0376E:  INCF   xC1,F
03770:  INCF   xC2,F
03772:  BTFSC  FD8.2
03774:  INCF   xC3,F
03776:  BRA    3730
....................    return((*s1 < *s2) ? -1: 1); 
03778:  MOVFF  5C1,03
0377C:  MOVFF  5C0,FE9
03780:  MOVFF  5C1,FEA
03784:  MOVFF  FEF,5C4
03788:  MOVFF  5C3,03
0378C:  MOVFF  5C2,FE9
03790:  MOVFF  5C3,FEA
03794:  MOVF   FEF,W
03796:  SUBWF  xC4,W
03798:  BC    379E
0379A:  MOVLW  FF
0379C:  BRA    37A0
0379E:  MOVLW  01
037A0:  MOVWF  01
037A2:  MOVLB  0
037A4:  RETURN 0
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
052C0:  MOVFF  5A1,03
052C4:  MOVLB  5
052C6:  MOVFF  5A0,FE9
052CA:  MOVFF  5A1,FEA
052CE:  MOVF   xA2,W
052D0:  SUBWF  FEF,W
052D2:  BZ    52F8
....................       if (*s == '\0') 
052D4:  MOVFF  5A1,03
052D8:  MOVFF  5A0,FE9
052DC:  MOVFF  5A1,FEA
052E0:  MOVF   FEF,F
052E2:  BNZ   52EC
....................          return(0); 
052E4:  MOVLW  00
052E6:  MOVWF  01
052E8:  MOVWF  02
052EA:  BRA    5300
052EC:  INCF   xA0,F
052EE:  BTFSC  FD8.2
052F0:  INCF   xA1,F
052F2:  MOVLB  0
052F4:  BRA    52C0
052F6:  MOVLB  5
....................    return(s); 
052F8:  MOVFF  5A0,01
052FC:  MOVFF  5A1,02
05300:  MOVLB  0
05302:  RETURN 0
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
*
051FE:  MOVLB  5
05200:  CLRF   x35
05202:  CLRF   x34
....................    { 
....................       if (*s == c) 
05204:  MOVFF  532,03
05208:  MOVFF  531,FE9
0520C:  MOVFF  532,FEA
05210:  MOVF   x33,W
05212:  SUBWF  FEF,W
05214:  BNZ   521E
....................          p = s; 
05216:  MOVFF  532,535
0521A:  MOVFF  531,534
....................       if (*s == '\0') 
0521E:  MOVFF  532,03
05222:  MOVFF  531,FE9
05226:  MOVFF  532,FEA
0522A:  MOVF   FEF,F
0522C:  BNZ   5238
....................          return(p); 
0522E:  MOVFF  534,01
05232:  MOVFF  535,02
05236:  BRA    5240
05238:  INCF   x31,F
0523A:  BTFSC  FD8.2
0523C:  INCF   x32,F
0523E:  BRA    5204
....................    } 
05240:  MOVLB  0
05242:  GOTO   5E0C (RETURN)
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
02F9C:  MOVFF  5D9,5DB
02FA0:  MOVFF  5D8,5DA
02FA4:  MOVFF  5DB,03
02FA8:  MOVLB  5
02FAA:  MOVFF  5DA,FE9
02FAE:  MOVFF  5DB,FEA
02FB2:  MOVF   FEF,F
02FB4:  BZ    2FC2
02FB6:  INCF   xDA,F
02FB8:  BTFSC  FD8.2
02FBA:  INCF   xDB,F
02FBC:  MOVLB  0
02FBE:  BRA    2FA4
02FC0:  MOVLB  5
....................    return(sc - s); 
02FC2:  MOVF   xD8,W
02FC4:  SUBWF  xDA,W
02FC6:  MOVWF  00
02FC8:  MOVF   xD9,W
02FCA:  SUBWFB xDB,W
02FCC:  MOVWF  03
02FCE:  MOVFF  00,01
02FD2:  MOVLB  0
02FD4:  RETURN 0
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... void usb_cdc_flush_tx_buffer(void)  
.................... { 
....................   #ifdef USB_CDC_DATA_LOCAL_SIZE 
....................    usb_cdc_tx_t n; 
....................   #endif 
....................    
....................    if (usb_cdc_put_buffer_nextin != 0) 
*
01F3C:  MOVLB  1
01F3E:  MOVF   x87,F
01F40:  BZ    1F66
....................    { 
....................      #ifndef USB_CDC_DATA_LOCAL_SIZE 
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE)) 
01F42:  MOVLW  02
01F44:  MOVLB  6
01F46:  MOVWF  x5E
01F48:  MOVLW  01
01F4A:  MOVWF  x60
01F4C:  MOVLW  48
01F4E:  MOVWF  x5F
01F50:  CLRF   x62
01F52:  MOVFF  187,661
01F56:  MOVLW  02
01F58:  MOVWF  x63
01F5A:  MOVLB  0
01F5C:  RCALL  1EB0
01F5E:  MOVF   01,F
01F60:  BZ    1F68
....................       { 
....................          usb_cdc_put_buffer_nextin = 0; 
01F62:  MOVLB  1
01F64:  CLRF   x87
01F66:  MOVLB  0
....................       } 
....................      #else 
....................       n = usb_cdc_put_buffer_nextin; 
....................       if (n > (USB_CDC_DATA_IN_SIZE-1)) //always send one less than packet size so we don't have to deal with 0 len packets 
....................          n = USB_CDC_DATA_IN_SIZE-1; 
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,n,USB_DTS_TOGGLE)) 
....................       { 
....................          //pull the buffer back 
....................          memmove(usb_cdc_put_buffer, &usb_cdc_put_buffer[n], usb_cdc_put_buffer_nextin-n); 
....................          usb_cdc_put_buffer_nextin -= n; 
....................       }       
....................      #endif 
....................    } 
01F68:  RETURN 0
.................... } 
....................  
.................... void usb_cdc_init(void)  
.................... { 
....................    usb_cdc_line_coding.dwDTERrate = 9600; 
*
0137E:  MOVLB  6
01380:  CLRF   x5F
01382:  CLRF   x5E
01384:  MOVLW  25
01386:  MOVWF  x5D
01388:  MOVLW  80
0138A:  MOVWF  x5C
0138C:  MOVLW  01
0138E:  MOVWF  FEA
01390:  MOVLW  37
01392:  MOVWF  FE9
01394:  MOVLW  06
01396:  MOVWF  FE2
01398:  MOVLW  5C
0139A:  MOVWF  FE1
0139C:  MOVLW  02
0139E:  MOVWF  01
013A0:  MOVFF  FE6,FEE
013A4:  DECFSZ 01,F
013A6:  BRA    13A0
013A8:  MOVLB  1
013AA:  CLRF   x39
013AC:  CLRF   x3A
....................    usb_cdc_line_coding.bCharFormat = 0; 
013AE:  MOVLB  6
013B0:  CLRF   x5C
013B2:  MOVLW  01
013B4:  MOVWF  FEA
013B6:  MOVLW  3B
013B8:  MOVWF  FE9
013BA:  MOVLW  06
013BC:  MOVWF  FE2
013BE:  MOVLW  5C
013C0:  MOVWF  FE1
013C2:  MOVFF  FE6,FEE
....................    usb_cdc_line_coding.bParityType = 0; 
013C6:  CLRF   x5C
013C8:  MOVLW  01
013CA:  MOVWF  FEA
013CC:  MOVLW  3C
013CE:  MOVWF  FE9
013D0:  MOVLW  06
013D2:  MOVWF  FE2
013D4:  MOVLW  5C
013D6:  MOVWF  FE1
013D8:  MOVFF  FE6,FEE
....................    usb_cdc_line_coding.bDataBits = 8; 
013DC:  MOVLW  08
013DE:  MOVWF  x5C
013E0:  MOVLW  01
013E2:  MOVWF  FEA
013E4:  MOVLW  3D
013E6:  MOVWF  FE9
013E8:  MOVLW  06
013EA:  MOVWF  FE2
013EC:  MOVLW  5C
013EE:  MOVWF  FE1
013F0:  MOVFF  FE6,FEE
....................    (int8)usb_cdc_carrier = 0; 
013F4:  MOVLB  1
013F6:  CLRF   x89
....................    usb_cdc_got_set_line_coding = FALSE; 
013F8:  BCF    x88.0
....................    usb_cdc_break = 0; 
013FA:  CLRF   x3F
013FC:  CLRF   x3E
....................    usb_cdc_put_buffer_nextin = 0; 
013FE:  CLRF   x87
....................    usb_cdc_get_buffer_status.got = 0; 
01400:  BCF    1F.0
....................    __usb_cdc_state = 0; 
01402:  CLRF   x8A
01404:  MOVLB  0
01406:  RETURN 0
.................... } 
....................  
.................... ////////////////// END USB CONTROL HANDLING ////////////////////////////////// 
....................  
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY ///////////////////////////// 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int bRxCarrier:1; //State of receiver carrier detection mechanism of device. This signal corresponds to V.24 signal 109 and RS-232 signal DCD. 
....................    unsigned int bTxCarrier:1; //State of transmission carrier. This signal corresponds to V.24 signal 106 and RS-232 signal DSR 
....................    unsigned int bBreak:1;  //State of break detection mechanism of the device. 
....................    unsigned int bRingSignal:1;   //State of ring signal detection of the device.  
....................    unsigned int bFraming:1;   //A framing error has occurred. 
....................    unsigned int bParity:1;    //A parity error has occurred. 
....................    unsigned int bOverRun:1;   //Received data has been discarded due to overrun in the device. 
....................    unsigned int reserved0:1;   //future use 
....................    unsigned int reserved1:8;   //future use 
.................... } cdc_serial_state_t; 
....................  
.................... /* 
....................    Send SERIAL_STATE notification to the host.  This contains DSR, DCD, Ring,  
....................    break signal and more (see cdc_serial_state_t). 
....................    Some of these values are held by the host (meaning it's value only needs 
....................    to be sent on change), but some values are one shot (meaning you continously 
....................    need to send value to host while being held). 
.................... */ 
.................... int1 usb_cdc_serial_state(cdc_serial_state_t state) 
.................... { 
....................   #if __USB_PIC_PERIF__ 
....................    #define CDC_EP1_NOTIFY_BUFFER usb_ep1_tx_buffer 
....................   #else 
....................    unsigned int8 payload[10]; 
....................    #define CDC_EP1_NOTIFY_BUFFER payload 
....................   #endif 
....................  
....................    if (!usb_tbe(USB_CDC_COMM_IN_ENDPOINT)) 
....................       return(FALSE); 
....................  
....................    //bmRequestType 
....................    CDC_EP1_NOTIFY_BUFFER[0] = 0xA1;  //0b10100001 
....................    //bNotification 
....................    CDC_EP1_NOTIFY_BUFFER[1] = 0x20;  //SERIAL_STATE 
....................    //wValue 
....................    CDC_EP1_NOTIFY_BUFFER[2] = 0; 
....................    CDC_EP1_NOTIFY_BUFFER[3] = 0; 
....................    //wIndex 
....................    CDC_EP1_NOTIFY_BUFFER[4] = 0; 
....................    CDC_EP1_NOTIFY_BUFFER[5] = 0; 
....................    //wLength 
....................    CDC_EP1_NOTIFY_BUFFER[6] = 2; //sizeof(cdc_serial_state_t) 
....................    CDC_EP1_NOTIFY_BUFFER[7] = 0; 
....................    //data 
....................    CDC_EP1_NOTIFY_BUFFER[8] = (unsigned int8)state; 
....................    CDC_EP1_NOTIFY_BUFFER[9] = (unsigned int16)state >> 8; 
....................  
....................   #if __USB_PIC_PERIF__ 
....................    usb_flush_in(USB_CDC_COMM_IN_ENDPOINT, 10, USB_DTS_TOGGLE); 
....................   #else 
....................    usb_put_packet(USB_CDC_COMM_IN_ENDPOINT, payload, 10, USB_DTS_TOGGLE); 
....................   #endif 
....................     
....................    return(TRUE); 
.................... } 
....................  
.................... void usb_cdc_get_discard(void) 
.................... { 
....................    usb_cdc_get_buffer_status.got = FALSE; 
*
01E36:  BCF    1F.0
....................    usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE); 
01E38:  MOVLW  02
01E3A:  MOVLB  6
01E3C:  MOVWF  x5E
01E3E:  MOVWF  x5F
01E40:  MOVLB  0
01E42:  RCALL  1BA2
01E44:  GOTO   1E60 (RETURN)
.................... } 
....................  
.................... char usb_cdc_getc(void)  
.................... { 
....................    char c; 
....................  
....................    while (!usb_cdc_kbhit())  
....................    { 
....................      #if defined(USB_ISR_POLLING) 
....................       usb_task(); 
....................      #endif 
....................    } 
....................  
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++]; 
....................  
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len)  
....................    { 
....................       usb_cdc_get_discard(); 
....................    } 
....................  
....................    return(c); 
.................... } 
....................  
.................... #define __USB_PAUSE_ISR()  int1 old_usbie; old_usbie = USBIE; USBIE = 0 
.................... #define __USB_RESTORE_ISR() if (old_usbie) USBIE = 1 
....................  
.................... static void _usb_cdc_putc_fast_noflush(char c) 
.................... { 
....................    __USB_PAUSE_ISR(); 
*
02EB2:  MOVLB  4
02EB4:  BCF    xB3.0
02EB6:  BTFSC  FA0.4
02EB8:  BSF    xB3.0
02EBA:  BCF    FA0.4
....................  
....................   #if defined(USB_CDC_DELAYED_FLUSH) 
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer))  
....................    { 
....................       usb_cdc_flush_tx_buffer(); 
....................    } 
....................   #endif 
....................  
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) { 
02EBC:  MOVLB  1
02EBE:  MOVF   x87,W
02EC0:  SUBLW  3E
02EC2:  BC    2EC8
....................       usb_cdc_put_buffer_nextin = sizeof(usb_cdc_put_buffer)-1;  //we just overflowed the buffer! 
02EC4:  MOVLW  3E
02EC6:  MOVWF  x87
....................    } 
....................     
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++] = c; 
02EC8:  MOVF   x87,W
02ECA:  INCF   x87,F
02ECC:  CLRF   03
02ECE:  ADDLW  48
02ED0:  MOVWF  FE9
02ED2:  MOVLW  01
02ED4:  ADDWFC 03,W
02ED6:  MOVWF  FEA
02ED8:  MOVFF  4B2,FEF
....................  
....................    __USB_RESTORE_ISR(); 
02EDC:  MOVLB  4
02EDE:  BTFSS  xB3.0
02EE0:  BRA    2EE4
02EE2:  BSF    FA0.4
02EE4:  MOVLB  0
02EE6:  GOTO   2EF0 (RETURN)
.................... } 
....................  
.................... void usb_cdc_putc_fast(char c) 
.................... { 
....................    _usb_cdc_putc_fast_noflush(c); 
02EEA:  MOVFF  4B1,4B2
02EEE:  BRA    2EB2
02EF0:  CLRF   17
02EF2:  BTFSC  FF2.7
02EF4:  BSF    17.7
02EF6:  BCF    FF2.7
....................  
....................   #if defined(USB_ISR_POLLING) 
....................    // if interrupts are disabled, we should clear all activity isrs 
....................    // before we attempt to put any data onto an endpoint. 
....................    if (!usb_tbe(USB_CDC_DATA_IN_ENDPOINT)) 
....................       return; 
....................    usb_task(); 
....................   #endif 
....................    
....................   #if !defined(USB_CDC_DELAYED_FLUSH) 
....................    //if (usb_cdc_put_buffer_free())  
....................    { 
....................       //printf("FL2 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................       usb_cdc_flush_tx_buffer(); 
02EF8:  CALL   1F3C
02EFC:  BTFSC  17.7
02EFE:  BSF    FF2.7
....................    } 
....................   #endif 
02F00:  GOTO   2F1C (RETURN)
....................  
....................    //putc('*'); 
.................... } 
....................  
.................... void usb_cdc_putc(char c) 
.................... { 
....................    while (!usb_cdc_putready())  
02F04:  MOVLW  3F
02F06:  BSF    FD8.0
02F08:  MOVLB  1
02F0A:  SUBFWB x87,W
02F0C:  BNZ   2F14
....................    { 
....................      #if 0 
....................       if (usb_cdc_put_buffer_free())  
....................       { 
....................          //printf("FL1 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................          usb_cdc_flush_tx_buffer(); 
....................       } 
....................      #endif 
....................      #if defined(USB_ISR_POLLING) 
02F0E:  MOVLB  0
02F10:  BRA    2F04
02F12:  MOVLB  1
....................       usb_task(); 
....................      #endif      
....................       //delay_ms(500); 
....................       //printf(putc_tbe,"TBE=%U CNT=%U LST=%U\r\n",usb_tbe(USB_CDC_DATA_IN_ENDPOINT), usb_cdc_put_buffer_nextin, usb_cdc_last_data_packet_size); 
....................    } 
....................    //putc('.'); 
....................    //putc(c); 
....................    usb_cdc_putc_fast(c); 
02F14:  MOVFF  4B0,4B1
02F18:  MOVLB  0
02F1A:  BRA    2EEA
02F1C:  RETURN 0
.................... } 
....................  
.................... int1 usb_cdc_putd(unsigned char *ptr, unsigned int8 len) 
.................... { 
....................  #if USB_EP2_TX_SIZE>=0x100 
....................    unsigned int16 i; 
....................  #else 
....................    unsigned int8 i; 
....................  #endif 
....................    char c; 
....................     
....................    i = 0; 
....................     
....................    if (!usb_cdc_put_buffer_free()) 
....................       return(FALSE); 
....................     
....................    while(len--) 
....................    { 
....................       c = *ptr++; 
....................       _usb_cdc_putc_fast_noflush(c); 
....................       if (++i >= USB_EP2_TX_SIZE) 
....................          break; 
....................    } 
....................     
....................    usb_cdc_flush_tx_buffer(); 
....................     
....................    return(TRUE); 
.................... } 
....................  
.................... int1 usb_cdc_puts(char *ptr) 
.................... {    
....................    unsigned int8 len; 
....................  
....................    len = strlen(ptr); 
....................    
....................    return(usb_cdc_putd(ptr, len)); 
.................... } 
....................  
.................... #endif //__USB_CDC_HELPERS_ONLY__ 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... BYTE gethex1_usb()  
.................... { 
....................    char digit; 
....................  
....................    digit = usb_cdc_getc(); 
....................  
....................    usb_cdc_putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... BYTE gethex_usb() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1_usb(); 
....................    lo = gethex1_usb(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string_usb(char* s, unsigned int max) { 
....................    unsigned int len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=usb_cdc_getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           usb_cdc_putc(c); 
....................           usb_cdc_putc(' '); 
....................           usb_cdc_putc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<max) { 
....................          s[len++]=c; 
....................          usb_cdc_putc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
....................  
.................... signed int get_int_usb() { 
....................   char s[7]; 
....................   signed int i; 
....................  
....................   get_string_usb(s, 7); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... signed long get_long_usb() { 
....................   char s[13]; 
....................   signed long l; 
....................  
....................   get_string_usb(s, 13); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... float get_float_usb() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string_usb(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //meda library, a compatable media library is required for FAT. 
.................... #use fast_io(b) 
.................... #define MMCSD_PIN_SCL     PIN_B6 //o 
.................... #define MMCSD_PIN_SDI     PIN_B7 //i 
.................... #define MMCSD_PIN_SDO     PIN_B5 //o 
.................... #define MMCSD_PIN_SELECT  PIN_B4 //o 
.................... #include <mmcsd.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           MMCSD.c                               //// 
.................... ////                                                                 //// 
.................... ////    This is a low-level driver for MMC and SD cards.             //// 
.................... ////                                                                 //// 
.................... //// --User Functions--                                              //// 
.................... ////                                                                 //// 
.................... //// mmcsd_init(): Initializes the media.                            //// 
.................... ////                                                                 //// 
.................... //// mmcsd_read_byte(a, p)                                           //// 
.................... ////  Reads a byte from the MMC/SD card at location a, saves to      //// 
.................... ////  pointer p.  Returns 0 if OK, non-zero if error.                //// 
.................... ////                                                                 //// 
.................... //// mmcsd_read_data(a, n, p)                                        //// 
.................... ////  Reads n bytes of data from the MMC/SD card starting at address //// 
.................... ////  a, saves result to pointer p.  Returns 0 if OK, non-zero if    //// 
.................... ////  error.                                                         //// 
.................... ////                                                                 //// 
.................... //// mmcsd_flush_buffer()                                            //// 
.................... ////  The two user write functions (mmcsd_write_byte() and           //// 
.................... ////  mmcsd_write_data()) maintain a buffer to speed up the writing  //// 
.................... ////  process.  Whenever a read or write is performed, the write     //// 
.................... ////  buffer is loaded with the specified page and only the          //// 
.................... ////  contents of this buffer is changed.  If any future writes      //// 
.................... ////  cross a page boundary then the buffer in RAM is written        //// 
.................... ////  to the MMC/SD and then the next page is loaded into the        //// 
.................... ////  buffer.  mmcsd_flush_buffer() forces the contents in RAM       //// 
.................... ////  to the MMC/SD card.  Returns 0 if OK, non-zero if errror.      //// 
.................... ////                                                                 //// 
.................... //// mmcsd_write_byte(a, d)                                          //// 
.................... ////  Writes data byte d to the MMC/SD address a.  Intelligently     //// 
.................... ////  manages a write buffer, therefore you may need to call         //// 
.................... ////  mmcsd_flush_buffer() to flush the buffer.                      //// 
.................... ////                                                                 //// 
.................... //// mmcsd_write_data(a, n, p)                                       //// 
.................... ////  Writes n bytes of data from pointer p to the MMC/SD card       //// 
.................... ////  starting at address a.  This function intelligently manages    //// 
.................... ////  a write buffer, therefore if you may need to call              //// 
.................... ////  mmcsd_flush_buffer() to flush any buffered characters.         //// 
.................... ////  returns 0 if OK, non-zero if error.                            //// 
.................... ////                                                                 //// 
.................... //// mmcsd_read_block(a, s, p)                                       //// 
.................... ////  Reads an entire page from the SD/MMC.  Keep in mind that the   //// 
.................... ////  start of the read has to be aligned to a block                 //// 
.................... ////  (Address % 512 = 0).  Therefore s must be evenly divisible by  //// 
.................... ////  512.  At the application level it is much more effecient to    //// 
.................... ////  to use mmcsd_read_data() or mmcsd_read_byte().  Returns 0      //// 
.................... ////  if successful, non-zero if error.                              //// 
.................... ////                                                                 //// 
.................... //// mmcsd_write_block(a, s, p):                                     //// 
.................... ////  Writes an entire page to the SD/MMC.  This will write an       //// 
.................... ////  entire page to the SD/MMC, so the address and size must be     //// 
.................... ////  evenly  divisble by 512.  At the application level it is much  //// 
.................... ////  more effecient to use mmcsd_write_data() or mmcsd_write_byte().//// 
.................... ////  Returns 0 if successful, non-zero if error.                    //// 
.................... ////                                                                 //// 
.................... //// mmcsd_print_cid(): Displays all data in the Card Identification //// 
.................... ////                     Register. Note this only works on SD cards. //// 
.................... ////                                                                 //// 
.................... //// mmcsd_print_csd(): Displays all data in the Card Specific Data  //// 
.................... ////                     Register. Note this only works on SD cards. //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// --Non-User Functions--                                          //// 
.................... ////                                                                 //// 
.................... //// mmcsd_go_idle_state(): Sends the GO_IDLE_STATE command to the   //// 
.................... ////                        SD/MMC.                                  //// 
.................... //// mmcsd_send_op_cond(): Sends the SEND_OP_COND command to the     //// 
.................... ////                        SD. Note this command only works on SD.  //// 
.................... //// mmcsd_send_if_cond(): Sends the SEND_IF_COND command to the     //// 
.................... ////                        SD. Note this command only works on SD.  //// 
.................... //// mmcsd_sd_status(): Sends the SD_STATUS command to the SD. Note  //// 
.................... ////                     This command only works on SD cards.        //// 
.................... //// mmcsd_send_status(): Sends the SEND_STATUS command to the       //// 
.................... ////                       SD/MMC.                                   //// 
.................... //// mmcsd_set_blocklen(): Sends the SET_BLOCKLEN command along with //// 
.................... ////                        the desired block length.                //// 
.................... //// mmcsd_app_cmd(): Sends the APP_CMD command to the SD. This only //// 
.................... ////                   works on SD cards and is used just before any //// 
.................... ////                   SD-only command (e.g. send_op_cond()).        //// 
.................... //// mmcsd_read_ocr(): Sends the READ_OCR command to the SD/MMC.     //// 
.................... //// mmcsd_crc_on_off(): Sends the CRC_ON_OFF command to the SD/MMC  //// 
.................... ////                      along with a bit to turn the CRC on/off.   //// 
.................... //// mmcsd_send_cmd(): Sends a command and argument to the SD/MMC.   //// 
.................... //// mmcsd_get_r1(): Waits for an R1 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_get_r2(): Waits for an R2 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_get_r3(): Waits for an R3 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_get_r7(): Waits for an R7 response from the SD/MMC and    //// 
.................... ////                  then saves the response to a buffer.           //// 
.................... //// mmcsd_wait_for_token(): Waits for a specified token from the    //// 
.................... ////                          SD/MMC.                                //// 
.................... //// mmcsd_crc7(): Generates a CRC7 using a pointer to some data,    //// 
.................... ////                and how many bytes long the data is.             //// 
.................... //// mmcsd_crc16(): Generates a CRC16 using a pointer to some data,  //// 
.................... ////                and how many bytes long the data is.             //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MMCSD_C 
.................... #define MMCSD_C 
....................  
.................... ///////////////////// 
.................... ////             //// 
.................... //// User Config //// 
.................... ////             //// 
.................... ///////////////////// 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #ifndef MMCSD_SPI_XFER 
....................    #if defined(MMCSD_SPI_HW) 
....................       #use spi(MASTER, MMCSD_SPI_HW, BITS=8, MSB_FIRST, MODE=0, baud=400000, stream=mmcsd_spi) 
....................    #else 
....................       #ifndef MMCSD_PIN_SCL 
....................          #define MMCSD_PIN_SCL     PIN_C3 //o 
....................          #define MMCSD_PIN_SDI     PIN_C4 //i 
....................          #define MMCSD_PIN_SDO     PIN_C5 //o 
....................          #define MMCSD_PIN_SELECT  PIN_C2 //o 
....................       #endif 
....................     
....................       #use spi(MASTER, DI=MMCSD_PIN_SDI, DO=MMCSD_PIN_SDO, CLK=MMCSD_PIN_SCL, BITS=8, MSB_FIRST, MODE=0, baud=400000, stream=mmcsd_spi) 
*
023AA:  MOVLB  6
023AC:  MOVF   x4E,W
023AE:  SUBLW  08
023B0:  BZ    23BA
023B2:  MOVWF  x4F
023B4:  RLCF   x4D,F
023B6:  DECFSZ x4F,F
023B8:  BRA    23B4
023BA:  BCF    F8A.6
023BC:  MOVFF  64E,64F
023C0:  BTFSS  x4D.7
023C2:  BCF    F8A.5
023C4:  BTFSC  x4D.7
023C6:  BSF    F8A.5
023C8:  RLCF   x4D,F
023CA:  BSF    F8A.6
023CC:  MOVLW  04
023CE:  MOVWF  x50
023D0:  DECFSZ x50,F
023D2:  BRA    23D0
023D4:  RLCF   01,F
023D6:  BTFSS  F81.7
023D8:  BCF    01.0
023DA:  BTFSC  F81.7
023DC:  BSF    01.0
023DE:  BCF    F8A.6
023E0:  MOVLW  03
023E2:  MOVWF  x50
023E4:  DECFSZ x50,F
023E6:  BRA    23E4
023E8:  DECFSZ x4F,F
023EA:  BRA    23C0
023EC:  MOVLB  0
023EE:  RETURN 0
....................    #endif 
....................     
....................    #define MMCSD_SPI_XFER(x)  spi_xfer(mmcsd_spi, x) 
.................... #endif 
....................  
.................... //////////////////////// 
.................... ////                //// 
.................... //// Useful Defines //// 
.................... ////                //// 
.................... //////////////////////// 
....................  
.................... enum MMCSD_err 
....................    {MMCSD_GOODEC = 0, 
....................    MMCSD_IDLE = 0x01, 
....................    MMCSD_ERASE_RESET = 0x02, 
....................    MMCSD_ILLEGAL_CMD = 0x04, 
....................    MMCSD_CRC_ERR = 0x08, 
....................    MMCSD_ERASE_SEQ_ERR = 0x10, 
....................    MMCSD_ADDR_ERR = 0x20, 
....................    MMCSD_PARAM_ERR = 0x40, 
....................    RESP_TIMEOUT = 0x80}; 
....................  
.................... #define GO_IDLE_STATE 0 
.................... #define SEND_OP_COND 1 
.................... #define SEND_IF_COND 8 
.................... #define SEND_CSD 9 
.................... #define SEND_CID 10 
.................... #define SD_STATUS 13 
.................... #define SEND_STATUS 13 
.................... #define SET_BLOCKLEN 16 
.................... #define READ_SINGLE_BLOCK 17 
.................... #define WRITE_BLOCK 24 
.................... #define SD_SEND_OP_COND 41 
.................... #define APP_CMD 55 
.................... #define READ_OCR 58 
.................... #define CRC_ON_OFF 59 
....................  
.................... #define IDLE_TOKEN 0x01 
.................... #define DATA_START_TOKEN 0xFE 
....................  
.................... #define MMCSD_MAX_BLOCK_SIZE 512 
....................  
.................... //////////////////////// 
.................... ///                  /// 
.................... /// Global Variables /// 
.................... ///                  /// 
.................... //////////////////////// 
....................  
.................... uint8_t g_mmcsd_buffer[MMCSD_MAX_BLOCK_SIZE]; 
....................  
.................... int1 g_CRC_enabled; 
.................... int1 g_MMCSDBufferChanged; 
....................  
.................... uint32_t g_mmcsdBufferAddress; 
....................  
.................... enum _card_type{SD, MMC} g_card_type; 
....................  
.................... ///////////////////////////// 
.................... ////                     //// 
.................... //// Function Prototypes //// 
.................... ////                     //// 
.................... ///////////////////////////// 
....................  
.................... MMCSD_err mmcsd_init(); 
.................... MMCSD_err mmcsd_read_data(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_read_block(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_write_data(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_write_block(uint32_t address, uint16_t size, uint8_t* ptr); 
.................... MMCSD_err mmcsd_go_idle_state(void); 
.................... MMCSD_err mmcsd_send_op_cond(void); 
.................... MMCSD_err mmcsd_send_if_cond(uint8_t r7[]); 
.................... MMCSD_err mmcsd_print_csd(); 
.................... MMCSD_err mmcsd_print_cid(); 
.................... MMCSD_err mmcsd_sd_status(uint8_t r2[]); 
.................... MMCSD_err mmcsd_send_status(uint8_t r2[]); 
.................... MMCSD_err mmcsd_set_blocklen(uint32_t blocklen); 
.................... MMCSD_err mmcsd_read_single_block(uint32_t address); 
.................... MMCSD_err mmcsd_write_single_block(uint32_t address); 
.................... MMCSD_err mmcsd_sd_send_op_cond(void); 
.................... MMCSD_err mmcsd_app_cmd(void); 
.................... MMCSD_err mmcsd_read_ocr(uint8_t* r1); 
.................... MMCSD_err mmcsd_crc_on_off(int1 crc_enabled); 
.................... MMCSD_err mmcsd_send_cmd(uint8_t cmd, uint32_t arg); 
.................... MMCSD_err mmcsd_get_r1(void); 
.................... MMCSD_err mmcsd_get_r2(uint8_t r2[]); 
.................... MMCSD_err mmcsd_get_r3(uint8_t r3[]); 
.................... MMCSD_err mmcsd_get_r7(uint8_t r7[]); 
.................... MMCSD_err mmcsd_wait_for_token(uint8_t token); 
.................... uint8_t mmcsd_crc7(char *data, uint8_t length); 
.................... uint16_t mmcsd_crc16(char *data, uint8_t length); 
.................... void mmcsd_select(); 
.................... void mmcsd_deselect(); 
....................  
.................... /// Fast Functions ! /// 
....................  
.................... MMCSD_err mmcsd_load_buffer(void); 
.................... MMCSD_err mmcsd_flush_buffer(void); 
.................... MMCSD_err mmcsd_move_buffer(uint32_t new_addr); 
.................... MMCSD_err mmcsd_read_byte(uint32_t addr, char* data); 
.................... MMCSD_err mmcsd_write_byte(uint32_t addr, char data); 
....................  
.................... ////////////////////////////////// 
.................... ////                          //// 
.................... //// Function Implementations //// 
.................... ////                          //// 
.................... ////////////////////////////////// 
....................  
.................... MMCSD_err mmcsd_init() 
.................... { 
....................    uint8_t 
....................       i, 
....................       r1; 
....................  
....................    g_CRC_enabled = TRUE; 
*
027F2:  MOVLB  1
027F4:  BSF    x88.1
....................    g_mmcsdBufferAddress = 0; 
027F6:  MOVLB  3
027F8:  CLRF   x94
027FA:  CLRF   x93
027FC:  CLRF   x92
027FE:  CLRF   x91
....................  
....................   #if defined(MMCSD_PIN_SCL) 
....................    output_drive(MMCSD_PIN_SCL); 
02800:  BCF    F93.6
....................   #endif 
....................   #if defined(MMCSD_PIN_SDO) 
....................    output_drive(MMCSD_PIN_SDO); 
02802:  BCF    F93.5
....................   #endif 
....................    output_drive(MMCSD_PIN_SELECT); 
02804:  BCF    F93.4
....................   #if defined(MMCSD_PIN_SDI) 
....................    output_float(MMCSD_PIN_SDI); 
02806:  BSF    F93.7
....................   #endif 
....................  
....................    mmcsd_deselect(); 
02808:  MOVLB  0
0280A:  RCALL  23F0
....................    delay_ms(15); 
0280C:  MOVLW  0F
0280E:  MOVLB  4
02810:  MOVWF  xC1
02812:  MOVLB  0
02814:  RCALL  2400
....................        
....................    /* begin initialization */ 
....................    i = 0; 
02816:  MOVLB  4
02818:  CLRF   xBF
....................    do 
....................    { 
....................       delay_ms(1); 
0281A:  MOVLW  01
0281C:  MOVWF  xC1
0281E:  MOVLB  0
02820:  RCALL  2400
....................       mmcsd_select();       
02822:  RCALL  242A
....................       r1=mmcsd_go_idle_state(); 
02824:  BRA    254E
02826:  MOVFF  01,4C0
....................       mmcsd_deselect(); 
0282A:  RCALL  23F0
....................       i++; 
0282C:  MOVLB  4
0282E:  INCF   xBF,F
....................       if(i == 0xFF) 
02830:  INCFSZ xBF,W
02832:  BRA    2840
....................       { 
....................          mmcsd_deselect(); 
02834:  MOVLB  0
02836:  RCALL  23F0
....................          return r1; 
02838:  MOVLB  4
0283A:  MOVFF  4C0,01
0283E:  BRA    28F4
....................       } 
....................    } while(!bit_test(r1, 0)); 
02840:  BTFSS  xC0.0
02842:  BRA    281A
....................  
....................    i = 0; 
02844:  CLRF   xBF
....................    do 
....................    { 
....................       delay_ms(1); 
02846:  MOVLW  01
02848:  MOVWF  xC1
0284A:  MOVLB  0
0284C:  RCALL  2400
....................       mmcsd_select(); 
0284E:  RCALL  242A
....................       r1=mmcsd_send_op_cond(); 
02850:  BRA    2566
02852:  MOVFF  01,4C0
....................       mmcsd_deselect(); 
02856:  RCALL  23F0
....................       i++; 
02858:  MOVLB  4
0285A:  INCF   xBF,F
....................       if(i == 0xFF) 
0285C:  INCFSZ xBF,W
0285E:  BRA    286C
....................       { 
....................          mmcsd_deselect(); 
02860:  MOVLB  0
02862:  RCALL  23F0
....................          return r1; 
02864:  MOVLB  4
02866:  MOVFF  4C0,01
0286A:  BRA    28F4
....................       } 
....................    } while(r1 & MMCSD_IDLE); 
0286C:  BTFSC  xC0.0
0286E:  BRA    2846
....................  
....................    /* figure out if we have an SD or MMC */ 
....................    mmcsd_select(); 
02870:  MOVLB  0
02872:  RCALL  242A
....................    r1=mmcsd_app_cmd(); 
02874:  BRA    2580
02876:  MOVFF  01,4C0
....................    r1=mmcsd_sd_send_op_cond(); 
0287A:  BRA    259A
0287C:  MOVFF  01,4C0
....................    mmcsd_deselect(); 
02880:  RCALL  23F0
....................  
....................    /* an mmc will return an 0x04 here */ 
....................    if(r1 == 0x04) 
02882:  MOVLB  4
02884:  MOVF   xC0,W
02886:  SUBLW  04
02888:  BNZ   2892
....................       g_card_type = MMC; 
0288A:  MOVLB  1
0288C:  BSF    x88.3
0288E:  BRA    2896
02890:  MOVLB  4
....................    else 
....................       g_card_type = SD; 
02892:  MOVLB  1
02894:  BCF    x88.3
....................  
....................    /* set block length to 512 bytes */ 
....................    mmcsd_select(); 
02896:  MOVLB  0
02898:  RCALL  242A
....................    r1 = mmcsd_set_blocklen(MMCSD_MAX_BLOCK_SIZE); 
0289A:  MOVLB  4
0289C:  CLRF   xC4
0289E:  CLRF   xC3
028A0:  MOVLW  02
028A2:  MOVWF  xC2
028A4:  CLRF   xC1
028A6:  MOVLB  0
028A8:  BRA    25B4
028AA:  MOVFF  01,4C0
....................    if(r1 != MMCSD_GOODEC) 
028AE:  MOVLB  4
028B0:  MOVF   xC0,F
028B2:  BZ    28C0
....................    { 
....................       mmcsd_deselect(); 
028B4:  MOVLB  0
028B6:  RCALL  23F0
....................       return r1; 
028B8:  MOVLB  4
028BA:  MOVFF  4C0,01
028BE:  BRA    28F4
....................    } 
....................    mmcsd_deselect(); 
028C0:  MOVLB  0
028C2:  RCALL  23F0
....................  
.................... /// this would be a good time to set a higher clock speed, 20MHz 
.................... #if defined(MMCSD_SPI_HW) 
....................    #if (getenv("CLOCK") <= 80000000) 
....................       #define MMC_SPI_CLK_DIV SPI_CLK_DIV_4 
....................    #else 
....................       #if defined(SPI_CLK_DIV_8) 
....................          #define MMC_SPI_CLK_DIV SPI_CLK_DIV_8 
....................       #else 
....................          #define MMC_SPI_CLK_DIV SPI_CLK_DIV_16 
....................       #endif 
....................    #endif 
....................    #error/warning the next line will only work if using SPI1 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | MMC_SPI_CLK_DIV); 
.................... #endif 
....................  
....................    /* turn CRCs off to speed up reading/writing */ 
....................    mmcsd_select(); 
028C4:  RCALL  242A
....................    r1 = mmcsd_crc_on_off(0); 
028C6:  MOVLB  4
028C8:  CLRF   xC1
028CA:  MOVLB  0
028CC:  BRA    25D6
028CE:  MOVFF  01,4C0
....................    if(r1 != MMCSD_GOODEC) 
028D2:  MOVLB  4
028D4:  MOVF   xC0,F
028D6:  BZ    28E4
....................    { 
....................       mmcsd_deselect(); 
028D8:  MOVLB  0
028DA:  RCALL  23F0
....................       return r1; 
028DC:  MOVLB  4
028DE:  MOVFF  4C0,01
028E2:  BRA    28F4
....................    } 
....................    mmcsd_deselect(); 
028E4:  MOVLB  0
028E6:  RCALL  23F0
....................  
....................    r1 = mmcsd_load_buffer(); 
028E8:  RCALL  27C6
028EA:  MOVFF  01,4C0
....................  
....................    return r1; 
028EE:  MOVLB  4
028F0:  MOVFF  4C0,01
028F4:  MOVLB  0
028F6:  GOTO   2C4C (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_read_data(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... { 
....................    MMCSD_err r1; 
....................    uint16_t i;  // counter for loops 
....................  
....................    for(i = 0; i < size; i++) 
*
02B2E:  MOVLB  6
02B30:  CLRF   x05
02B32:  CLRF   x04
02B34:  MOVF   x05,W
02B36:  SUBWF  x00,W
02B38:  BNC   2BBE
02B3A:  BNZ   2B46
02B3C:  MOVLB  5
02B3E:  MOVF   xFF,W
02B40:  MOVLB  6
02B42:  SUBWF  x04,W
02B44:  BC    2BBE
....................    { 
....................       r1 = mmcsd_read_byte(address++, ptr++); 
02B46:  MOVLB  5
02B48:  MOVFF  5FE,03
02B4C:  MOVFF  5FD,02
02B50:  MOVFF  5FC,01
02B54:  MOVFF  5FB,00
02B58:  MOVLW  01
02B5A:  ADDWF  xFB,F
02B5C:  BTFSC  FD8.0
02B5E:  INCF   xFC,F
02B60:  BTFSC  FD8.2
02B62:  INCF   xFD,F
02B64:  BTFSC  FD8.2
02B66:  INCF   xFE,F
02B68:  MOVFF  03,609
02B6C:  MOVFF  02,608
02B70:  MOVFF  01,607
02B74:  MOVFF  00,606
02B78:  MOVLB  6
02B7A:  MOVFF  602,03
02B7E:  MOVF   x01,W
02B80:  INCF   x01,F
02B82:  BTFSC  FD8.2
02B84:  INCF   x02,F
02B86:  MOVWF  x0A
02B88:  MOVFF  03,60B
02B8C:  MOVFF  609,614
02B90:  MOVFF  02,613
02B94:  MOVFF  01,612
02B98:  MOVFF  00,611
02B9C:  MOVFF  03,616
02BA0:  MOVWF  x15
02BA2:  MOVLB  0
02BA4:  BRA    2ADC
02BA6:  MOVFF  01,603
....................       if(r1 != MMCSD_GOODEC) 
02BAA:  MOVLB  6
02BAC:  MOVF   x03,F
02BAE:  BZ    2BB6
....................          return r1; 
02BB0:  MOVFF  603,01
02BB4:  BRA    2BC2
02BB6:  INCF   x04,F
02BB8:  BTFSC  FD8.2
02BBA:  INCF   x05,F
02BBC:  BRA    2B34
....................    } 
....................     
....................    return MMCSD_GOODEC; 
02BBE:  MOVLW  00
02BC0:  MOVWF  01
02BC2:  MOVLB  0
02BC4:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_read_block(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... {   
....................    MMCSD_err ec; 
....................    uint16_t i; // counter for loops 
....................  
....................    // send command 
....................    mmcsd_select(); 
*
026B6:  RCALL  242A
....................    ec = mmcsd_read_single_block(address); 
026B8:  MOVFF  636,641
026BC:  MOVFF  635,640
026C0:  MOVFF  634,63F
026C4:  MOVFF  633,63E
026C8:  BRA    2604
026CA:  MOVFF  01,63B
....................    if(ec != MMCSD_GOODEC) 
026CE:  MOVLB  6
026D0:  MOVF   x3B,F
026D2:  BZ    26E0
....................    { 
....................       mmcsd_deselect(); 
026D4:  MOVLB  0
026D6:  RCALL  23F0
....................       return ec; 
026D8:  MOVLB  6
026DA:  MOVFF  63B,01
026DE:  BRA    27C0
....................    } 
....................     
....................    // wait for the data start token 
....................    ec = mmcsd_wait_for_token(DATA_START_TOKEN); 
026E0:  MOVLW  FE
026E2:  MOVWF  x3E
026E4:  MOVLB  0
026E6:  BRA    2626
026E8:  MOVFF  01,63B
....................    if(ec != MMCSD_GOODEC) 
026EC:  MOVLB  6
026EE:  MOVF   x3B,F
026F0:  BZ    26FE
....................    { 
....................       mmcsd_deselect(); 
026F2:  MOVLB  0
026F4:  RCALL  23F0
....................       return ec; 
026F6:  MOVLB  6
026F8:  MOVFF  63B,01
026FC:  BRA    27C0
....................    } 
....................     
....................    // read in the data 
....................    for(i = 0; i < size; i += 1) 
026FE:  CLRF   x3D
02700:  CLRF   x3C
02702:  MOVF   x3D,W
02704:  SUBWF  x38,W
02706:  BNC   2738
02708:  BNZ   2710
0270A:  MOVF   x37,W
0270C:  SUBWF  x3C,W
0270E:  BC    2738
....................       ptr[i] = MMCSD_SPI_XFER(0xFF); 
02710:  MOVF   x39,W
02712:  ADDWF  x3C,W
02714:  MOVWF  FE9
02716:  MOVF   x3A,W
02718:  ADDWFC x3D,W
0271A:  MOVWF  FEA
0271C:  SETF   x4D
0271E:  MOVLW  08
02720:  MOVWF  x4E
02722:  MOVLB  0
02724:  RCALL  23AA
02726:  MOVF   01,W
02728:  MOVFF  01,FEF
0272C:  MOVLW  01
0272E:  MOVLB  6
02730:  ADDWF  x3C,F
02732:  MOVLW  00
02734:  ADDWFC x3D,F
02736:  BRA    2702
....................  
....................    if(g_CRC_enabled) 
02738:  MOVLB  1
0273A:  BTFSS  x88.1
0273C:  BRA    279C
....................    { 
....................       /* check the crc */ 
....................       if(make16(MMCSD_SPI_XFER(0xFF), MMCSD_SPI_XFER(0xFF)) != mmcsd_crc16(g_mmcsd_buffer, MMCSD_MAX_BLOCK_SIZE)) 
0273E:  MOVLB  6
02740:  SETF   x4D
02742:  MOVLW  08
02744:  MOVWF  x4E
02746:  MOVLB  0
02748:  RCALL  23AA
0274A:  MOVF   01,W
0274C:  MOVFF  01,63E
02750:  MOVLB  6
02752:  SETF   x4D
02754:  MOVLW  08
02756:  MOVWF  x4E
02758:  MOVLB  0
0275A:  RCALL  23AA
0275C:  MOVF   01,W
0275E:  MOVFF  01,63F
02762:  MOVFF  63E,641
02766:  MOVFF  01,640
0276A:  MOVLW  01
0276C:  MOVLB  6
0276E:  MOVWF  x43
02770:  MOVLW  91
02772:  MOVWF  x42
02774:  CLRF   x44
02776:  MOVLB  0
02778:  RCALL  2644
0277A:  MOVFF  02,03
0277E:  MOVF   01,W
02780:  MOVLB  6
02782:  SUBWF  x40,W
02784:  BNZ   278C
02786:  MOVF   03,W
02788:  SUBWF  x41,W
0278A:  BZ    2798
....................       { 
....................          mmcsd_deselect(); 
0278C:  MOVLB  0
0278E:  RCALL  23F0
....................          return MMCSD_CRC_ERR; 
02790:  MOVLW  08
02792:  MOVWF  01
02794:  MOVLB  6
02796:  BRA    27C0
....................       } 
....................    } 
02798:  BRA    27B6
0279A:  MOVLB  1
....................    else 
....................    { 
....................       /* have the card transmit the CRC, but ignore it */ 
....................       MMCSD_SPI_XFER(0xFF); 
0279C:  MOVLB  6
0279E:  SETF   x4D
027A0:  MOVLW  08
027A2:  MOVWF  x4E
027A4:  MOVLB  0
027A6:  RCALL  23AA
....................       MMCSD_SPI_XFER(0xFF); 
027A8:  MOVLB  6
027AA:  SETF   x4D
027AC:  MOVLW  08
027AE:  MOVWF  x4E
027B0:  MOVLB  0
027B2:  RCALL  23AA
027B4:  MOVLB  6
....................    } 
....................    mmcsd_deselect(); 
027B6:  MOVLB  0
027B8:  RCALL  23F0
....................  
....................    return MMCSD_GOODEC; 
027BA:  MOVLW  00
027BC:  MOVWF  01
027BE:  MOVLB  6
027C0:  MOVLB  0
027C2:  GOTO   27EE (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_write_data(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... { 
....................    MMCSD_err ec; 
....................    uint16_t i;  // counter for loops 
....................    
....................    for(i = 0; i < size; i++) 
*
03874:  MOVLB  6
03876:  CLRF   x1E
03878:  CLRF   x1D
0387A:  MOVF   x1E,W
0387C:  SUBWF  x19,W
0387E:  BNC   38FE
03880:  BNZ   3888
03882:  MOVF   x18,W
03884:  SUBWF  x1D,W
03886:  BC    38FE
....................    { 
....................       ec = mmcsd_write_byte(address++, *ptr++); 
03888:  MOVFF  617,03
0388C:  MOVFF  616,02
03890:  MOVFF  615,01
03894:  MOVFF  614,00
03898:  MOVLW  01
0389A:  ADDWF  x14,F
0389C:  BTFSC  FD8.0
0389E:  INCF   x15,F
038A0:  BTFSC  FD8.2
038A2:  INCF   x16,F
038A4:  BTFSC  FD8.2
038A6:  INCF   x17,F
038A8:  MOVFF  03,622
038AC:  MOVFF  02,621
038B0:  MOVFF  01,620
038B4:  MOVFF  00,61F
038B8:  MOVFF  61B,03
038BC:  MOVF   x1A,W
038BE:  INCF   x1A,F
038C0:  BTFSC  FD8.2
038C2:  INCF   x1B,F
038C4:  MOVWF  FE9
038C6:  MOVFF  03,FEA
038CA:  MOVFF  FEF,623
038CE:  MOVFF  622,627
038D2:  MOVFF  02,626
038D6:  MOVFF  01,625
038DA:  MOVFF  00,624
038DE:  MOVFF  623,628
038E2:  MOVLB  0
038E4:  BRA    3826
038E6:  MOVFF  01,61C
....................       if(ec != MMCSD_GOODEC) 
038EA:  MOVLB  6
038EC:  MOVF   x1C,F
038EE:  BZ    38F6
....................          return ec; 
038F0:  MOVFF  61C,01
038F4:  BRA    3902
038F6:  INCF   x1D,F
038F8:  BTFSC  FD8.2
038FA:  INCF   x1E,F
038FC:  BRA    387A
....................    } 
....................     
....................    return MMCSD_GOODEC; 
038FE:  MOVLW  00
03900:  MOVWF  01
03902:  MOVLB  0
03904:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_write_block(uint32_t address, uint16_t size, uint8_t* ptr) 
.................... {  
....................    MMCSD_err ec; 
....................    uint16_t i; 
....................  
....................    // send command 
....................    mmcsd_select(); 
*
0291C:  RCALL  242A
....................    ec = mmcsd_write_single_block(address); 
0291E:  MOVFF  636,641
02922:  MOVFF  635,640
02926:  MOVFF  634,63F
0292A:  MOVFF  633,63E
0292E:  BRA    28FA
02930:  MOVFF  01,63B
....................    if(ec != MMCSD_GOODEC) 
02934:  MOVLB  6
02936:  MOVF   x3B,F
02938:  BZ    2946
....................    { 
....................       mmcsd_deselect(); 
0293A:  MOVLB  0
0293C:  RCALL  23F0
....................       return ec; 
0293E:  MOVLB  6
02940:  MOVFF  63B,01
02944:  BRA    2A0C
....................    } 
....................     
....................    // send a data start token 
....................    MMCSD_SPI_XFER(DATA_START_TOKEN); 
02946:  MOVLW  FE
02948:  MOVWF  x4D
0294A:  MOVLW  08
0294C:  MOVWF  x4E
0294E:  MOVLB  0
02950:  RCALL  23AA
....................     
....................    // send all the data 
....................    for(i = 0; i < size; i += 1) 
02952:  MOVLB  6
02954:  CLRF   x3D
02956:  CLRF   x3C
02958:  MOVF   x3D,W
0295A:  SUBWF  x38,W
0295C:  BNC   298E
0295E:  BNZ   2966
02960:  MOVF   x37,W
02962:  SUBWF  x3C,W
02964:  BC    298E
....................    { 
....................       MMCSD_SPI_XFER(ptr[i]); 
02966:  MOVF   x39,W
02968:  ADDWF  x3C,W
0296A:  MOVWF  FE9
0296C:  MOVF   x3A,W
0296E:  ADDWFC x3D,W
02970:  MOVWF  FEA
02972:  MOVFF  FEF,63E
02976:  MOVFF  63E,64D
0297A:  MOVLW  08
0297C:  MOVWF  x4E
0297E:  MOVLB  0
02980:  RCALL  23AA
02982:  MOVLW  01
02984:  MOVLB  6
02986:  ADDWF  x3C,F
02988:  MOVLW  00
0298A:  ADDWFC x3D,F
0298C:  BRA    2958
....................    } 
....................  
....................    // if the CRC is enabled we have to calculate it, otherwise just send an 0xFFFF 
....................    if(g_CRC_enabled) 
0298E:  MOVLB  1
02990:  BTFSS  x88.1
02992:  BRA    29BE
....................       MMCSD_SPI_XFER(mmcsd_crc16(ptr, size)); 
02994:  MOVFF  63A,643
02998:  MOVFF  639,642
0299C:  MOVFF  637,644
029A0:  MOVLB  0
029A2:  RCALL  2644
029A4:  MOVFF  02,63F
029A8:  MOVFF  01,63E
029AC:  MOVFF  01,64D
029B0:  MOVLW  08
029B2:  MOVLB  6
029B4:  MOVWF  x4E
029B6:  MOVLB  0
029B8:  RCALL  23AA
029BA:  BRA    29D6
029BC:  MOVLB  1
....................    else 
....................    { 
....................       MMCSD_SPI_XFER(0xFF); 
029BE:  MOVLB  6
029C0:  SETF   x4D
029C2:  MOVLW  08
029C4:  MOVWF  x4E
029C6:  MOVLB  0
029C8:  RCALL  23AA
....................       MMCSD_SPI_XFER(0xFF); 
029CA:  MOVLB  6
029CC:  SETF   x4D
029CE:  MOVLW  08
029D0:  MOVWF  x4E
029D2:  MOVLB  0
029D4:  RCALL  23AA
....................    } 
....................     
....................    // get the error code back from the card; "data accepted" is 0bXXX00101 
....................    ec = mmcsd_get_r1(); 
029D6:  RCALL  251A
029D8:  MOVFF  01,63B
....................    if(ec & 0x0A) 
029DC:  MOVLB  6
029DE:  MOVF   x3B,W
029E0:  ANDLW  0A
029E2:  BZ    29F0
....................    { 
....................       mmcsd_deselect(); 
029E4:  MOVLB  0
029E6:  RCALL  23F0
....................       return ec; 
029E8:  MOVLB  6
029EA:  MOVFF  63B,01
029EE:  BRA    2A0C
....................    } 
....................     
....................    // wait for the line to go back high, this indicates that the write is complete 
....................    while(MMCSD_SPI_XFER(0xFF) == 0); 
029F0:  SETF   x4D
029F2:  MOVLW  08
029F4:  MOVWF  x4E
029F6:  MOVLB  0
029F8:  RCALL  23AA
029FA:  MOVF   01,W
029FC:  BTFSS  FD8.2
029FE:  BRA    2A04
02A00:  MOVLB  6
02A02:  BRA    29F0
....................    mmcsd_deselect(); 
02A04:  RCALL  23F0
....................  
....................    return MMCSD_GOODEC; 
02A06:  MOVLW  00
02A08:  MOVWF  01
02A0A:  MOVLB  6
02A0C:  MOVLB  0
02A0E:  GOTO   2A3E (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_go_idle_state(void) 
.................... { 
....................    mmcsd_send_cmd(GO_IDLE_STATE, 0); 
*
0254E:  MOVLB  6
02550:  CLRF   x42
02552:  CLRF   x46
02554:  CLRF   x45
02556:  CLRF   x44
02558:  CLRF   x43
0255A:  MOVLB  0
0255C:  RCALL  2482
....................     
....................    return mmcsd_get_r1(); 
0255E:  RCALL  251A
02560:  MOVF   01,W
02562:  GOTO   2826 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_send_op_cond(void) 
.................... { 
....................    mmcsd_send_cmd(SEND_OP_COND, 0); 
02566:  MOVLW  01
02568:  MOVLB  6
0256A:  MOVWF  x42
0256C:  CLRF   x46
0256E:  CLRF   x45
02570:  CLRF   x44
02572:  CLRF   x43
02574:  MOVLB  0
02576:  RCALL  2482
....................     
....................    return mmcsd_get_r1(); 
02578:  RCALL  251A
0257A:  MOVF   01,W
0257C:  GOTO   2852 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_send_if_cond(uint8_t r7[]) 
.................... { 
....................    mmcsd_send_cmd(SEND_IF_COND, 0x45A); 
....................  
....................    return mmcsd_get_r7(r7); 
.................... } 
....................  
.................... MMCSD_err mmcsd_print_csd() 
.................... {   
....................    uint8_t 
....................       buf[16], 
....................       i, 
....................       r1; 
....................  
....................    // MMCs don't support this command 
....................    if(g_card_type == MMC) 
....................       return MMCSD_PARAM_ERR; 
....................  
....................    mmcsd_select();    
....................    mmcsd_send_cmd(SEND_CSD, 0); 
....................    r1 = mmcsd_get_r1(); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................     
....................    r1 = mmcsd_wait_for_token(DATA_START_TOKEN); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................  
....................    for(i = 0; i < 16; i++) 
....................       buf[i] = MMCSD_SPI_XFER(0xFF); 
....................    mmcsd_deselect(); 
.................... /* 
....................    printf("\r\nCSD_STRUCTURE: %X", (buf[0] & 0x0C) >> 2); 
....................    printf("\r\nTAAC: %X", buf[1]); 
....................    printf("\r\nNSAC: %X", buf[2]); 
....................    printf("\r\nTRAN_SPEED: %X", buf[3]); 
....................    printf("\r\nCCC: %lX", (make16(buf[4], buf[5]) & 0xFFF0) >> 4); 
....................    printf("\r\nREAD_BL_LEN: %X", buf[5] & 0x0F);    
....................    printf("\r\nREAD_BL_PARTIAL: %X", (buf[6] & 0x80) >> 7); 
....................    printf("\r\nWRITE_BLK_MISALIGN: %X", (buf[6] & 0x40) >> 6); 
....................    printf("\r\nREAD_BLK_MISALIGN: %X", (buf[6] & 0x20) >> 5); 
....................    printf("\r\nDSR_IMP: %X", (buf[6] & 0x10) >> 4); 
....................    printf("\r\nC_SIZE: %lX", (((buf[6] & 0x03) << 10) | (buf[7] << 2) | ((buf[8] & 0xC0) >> 6))); 
....................    printf("\r\nVDD_R_CURR_MIN: %X", (buf[8] & 0x38) >> 3); 
....................    printf("\r\nVDD_R_CURR_MAX: %X", buf[8] & 0x07); 
....................    printf("\r\nVDD_W_CURR_MIN: %X", (buf[9] & 0xE0) >> 5); 
....................    printf("\r\nVDD_W_CURR_MAX: %X", (buf[9] & 0x1C) >> 2); 
....................    printf("\r\nC_SIZE_MULT: %X", ((buf[9] & 0x03) << 1) | ((buf[10] & 0x80) >> 7)); 
....................    printf("\r\nERASE_BLK_EN: %X", (buf[10] & 0x40) >> 6); 
....................    printf("\r\nSECTOR_SIZE: %X", ((buf[10] & 0x3F) << 1) | ((buf[11] & 0x80) >> 7)); 
....................    printf("\r\nWP_GRP_SIZE: %X", buf[11] & 0x7F); 
....................    printf("\r\nWP_GRP_ENABLE: %X", (buf[12] & 0x80) >> 7); 
....................    printf("\r\nR2W_FACTOR: %X", (buf[12] & 0x1C) >> 2); 
....................    printf("\r\nWRITE_BL_LEN: %X", ((buf[12] & 0x03) << 2) | ((buf[13] & 0xC0) >> 6)); 
....................    printf("\r\nWRITE_BL_PARTIAL: %X", (buf[13] & 0x20) >> 5); 
....................    printf("\r\nFILE_FORMAT_GRP: %X", (buf[14] & 0x80) >> 7); 
....................    printf("\r\nCOPY: %X", (buf[14] & 0x40) >> 6); 
....................    printf("\r\nPERM_WRITE_PROTECT: %X", (buf[14] & 0x20) >> 5); 
....................    printf("\r\nTMP_WRITE_PROTECT: %X", (buf[14] & 0x10) >> 4); 
....................    printf("\r\nFILE_FORMAT: %X", (buf[14] & 0x0C) >> 2); 
....................    printf("\r\nCRC: %X", buf[15]); 
.................... */ 
....................    return r1; 
.................... } 
....................  
.................... MMCSD_err mmcsd_print_cid() 
.................... { 
....................    uint8_t 
....................       buf[16], 
....................       i, 
....................       r1; 
....................  
....................    // MMCs don't support this command 
....................    if(g_card_type == MMC) 
....................       return MMCSD_PARAM_ERR; 
....................     
....................    mmcsd_select(); 
....................    mmcsd_send_cmd(SEND_CID, 0); 
....................    r1 = mmcsd_get_r1(); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................    r1 = mmcsd_wait_for_token(DATA_START_TOKEN); 
....................    if(r1 != MMCSD_GOODEC) 
....................    { 
....................       mmcsd_deselect(); 
....................       return r1; 
....................    } 
....................     
....................    for(i = 0; i < 16; i++) 
....................       buf[i] = MMCSD_SPI_XFER(0xFF); 
....................    mmcsd_deselect(); 
....................    /* 
....................    printf("\r\nManufacturer ID: %X", buf[0]); 
....................    printf("\r\nOEM/Application ID: %c%c", buf[1], buf[2]); 
....................    printf("\r\nOEM/Application ID: %c%c%c%c%c", buf[3], buf[4], buf[5], buf[6], buf[7]); 
....................    printf("\r\nProduct Revision: %X", buf[8]); 
....................    printf("\r\nSerial Number: %X%X%X%X", buf[9], buf[10], buf[11], buf[12]); 
....................    printf("\r\nManufacturer Date Code: %X%X", buf[13] & 0x0F, buf[14]); 
....................    printf("\r\nCRC-7 Checksum: %X", buf[15]); 
.................... */ 
....................    return r1; 
.................... } 
....................  
.................... MMCSD_err mmcsd_sd_status(uint8_t r2[]) 
.................... { 
....................    uint8_t i; 
....................  
....................    mmcsd_select(); 
....................    mmcsd_send_cmd(APP_CMD, 0); 
....................    r2[0]=mmcsd_get_r1(); 
....................    mmcsd_deselect(); 
....................  
....................    mmcsd_select(); 
....................    mmcsd_send_cmd(SD_STATUS, 0); 
....................  
....................    for(i = 0; i < 64; i++) 
....................       MMCSD_SPI_XFER(0xFF);       
....................  
....................    mmcsd_deselect(); 
....................  
....................    return mmcsd_get_r2(r2); 
.................... } 
....................  
.................... MMCSD_err mmcsd_send_status(uint8_t r2[]) 
.................... { 
....................    mmcsd_send_cmd(SEND_STATUS, 0);    
....................     
....................    return mmcsd_get_r2(r2); 
.................... } 
....................  
.................... MMCSD_err mmcsd_set_blocklen(uint32_t blocklen) 
.................... { 
....................    mmcsd_send_cmd(SET_BLOCKLEN, blocklen); 
*
025B4:  MOVLW  10
025B6:  MOVLB  6
025B8:  MOVWF  x42
025BA:  MOVFF  4C4,646
025BE:  MOVFF  4C3,645
025C2:  MOVFF  4C2,644
025C6:  MOVFF  4C1,643
025CA:  MOVLB  0
025CC:  RCALL  2482
....................     
....................    return mmcsd_get_r1(); 
025CE:  RCALL  251A
025D0:  MOVF   01,W
025D2:  GOTO   28AA (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_read_single_block(uint32_t address) 
.................... { 
....................    mmcsd_send_cmd(READ_SINGLE_BLOCK, address); 
*
02604:  MOVLW  11
02606:  MOVLB  6
02608:  MOVWF  x42
0260A:  MOVFF  641,646
0260E:  MOVFF  640,645
02612:  MOVFF  63F,644
02616:  MOVFF  63E,643
0261A:  MOVLB  0
0261C:  RCALL  2482
....................     
....................    return mmcsd_get_r1(); 
0261E:  RCALL  251A
02620:  MOVF   01,W
02622:  GOTO   26CA (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_write_single_block(uint32_t address) 
.................... { 
....................    mmcsd_send_cmd(WRITE_BLOCK, address); 
*
028FA:  MOVLW  18
028FC:  MOVLB  6
028FE:  MOVWF  x42
02900:  MOVFF  641,646
02904:  MOVFF  640,645
02908:  MOVFF  63F,644
0290C:  MOVFF  63E,643
02910:  MOVLB  0
02912:  RCALL  2482
....................    
....................    return mmcsd_get_r1(); 
02914:  RCALL  251A
02916:  MOVF   01,W
02918:  GOTO   2930 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_sd_send_op_cond(void) 
.................... { 
....................    mmcsd_send_cmd(SD_SEND_OP_COND, 0); 
*
0259A:  MOVLW  29
0259C:  MOVLB  6
0259E:  MOVWF  x42
025A0:  CLRF   x46
025A2:  CLRF   x45
025A4:  CLRF   x44
025A6:  CLRF   x43
025A8:  MOVLB  0
025AA:  RCALL  2482
....................     
....................    return mmcsd_get_r1(); 
025AC:  RCALL  251A
025AE:  MOVF   01,W
025B0:  GOTO   287C (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_app_cmd(void) 
.................... { 
....................    mmcsd_send_cmd(APP_CMD, 0); 
*
02580:  MOVLW  37
02582:  MOVLB  6
02584:  MOVWF  x42
02586:  CLRF   x46
02588:  CLRF   x45
0258A:  CLRF   x44
0258C:  CLRF   x43
0258E:  MOVLB  0
02590:  RCALL  2482
....................     
....................    return mmcsd_get_r1(); 
02592:  RCALL  251A
02594:  MOVF   01,W
02596:  GOTO   2876 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_read_ocr(int r3[]) 
.................... { 
....................    mmcsd_send_cmd(READ_OCR, 0); 
....................     
....................    return mmcsd_get_r3(r3); 
.................... } 
....................  
.................... MMCSD_err mmcsd_crc_on_off(int1 crc_enabled) 
.................... { 
....................    mmcsd_send_cmd(CRC_ON_OFF, crc_enabled); 
*
025D6:  MOVLW  3B
025D8:  MOVLB  6
025DA:  MOVWF  x42
025DC:  CLRF   x46
025DE:  CLRF   x45
025E0:  CLRF   x44
025E2:  MOVFF  4C1,643
025E6:  MOVLB  0
025E8:  RCALL  2482
....................     
....................    g_CRC_enabled = crc_enabled; 
025EA:  MOVLB  1
025EC:  BCF    x88.1
025EE:  MOVLB  4
025F0:  BTFSS  xC1.0
025F2:  BRA    25FA
025F4:  MOVLB  1
025F6:  BSF    x88.1
025F8:  MOVLB  4
....................     
....................    return mmcsd_get_r1(); 
025FA:  MOVLB  0
025FC:  RCALL  251A
025FE:  MOVF   01,W
02600:  GOTO   28CE (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_send_cmd(uint8_t cmd, uint32_t arg) 
.................... {    
....................    uint8_t packet[6]; // the entire command, argument, and crc in one variable 
....................    
....................    // construct the packet 
....................    // every command on an SD card is or'ed with 0x40 
....................    packet[0] = cmd | 0x40; 
*
02482:  MOVLB  6
02484:  MOVF   x42,W
02486:  IORLW  40
02488:  MOVWF  x47
....................    packet[1] = make8(arg, 3); 
0248A:  MOVFF  646,648
....................    packet[2] = make8(arg, 2); 
0248E:  MOVFF  645,649
....................    packet[3] = make8(arg, 1); 
02492:  MOVFF  644,64A
....................    packet[4] = make8(arg, 0); 
02496:  MOVFF  643,64B
....................  
....................    // calculate the crc if needed 
....................    if(g_CRC_enabled) 
0249A:  MOVLB  1
0249C:  BTFSS  x88.1
0249E:  BRA    24BA
....................       packet[5] = mmcsd_crc7(packet, 5); 
024A0:  MOVLW  06
024A2:  MOVLB  6
024A4:  MOVWF  x4E
024A6:  MOVLW  47
024A8:  MOVWF  x4D
024AA:  MOVLW  05
024AC:  MOVWF  x4F
024AE:  MOVLB  0
024B0:  BRA    242E
024B2:  MOVFF  01,64C
024B6:  BRA    24C0
024B8:  MOVLB  1
....................    else 
....................       packet[5] = 0xFF; 
024BA:  MOVLB  6
024BC:  SETF   x4C
024BE:  MOVLB  0
....................  
....................    // transfer the command and argument, with an extra 0xFF hacked in there 
....................    MMCSD_SPI_XFER(packet[0]); 
024C0:  MOVFF  647,64D
024C4:  MOVLW  08
024C6:  MOVLB  6
024C8:  MOVWF  x4E
024CA:  MOVLB  0
024CC:  RCALL  23AA
....................    MMCSD_SPI_XFER(packet[1]); 
024CE:  MOVFF  648,64D
024D2:  MOVLW  08
024D4:  MOVLB  6
024D6:  MOVWF  x4E
024D8:  MOVLB  0
024DA:  RCALL  23AA
....................    MMCSD_SPI_XFER(packet[2]); 
024DC:  MOVFF  649,64D
024E0:  MOVLW  08
024E2:  MOVLB  6
024E4:  MOVWF  x4E
024E6:  MOVLB  0
024E8:  RCALL  23AA
....................    MMCSD_SPI_XFER(packet[3]); 
024EA:  MOVFF  64A,64D
024EE:  MOVLW  08
024F0:  MOVLB  6
024F2:  MOVWF  x4E
024F4:  MOVLB  0
024F6:  RCALL  23AA
....................    MMCSD_SPI_XFER(packet[4]); 
024F8:  MOVFF  64B,64D
024FC:  MOVLW  08
024FE:  MOVLB  6
02500:  MOVWF  x4E
02502:  MOVLB  0
02504:  RCALL  23AA
....................    MMCSD_SPI_XFER(packet[5]); 
02506:  MOVFF  64C,64D
0250A:  MOVLW  08
0250C:  MOVLB  6
0250E:  MOVWF  x4E
02510:  MOVLB  0
02512:  RCALL  23AA
.................... //!   spi_write2(packet[0]); 
.................... //!   spi_write2(packet[1]); 
.................... //!   spi_write2(packet[2]); 
.................... //!   spi_write2(packet[3]); 
.................... //!   spi_write2(packet[4]); 
.................... //!   spi_write2(packet[5]); 
....................     
....................  
....................    return MMCSD_GOODEC; 
02514:  MOVLW  00
02516:  MOVWF  01
02518:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r1(void) 
0251A:  MOVLB  6
0251C:  CLRF   x42
0251E:  SETF   x43
.................... { 
....................    uint8_t 
....................       response = 0,  // place to hold the response coming back from the SPI line 
....................       timeout = 0xFF; // maximum amount loops to wait for idle before getting impatient and leaving the function with an error code 
....................      
....................    // loop until timeout == 0 
....................    while(timeout) 
02520:  MOVF   x43,F
02522:  BZ    2546
....................    { 
....................       // read what's on the SPI line 
....................       //  the SD/MMC requires that you leave the line high when you're waiting for data from it 
....................       response = MMCSD_SPI_XFER(0xFF); 
02524:  SETF   x4D
02526:  MOVLW  08
02528:  MOVWF  x4E
0252A:  MOVLB  0
0252C:  RCALL  23AA
0252E:  MOVF   01,W
02530:  MOVFF  01,642
....................       //response = MMCSD_SPI_XFER(0x00);//leave the line idle 
....................        
....................       // check to see if we got a response 
....................       if(response != 0xFF) 
02534:  MOVLB  6
02536:  INCFSZ x42,W
02538:  BRA    253C
0253A:  BRA    2542
....................       {    
....................          // fill in the response that we got and leave the function 
....................          return response; 
0253C:  MOVFF  642,01
02540:  BRA    254A
....................       } 
....................  
....................       // wait for a little bit longer 
....................       timeout--; 
02542:  DECF   x43,F
02544:  BRA    2520
....................    } 
....................     
....................    // for some reason, we didn't get a response back from the card 
....................    //  return the proper error codes 
....................    return RESP_TIMEOUT; 
02546:  MOVLW  80
02548:  MOVWF  01
0254A:  MOVLB  0
0254C:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r2(uint8_t r2[]) 
.................... { 
....................    r2[1] = mmcsd_get_r1(); 
....................     
....................    r2[0] = MMCSD_SPI_XFER(0xFF); 
....................     
....................    return 0; 
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r3(uint8_t r3[]) 
.................... { 
....................    return mmcsd_get_r7(r3); 
.................... } 
....................  
.................... MMCSD_err mmcsd_get_r7(uint8_t r7[]) 
.................... { 
....................    uint8_t i;   // counter for loop 
....................     
....................    // the top byte of r7 is r1 
....................    r7[4]=mmcsd_get_r1(); 
....................     
....................    // fill in the other 4 bytes 
....................    for(i = 0; i < 4; i++) 
....................       r7[3 - i] = MMCSD_SPI_XFER(0xFF); 
....................  
....................    return r7[4]; 
.................... } 
....................  
.................... MMCSD_err mmcsd_wait_for_token(uint8_t token) 
.................... { 
....................    MMCSD_err r1; 
....................     
....................    // get a token 
....................    r1 = mmcsd_get_r1(); 
*
02626:  RCALL  251A
02628:  MOVFF  01,63F
....................     
....................    // check to see if the token we recieved was the one that we were looking for 
....................    if(r1 == token) 
0262C:  MOVLB  6
0262E:  MOVF   x3E,W
02630:  SUBWF  x3F,W
02632:  BNZ   263A
....................       return MMCSD_GOODEC; 
02634:  MOVLW  00
02636:  MOVWF  01
02638:  BRA    263E
....................     
....................    // if that wasn't right, return the error 
....................    return r1;    
0263A:  MOVFF  63F,01
0263E:  MOVLB  0
02640:  GOTO   26E8 (RETURN)
.................... } 
....................  
.................... unsigned int8 mmcsd_crc7(char *data,uint8_t length) 
.................... { 
....................    uint8_t i, ibit, c, crc; 
....................      
....................    crc = 0x00;                                                                // Set initial value 
*
0242E:  MOVLB  6
02430:  CLRF   x53
....................  
....................    for (i = 0; i < length; i++, data++) 
02432:  CLRF   x50
02434:  MOVF   x4F,W
02436:  SUBWF  x50,W
02438:  BC    2474
....................    { 
....................       c = *data; 
0243A:  MOVFF  64D,FE9
0243E:  MOVFF  64E,FEA
02442:  MOVFF  FEF,652
....................  
....................       for (ibit = 0; ibit < 8; ibit++) 
02446:  CLRF   x51
02448:  MOVF   x51,W
0244A:  SUBLW  07
0244C:  BNC   2466
....................       { 
....................          crc = crc << 1; 
0244E:  BCF    FD8.0
02450:  RLCF   x53,F
....................          if ((c ^ crc) & 0x80) crc = crc ^ 0x09;                              // ^ is XOR 
02452:  MOVF   x52,W
02454:  XORWF  x53,W
02456:  ANDLW  80
02458:  BZ    245E
0245A:  MOVLW  09
0245C:  XORWF  x53,F
....................          c = c << 1; 
0245E:  BCF    FD8.0
02460:  RLCF   x52,F
02462:  INCF   x51,F
02464:  BRA    2448
....................       } 
....................  
....................        crc = crc & 0x7F; 
02466:  BCF    x53.7
02468:  MOVF   x50,W
0246A:  INCF   x50,F
0246C:  INCF   x4D,F
0246E:  BTFSC  FD8.2
02470:  INCF   x4E,F
02472:  BRA    2434
....................    } 
....................  
....................    shift_left(&crc, 1, 1);                                                    // MMC card stores the result in the top 7 bits so shift them left 1 
02474:  BSF    FD8.0
02476:  RLCF   x53,F
....................                                                                               // Should shift in a 1 not a 0 as one of the cards I have won't work otherwise 
....................    return crc; 
02478:  MOVFF  653,01
0247C:  MOVLB  0
0247E:  GOTO   24B2 (RETURN)
.................... } 
....................  
.................... uint16_t mmcsd_crc16(char *data, uint8_t length) 
.................... { 
....................    uint8_t i, ibit, c; 
....................  
....................    uint16_t crc; 
....................  
....................    crc = 0x0000;                                                                // Set initial value 
*
02644:  MOVLB  6
02646:  CLRF   x49
02648:  CLRF   x48
....................  
....................    for (i = 0; i < length; i++, data++) 
0264A:  CLRF   x45
0264C:  MOVF   x44,W
0264E:  SUBWF  x45,W
02650:  BC    26A4
....................    { 
....................       c = *data; 
02652:  MOVFF  642,FE9
02656:  MOVFF  643,FEA
0265A:  MOVFF  FEF,647
....................  
....................       for (ibit = 0; ibit < 8; ibit++) 
0265E:  CLRF   x46
02660:  MOVF   x46,W
02662:  SUBLW  07
02664:  BNC   2696
....................       { 
....................          crc = crc << 1; 
02666:  BCF    FD8.0
02668:  RLCF   x48,F
0266A:  RLCF   x49,F
....................          if ((c ^ crc) & 0x8000) crc = crc ^ 0x1021;                              // ^ is XOR 
0266C:  MOVF   x47,W
0266E:  XORWF  x48,W
02670:  MOVWF  x4A
02672:  MOVF   x49,W
02674:  MOVWF  x4B
02676:  ANDLW  00
02678:  MOVWF  00
0267A:  MOVF   x4B,W
0267C:  ANDLW  80
0267E:  MOVWF  03
02680:  MOVF   00,W
02682:  IORWF  03,W
02684:  BZ    268E
02686:  MOVLW  21
02688:  XORWF  x48,F
0268A:  MOVLW  10
0268C:  XORWF  x49,F
....................          c = c << 1; 
0268E:  BCF    FD8.0
02690:  RLCF   x47,F
02692:  INCF   x46,F
02694:  BRA    2660
....................       } 
....................  
....................        crc = crc & 0x7FFF; 
02696:  BCF    x49.7
02698:  MOVF   x45,W
0269A:  INCF   x45,F
0269C:  INCF   x42,F
0269E:  BTFSC  FD8.2
026A0:  INCF   x43,F
026A2:  BRA    264C
....................    } 
....................  
....................    shift_left(&crc, 2, 1);                                                    // MMC card stores the result in the top 7 bits so shift them left 1 
026A4:  BSF    FD8.0
026A6:  RLCF   x48,F
026A8:  RLCF   x49,F
....................                                                                               // Should shift in a 1 not a 0 as one of the cards I have won't work otherwise 
....................    return crc; 
026AA:  MOVFF  648,01
026AE:  MOVFF  649,02
026B2:  MOVLB  0
026B4:  RETURN 0
.................... } 
....................  
.................... void mmcsd_select() 
.................... { 
....................    output_low(MMCSD_PIN_SELECT); 
*
0242A:  BCF    F8A.4
0242C:  RETURN 0
.................... } 
....................  
.................... void mmcsd_deselect() 
.................... { 
....................    MMCSD_SPI_XFER(0xFF); 
*
023F0:  MOVLB  6
023F2:  SETF   x4D
023F4:  MOVLW  08
023F6:  MOVWF  x4E
023F8:  MOVLB  0
023FA:  RCALL  23AA
....................    output_high(MMCSD_PIN_SELECT); 
023FC:  BSF    F8A.4
023FE:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_load_buffer(void) 
.................... { 
....................    g_MMCSDBufferChanged = FALSE; 
*
027C6:  MOVLB  1
027C8:  BCF    x88.2
....................    return(mmcsd_read_block(g_mmcsdBufferAddress, MMCSD_MAX_BLOCK_SIZE, g_mmcsd_buffer)); 
027CA:  MOVFF  394,636
027CE:  MOVFF  393,635
027D2:  MOVFF  392,634
027D6:  MOVFF  391,633
027DA:  MOVLW  02
027DC:  MOVLB  6
027DE:  MOVWF  x38
027E0:  CLRF   x37
027E2:  MOVLW  01
027E4:  MOVWF  x3A
027E6:  MOVLW  91
027E8:  MOVWF  x39
027EA:  MOVLB  0
027EC:  BRA    26B6
027EE:  MOVF   01,W
027F0:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_flush_buffer(void) 
.................... { 
....................    if (g_MMCSDBufferChanged) 
*
02A12:  MOVLB  1
02A14:  BTFSS  x88.2
02A16:  BRA    2A44
....................    { 
....................       g_MMCSDBufferChanged = FALSE; 
02A18:  BCF    x88.2
....................       return(mmcsd_write_block(g_mmcsdBufferAddress, MMCSD_MAX_BLOCK_SIZE, g_mmcsd_buffer)); 
02A1A:  MOVFF  394,636
02A1E:  MOVFF  393,635
02A22:  MOVFF  392,634
02A26:  MOVFF  391,633
02A2A:  MOVLW  02
02A2C:  MOVLB  6
02A2E:  MOVWF  x38
02A30:  CLRF   x37
02A32:  MOVLW  01
02A34:  MOVWF  x3A
02A36:  MOVLW  91
02A38:  MOVWF  x39
02A3A:  MOVLB  0
02A3C:  BRA    291C
02A3E:  MOVF   01,W
02A40:  BRA    2A48
02A42:  MOVLB  1
....................    } 
....................    return(0);  //ok 
02A44:  MOVLW  00
02A46:  MOVWF  01
02A48:  MOVLB  0
02A4A:  GOTO   2AA4 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_move_buffer(uint32_t new_addr) 
02A4E:  MOVLB  6
02A50:  CLRF   x2E
.................... { 
....................    MMCSD_err ec = MMCSD_GOODEC; 
....................    uint32_t 
....................       //cur_block, 
....................       new_block; 
....................     
....................    // make sure we're still on the same block 
....................    //cur_block = g_mmcsdBufferAddress - (g_mmcsdBufferAddress % MMCSD_MAX_BLOCK_SIZE); 
....................    new_block = new_addr - (new_addr % MMCSD_MAX_BLOCK_SIZE); 
02A52:  MOVF   x2B,W
02A54:  ANDLW  01
02A56:  MOVWF  01
02A58:  CLRF   02
02A5A:  CLRF   03
02A5C:  MOVF   x2A,W
02A5E:  SUBWF  x2A,W
02A60:  MOVWF  x2F
02A62:  MOVF   01,W
02A64:  SUBWFB x2B,W
02A66:  MOVWF  x30
02A68:  MOVF   02,W
02A6A:  SUBWFB x2C,W
02A6C:  MOVWF  x31
02A6E:  MOVF   03,W
02A70:  SUBWFB x2D,W
02A72:  MOVWF  x32
....................     
....................    //if(cur_block != new_block) 
....................    if(g_mmcsdBufferAddress != new_block) 
02A74:  MOVF   x2F,W
02A76:  MOVLB  3
02A78:  SUBWF  x91,W
02A7A:  BNZ   2A9A
02A7C:  MOVLB  6
02A7E:  MOVF   x30,W
02A80:  MOVLB  3
02A82:  SUBWF  x92,W
02A84:  BNZ   2A9A
02A86:  MOVLB  6
02A88:  MOVF   x31,W
02A8A:  MOVLB  3
02A8C:  SUBWF  x93,W
02A8E:  BNZ   2A9A
02A90:  MOVLB  6
02A92:  MOVF   x32,W
02A94:  MOVLB  3
02A96:  SUBWF  x94,W
02A98:  BZ    2AD2
....................    { 
....................       // dump the old buffer 
....................       if (g_MMCSDBufferChanged) 
02A9A:  MOVLB  1
02A9C:  BTFSS  x88.2
02A9E:  BRA    2AB8
....................       { 
....................          ec = mmcsd_flush_buffer(); 
02AA0:  MOVLB  0
02AA2:  BRA    2A12
02AA4:  MOVFF  01,62E
....................          if(ec != MMCSD_GOODEC) 
02AA8:  MOVLB  6
02AAA:  MOVF   x2E,F
02AAC:  BZ    2AB4
....................             return ec; 
02AAE:  MOVFF  62E,01
02AB2:  BRA    2AD8
....................          g_MMCSDBufferChanged = FALSE; 
02AB4:  MOVLB  1
02AB6:  BCF    x88.2
....................       } 
....................           
....................       // figure out the best place for a block 
....................       g_mmcsdBufferAddress = new_block; 
02AB8:  MOVFF  632,394
02ABC:  MOVFF  631,393
02AC0:  MOVFF  630,392
02AC4:  MOVFF  62F,391
....................  
....................       // load up a new buffer 
....................       ec = mmcsd_load_buffer(); 
02AC8:  MOVLB  0
02ACA:  RCALL  27C6
02ACC:  MOVFF  01,62E
02AD0:  MOVLB  3
....................    } 
....................     
....................    return ec; 
02AD2:  MOVLB  6
02AD4:  MOVFF  62E,01
02AD8:  MOVLB  0
02ADA:  RETURN 0
.................... } 
....................  
.................... MMCSD_err mmcsd_read_byte(uint32_t addr, char* data) 
.................... { 
....................    MMCSD_err ec; 
....................     
....................    ec = mmcsd_move_buffer(addr); 
02ADC:  MOVFF  614,62D
02AE0:  MOVFF  613,62C
02AE4:  MOVFF  612,62B
02AE8:  MOVFF  611,62A
02AEC:  RCALL  2A4E
02AEE:  MOVFF  01,617
....................    if(ec != MMCSD_GOODEC) 
02AF2:  MOVLB  6
02AF4:  MOVF   x17,F
02AF6:  BZ    2AFE
....................    { 
....................      return ec; 
02AF8:  MOVFF  617,01
02AFC:  BRA    2B28
....................    } 
....................   
....................    *data = g_mmcsd_buffer[addr % MMCSD_MAX_BLOCK_SIZE]; 
02AFE:  MOVF   x12,W
02B00:  ANDLW  01
02B02:  MOVWF  x1B
02B04:  CLRF   x1C
02B06:  CLRF   x1D
02B08:  MOVLW  91
02B0A:  ADDWF  x11,W
02B0C:  MOVWF  FE9
02B0E:  MOVLW  01
02B10:  ADDWFC x1B,W
02B12:  MOVWF  FEA
02B14:  MOVFF  FEF,61E
02B18:  MOVFF  616,FEA
02B1C:  MOVFF  615,FE9
02B20:  MOVFF  61E,FEF
....................  
....................    return MMCSD_GOODEC; 
02B24:  MOVLW  00
02B26:  MOVWF  01
02B28:  MOVLB  0
02B2A:  GOTO   2BA6 (RETURN)
.................... } 
....................  
.................... MMCSD_err mmcsd_write_byte(uint32_t addr, char data) 
.................... {   
....................    MMCSD_err ec; 
....................    ec = mmcsd_move_buffer(addr); 
*
03826:  MOVFF  627,62D
0382A:  MOVFF  626,62C
0382E:  MOVFF  625,62B
03832:  MOVFF  624,62A
03836:  CALL   2A4E
0383A:  MOVFF  01,629
....................    if(ec != MMCSD_GOODEC) 
0383E:  MOVLB  6
03840:  MOVF   x29,F
03842:  BZ    384A
....................      return ec; 
03844:  MOVFF  629,01
03848:  BRA    386E
....................     
....................    g_mmcsd_buffer[addr % MMCSD_MAX_BLOCK_SIZE] = data; 
0384A:  MOVF   x25,W
0384C:  ANDLW  01
0384E:  MOVWF  x2B
03850:  CLRF   x2C
03852:  CLRF   x2D
03854:  MOVLW  91
03856:  ADDWF  x24,W
03858:  MOVWF  FE9
0385A:  MOVLW  01
0385C:  ADDWFC x2B,W
0385E:  MOVWF  FEA
03860:  MOVFF  628,FEF
....................     
....................    g_MMCSDBufferChanged = TRUE; 
03864:  MOVLB  1
03866:  BSF    x88.2
....................  
....................    return MMCSD_GOODEC; 
03868:  MOVLW  00
0386A:  MOVWF  01
0386C:  MOVLB  6
0386E:  MOVLB  0
03870:  GOTO   38E6 (RETURN)
.................... } 
....................  
.................... #endif 
....................  
.................... #define STREAM_SERIAL_INPUT   usb_cdc_put 
.................... //!//#include <input.c> 
.................... //FAT library. 
.................... #include <fat.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          FAT_PIC.C                              //// 
.................... ////                                                                 //// 
.................... //// Driver/Library for a FAT filesystem with a PIC                  //// 
.................... ////                                                                 //// 
.................... //// This Library was designed to resemble standard ANSI C I/O as    //// 
.................... ////  much as possible. There are, however, some caveats to this.    //// 
.................... ////  Please read the comments to make sure the inputs and outputs   //// 
.................... ////  to each function are understood before using anything in       //// 
.................... ////  this library.                                                  //// 
.................... ////                                                                 //// 
.................... //// This library supports FAT16 and FAT32, but not both at the same //// 
.................... //// time (this is a compile option, see options below).  It is      //// 
.................... //// recommended to use FAT32, FAT32 also has been tested more.      //// 
.................... ////                                                                 //// 
.................... //// Any function with an argument taking in a file name must be in  //// 
.................... ////  the form of...                                                 //// 
.................... ////  "/filename.fil" for a file in the root directory               //// 
.................... ////  "/Directory/filename.fil" for a file in a subdirectory of root //// 
.................... ////  "/Directory/Subdirectory/filename.fil" and so on...            //// 
.................... ////                                                                 //// 
.................... //// Any function with an argument taking in a directory name must   //// 
.................... ////  be in the form of...                                           //// 
.................... ////  "/Dirname/" for a directory in the root directory              //// 
.................... ////  "/Dirname/Subdirname/" for a directory in a subdirectory of    //// 
.................... ////  root and so on...                                              //// 
.................... ////                                                                 //// 
.................... //// A compatable media library must be provided.  This is           //// 
.................... //// documented after the User Functions.                            //// 
.................... ////                                                                 //// 
.................... //// -- User Functions --                                            //// 
.................... ////                                                                 //// 
.................... //// fat_init()                                                      //// 
.................... ////  Initializes the FAT library, also initializes the media.       //// 
.................... ////                                                                 //// 
.................... //// fatopen(char *name, char *mode, FILE *fstream)                  //// 
.................... ////  Opens up a FILE stream to a specified file with the specified  ////  
.................... ////  permission mode:                                               //// 
.................... ////             Permissions: "r" = read                             //// 
.................... ////                          "w" = write                            //// 
.................... ////                          "a" = append                           //// 
.................... ////                          "rb" = read binarily                   //// 
.................... ////             "w" will erase all of the data in the file upon     //// 
.................... ////              the opening of the file.                           //// 
.................... ////             "a" will tack on all of the data to the end of the  //// 
.................... ////              file.                                              //// 
.................... ////             "r" will keep on reading until the stream           //// 
.................... ////              hits an '\0'                                       //// 
.................... ////             "rb" will keep on reading until the amount of       //// 
.................... ////              bytes read equals the size of the file.            //// 
.................... ////                                                                 //// 
.................... ////  Unlike standard C fopen(), this does not malloc a FILE -       //// 
.................... ////  instead the caller will have to have allready allocated a      //// 
.................... ////  a FILE and pass a pointer to it.                               //// 
.................... ////                                                                 //// 
.................... //// fatreopen(char *name, char *mode, FILE *fstream)                //// 
.................... ////  Closes a FILE stream, then reopens the stream with a new file  //// 
.................... ////  and new permissions.                                           //// 
.................... ////                                                                 //// 
.................... //// fatclose(FILE *fstream)                                         //// 
.................... ////  Closes a FILE stream. It is very important to call this        ////  
.................... ////  function when you're done reading or writing to a file.        ////                             //// 
.................... ////                                                                 //// 
.................... //// fatgetc(FILE *fstream)                                          //// 
.................... ////  Gets a character from a stream. An EOF will be returned at     ////  
.................... ////  different times depending on whether or not the stream is      ////  
.................... ////  reading binarily.  If not reading binarily: EOF when the       ////  
.................... ////  stream reads a '\0'.  If reading binarily: EOF when the amount ////  
.................... ////  of bytes read equals the size of the file (end of file).       //// 
.................... ////                                                                 //// 
.................... //// fatputc(char c, FILE *fstream)                                  //// 
.................... ////  Puts a character into a stream (write to the file).            //// 
.................... ////  Writes are buffered, so the media may not be written to until  //// 
.................... ////  a fatclose().                                                  //// 
.................... ////                                                                 //// 
.................... //// char* fatgets(char* str, int num, FILE *fstream)                ////  
.................... ////  Gets characters from a stream until either a '\r',  EOF, or    ////  
.................... ////  num - 1 is hit.                                                //// 
.................... ////                                                                 //// 
.................... //// fatputs(char* str, FILE *fstream)                               //// 
.................... ////  Puts a string into a stream (write a string to the file).      //// 
.................... ////                                                                 //// 
.................... //// fatprintf(FILE *stream): Printfs the entire stream.             //// 
.................... ////  printf()'s the entire stream (printf()'s the contents of the 
.................... ////  file). 
.................... ////                                                                 //// 
.................... //// fatgetpos(FILE *fstream, fatpos_t *pos)                         //// 
.................... ////  Gets the current position of the stream/file, saves to pos.    //// 
.................... ////                                                                 //// 
.................... //// fatsetpos(FILE *fstream, fatpos_t *pos)                          //// 
.................... ////  Sets the current position of the stream/file.                  //// 
.................... ////                                                                 //// 
.................... //// fatseek(FILE *fstream, int32 offset, int origin)                 //// 
.................... ////  Sets the current position of the stream according to the       //// 
.................... ////  origin parameter:                                              //// 
.................... ////             SEEK_CUR: Set position relative to the              //// 
.................... ////              current stream position.                           //// 
.................... ////             SEEK_END: Set position relative to the              //// 
.................... ////              end of the stream.                                 //// 
.................... ////             SEEK_SET: Set position relative to the              //// 
.................... ////              beginning of the stream.                           //// 
.................... ////                                                                 //// 
.................... //// fateof(FILE *fstream)                                           //// 
.................... ////  Returns non-zero if the stream/file position is at EOF,        ////  
.................... ////  non-zero if there are still data left in the stream.           //// 
.................... ////                                                                 //// 
.................... //// faterror(FILE *fstream):                                        //// 
.................... ////  Returns non-zero if there have been errors with the stream,    //// 
.................... ////  zero if the stream has been operating correctly since it has   //// 
.................... ////  been opened.                                                   //// 
.................... ////                                                                 //// 
.................... //// fatread(void* buffer, int size, int32 num, FILE* fstream)       //// 
.................... ////  Reads size*num chars from the stream, saves to buffer.         //// 
.................... ////                                                                 //// 
.................... //// fatwrite(void* buffer, int size, int32 num, FILE* fstream)      ////  
.................... ////  Writes size*num chars from buffer to the stream.               //// 
.................... ////                                                                 //// 
.................... //// fatflush(FILE *fstream)                                         //// 
.................... ////  Flushes the buffer in a stream.                                //// 
.................... ////                                                                 //// 
.................... //// clearerr(FILE *fstream)                                         //// 
.................... ////  Clears any error flags in the stream.                          //// 
.................... ////                                                                 //// 
.................... //// rewind(FILE *fstream)                                           //// 
.................... ////  Send the stream back to the beginning of the file.             //// 
.................... ////                                                                 //// 
.................... //// fatpos_t fattell(FILE *fstream)                                 //// 
.................... ////  Returns the current position of the stream.                    //// 
.................... ////                                                                 //// 
.................... //// rm_file(char *fname)                                            //// 
.................... ////  Removes a file.                                                //// 
.................... ////                                                                 //// 
.................... //// rm_dir(char *dirname)                                           //// 
.................... ////  Removes a directory.                                           //// 
.................... ////                                                                 //// 
.................... //// mk_file(char *fname)                                            //// 
.................... ////  Makes a file, file will be blank.                              //// 
.................... ////                                                                 //// 
.................... //// mk_dir(char *dirname)                                           //// 
.................... ////  Makes a directory.                                             //// 
.................... ////                                                                 //// 
.................... //// format(int32 mediaSize)                                         //// 
.................... ////  Formats the media into a FAT32 or FAT16 file system.           //// 
.................... ////  If you specify a mediaSize larger than the actual media bad    //// 
.................... ////  things will happen.  If you specify a mediaSize smaller than   //// 
.................... ////  the actual media size will simply limit the filesystem from    //// 
.................... ////  using 0 to mediaSize-1.  Anything after mediaSize can be used  //// 
.................... ////  by the application (perhaps as a general purpose EEPROM?)      //// 
.................... ////  NOTE: Windows thinks the filesystem is RAW.                    //// 
.................... ////  NOTE: This may be a little buggy.                              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// This library was written to use CCS's MMC/SD library as the     //// 
.................... //// media source.  If you want to use a different media source,     //// 
.................... //// you must provide the following 4 functions:                     //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_init(void);                                          //// 
.................... ////  Initializes the media.  This will be called by fat_init().     //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_read_bytes(int32 a, int16 s, char *p);               //// 
.................... ////  Read s bytes from p to the media starting at address a.        //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_write_data(int32 a, int16 s, char *p);               //// 
.................... ////  Write s bytes from p to the media starting at address a.       //// 
.................... ////  To maximize throughput on some medias, it's a good idea to     //// 
.................... ////  buffer writes in this function.                                //// 
.................... ////                                                                 //// 
.................... //// int8 mmcsd_flush_buffer(void);                                  //// 
.................... ////  If your write function is buffering writes, this will flush    //// 
.................... ////  the buffer and write it to the media.                          //// 
.................... ////                                                                 //// 
.................... //// All four functions should return 0 if OK, non-zero if error.    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... // NOTE This library has no concept of what time and date it currently is. 
.................... //       All files and folders created or modified using this library 
.................... //       will have invalid/inaccurate timestamps and datestamps. 
....................  
.................... // NOTE To save on ROM and RAM space, the user of this library will have to  
.................... //       define what type of FAT they will be working with. The defines are  
.................... //       in the Useful Defines section below. 
....................  
.................... // NOTE For faster writing or appending for an application such as a logger,  
.................... //       uncomment #FAST_FAT below.  This will make the FAT library assume  
.................... //       there is one file on the card to write or append to, thereby 
.................... //       making writing and appending much faster. Reading is impossible in  
.................... //       this mode. 
.................... //       THIS IS NOT TESTED VERY WELL YET! 
....................  
.................... // NOTE The current maximum file name length (full path) is 32 characters  
.................... //       long. If longer file names are desired, change the  
.................... //       MAX_FILE_NAME_LENGTH define below. Creating a file whose full path  
.................... //       is longer than MAX_FILE_NAME_LENGTH may lead to weird operation. Keep 
.................... //       in mind that making this define larger will make your RAM usage go  
.................... //        up. 
....................  
.................... #ifndef FAT_PIC_C 
.................... #define FAT_PIC_C 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #case 
....................  
.................... ////////////////////// 
.................... ///                /// 
.................... /// Useful Defines /// 
.................... ///                /// 
.................... ////////////////////// 
....................  
.................... /// Define your FAT type here /// 
.................... //#define FAT16 
.................... #define FAT32 
....................  
.................... /// For faster single-file writing, uncomment this line below /// 
.................... //#define FAST_FAT 
....................  
.................... /// Everything else /// 
.................... #define MAX_FILE_NAME_LENGTH 0x20  // the maximum length of a file name for our FAT, including /0 terminator 
.................... #define STREAM_BUF_SIZE 0x20       // how big the FILE buffer is. 0x20 is optimal 
....................  
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #define EOF -1 
.................... #define GOODEC 0 
.................... #define fatpos_t int32 
.................... #define SEEK_CUR 0 
.................... #define SEEK_END 1 
.................... #define SEEK_SET 2 
....................  
.................... //////////////////////// 
.................... ///                  /// 
.................... /// Global Variables /// 
.................... ///                  /// 
.................... //////////////////////// 
....................  
.................... int16 
....................    Bytes_Per_Cluster,   // number of addressable bytes per cluster 
....................    FAT_Start;           // when the first FAT begins 
....................  
.................... int32 
....................    Data_Start,          // when data starts 
....................    FAT_Length,          // the length of one FAT 
....................    Next_Free_Clust,     // where the next free cluster is 
....................    Root_Dir;            // when the root directory starts 
....................  
.................... enum filetype 
.................... { 
....................    Data_File,  // the stream is pointing to a binary, data file 
....................    Directory,  // the stream is pointing to a directory 
....................    None        // the stream isn't currently pointing to anything 
.................... }; 
....................  
.................... enum ioflags 
.................... { 
....................    Closed = 0x00, 
....................    Read = 0x01, 
....................    Write = 0x02, 
....................    Append = 0x04, 
....................    Binary = 0x08, 
....................    EOF_Reached = 0x10, 
....................    Read_Error = 0x20, 
....................    Write_Error = 0x40, 
....................    File_Not_Found = 0x80 
.................... }; 
....................  
.................... struct iobuf 
.................... { 
....................    fatpos_t 
....................       Bytes_Until_EOF,     // how many bytes until the stream's end of file 
....................       Cur_Char,            // the current byte that the stream is pointing at 
....................       Entry_Addr,          // the entry address of the file that is associated with the stream 
....................       Parent_Start_Addr,   // the parent's start adddress of the file that is associated with the stream 
....................       Size,                // the size of the file that is associated with the stream 
....................       Start_Addr;          // the beginning of the data in the file that is associated with the stream 
....................  
....................    enum filetype File_Type;   // the type of file that is associated with the stream 
....................  
....................    enum ioflags Flags;        // any associated input/output flag 
....................  
....................    int Buf[STREAM_BUF_SIZE];  // this is a buffer so that during fatputc() or fatgetc() 
....................                               //  the media won't have to be read at every character 
.................... }; 
.................... typedef struct iobuf FILE; 
....................  
.................... /////////////////////////// 
.................... ///                     /// 
.................... /// Function Prototypes /// 
.................... ///                     /// 
.................... /////////////////////////// 
....................  
.................... /// Standard C Functions /// 
.................... signed int fatopen(char fname[], char mode[], FILE* stream); 
.................... signed int fatreopen(char fname[], char mode[], FILE* stream); 
.................... signed int fatclose(FILE* stream); 
.................... signed int fatgetc(FILE* stream); 
.................... signed int fatputc(int ch, FILE* stream); 
.................... char* fatgets(char* str, int num, FILE* stream); 
.................... signed int fatputs(char* str, FILE* stream); 
.................... signed int fatprintf(FILE* stream); 
.................... signed int fatgetpos(FILE* stream, fatpos_t* position); 
.................... signed int fatsetpos(FILE* stream, fatpos_t* position); 
.................... signed int fatseek(FILE* stream, int32 offset, int origin); 
.................... signed int fateof(FILE* stream); 
.................... signed int faterror(FILE* stream); 
.................... signed int fatread(void* buffer, int size, int32 num, FILE* stream); 
.................... signed int fatwrite(void* buffer, int size, int32 count, FILE* stream ); 
.................... signed int fatflush(FILE* stream); 
.................... signed int remove(char* fname); 
.................... void clearerr(FILE* stream); 
.................... void rewind(FILE* stream); 
.................... fatpos_t fattell(FILE* stream); 
....................  
.................... /// Non-Standard C Functions /// 
.................... signed int rm_file(char fname[]); 
.................... signed int rm_dir(char dname[]); 
.................... signed int mk_file(char fname[]); 
.................... signed int mk_dir(char dname[]); 
....................  
.................... /// Functions' Utility Functions /// 
.................... signed int set_file(char fname[], int attrib, FILE* stream); 
.................... signed int get_file_name(int32 file_entry_addr, char name[]); 
.................... signed int set_file_name(int32 parent_dir_addr, int32* entry_addr, char name[]); 
.................... signed int get_short_file_name(int32 file_entry_addr, char sname[], int type); 
.................... signed int make_short_file_name(int32 parent_dir_addr, char fname[], char sname[]); 
.................... int long_name_chksum (int* pFcbName); 
.................... signed int check_invalid_char(char fname[]); 
.................... #ifdef FAT32 
.................... signed int get_next_free_cluster(int32* my_cluster); 
.................... signed int dealloc_clusters(int32 start_cluster); 
.................... signed int alloc_clusters(int32 start_cluster, int32* new_cluster_addr); 
.................... signed int clear_cluster(int32 cluster); 
.................... signed int write_fat(int32 cluster, int32 data); 
.................... #else // FAT16 
.................... signed int get_next_free_cluster(int16* my_cluster); 
.................... signed int dealloc_clusters(int16 start_cluster); 
.................... signed int alloc_clusters(int16 start_cluster, int32* new_cluster_addr); 
.................... signed int clear_cluster(int16 cluster); 
.................... signed int write_fat(int16 cluster, int16 data); 
.................... #endif // #ifdef FAT32 
.................... signed int get_next_file(FILE* stream); 
.................... signed int get_prev_file(FILE* stream); 
.................... signed int get_next_free_addr(int32* my_addr); 
.................... signed int get_next_free_entry(int32* start_addr); 
.................... signed int get_next_entry(int32* start_addr); 
.................... signed int get_prev_entry(int32* start_addr); 
.................... signed int read_buffer(FILE* stream, int* val); 
.................... signed int write_buffer(FILE* stream, int val); 
.................... void fill_entry(char the_entry[], char val, int8 start_ind); 
.................... void disp_timestamp(int16 timestamp); 
.................... void disp_datestamp(int16 datestamp); 
....................  
.................... /// Data Utility Functions /// 
.................... signed int fat_init(); 
.................... #ifdef FAT32 
.................... signed int get_next_cluster(int32* my_cluster); 
.................... signed int get_prev_cluster(int32* my_cluster); 
.................... int32 cluster_to_addr(int32 cluster); 
.................... int32 addr_to_cluster(int32 addr); 
.................... #else // FAT16 
.................... signed int get_next_cluster(int16* my_cluster); 
.................... signed int get_prev_cluster(int16* my_cluster); 
.................... int32 cluster_to_addr(int16 cluster); 
.................... int16 addr_to_cluster(int32 addr); 
.................... #endif // #ifdef FAT32 
.................... signed int get_next_addr(int32* my_addr); 
.................... signed int get_prev_addr(int32* my_addr); 
.................... signed int format(int32 DskSize); 
....................  
.................... /// Debugging Utility Functions /// 
.................... signed int disp_folder_contents(char foldername[]); 
.................... signed int dump_addr(int32 from, int32 to); 
.................... signed int dump_clusters(int32 from, int32 to); 
.................... void disp_fat_stats(); 
.................... signed int fatprintfinfo(FILE* stream); 
....................  
.................... //////////////////////////////// 
.................... ///                          /// 
.................... /// Function Implementations /// 
.................... ///                          /// 
.................... //////////////////////////////// 
....................  
.................... /// Standard C Functions /// 
....................  
.................... /* 
.................... signed int fatopen(char fname[], char mode[], FILE* stream) 
.................... Summary: This will open up a file stream for reading, writing, or appending. 
.................... Param fname: The full path of the file to open. 
.................... Param mode: The mode to open up the stream into. 
....................              "r" = Read 
....................              "w" = Write 
....................              "a" = Append 
....................              "rb", "wb", "ab" = Read, Write, or Append in Binary mode 
.................... Param stream: The stream to open up. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... Note: Standard C will make a file in case a file isn't found, 
....................        however due to recursion this is not possible in CCSC. 
.................... */ 
.................... signed int fatopen(char fname[], char mode[], FILE* stream) 
*
04F76:  MOVLW  01
04F78:  MOVLB  5
04F7A:  MOVWF  x37
04F7C:  CLRF   x92
.................... { 
....................    int fname_parse_pos = 1;    // the current index of the fname character 
....................  
....................    char target_file[MAX_FILE_NAME_LENGTH];   // temporary buffer to hold names of files 
....................  
....................    FILE cur_stream;     // this will   be the stream that will be returned if all goes well 
....................  
.................... #ifndef FAST_FAT 
....................    int 
....................       depth = 0,              // how many subdirectories deep the file is 
....................       target_file_parse_pos;  // the current index of the target_file character 
.................... #endif // #ifndef FAST_FAT 
....................  
....................    // set flags 
.................... #ifdef FAST_FAT 
....................    switch(mode[0]) 
....................    { 
....................       case 'w': 
....................          cur_stream.Flags = Write; 
....................          break; 
....................       case 'a': 
....................          cur_stream.Flags = Append; 
....................          break; 
....................       default: 
....................          return EOF; 
....................    } 
....................  
....................    // start looking for the file, start at root 
....................    cur_stream.Start_Addr = cur_stream.Parent_Start_Addr = Root_Dir; 
....................  
....................    while(fname[fname_parse_pos] != '\0') 
....................    { 
....................       target_file[fname_parse_pos - 1] = fname[fname_parse_pos]; 
....................       fname_parse_pos += 1; 
....................    } 
....................  
....................    target_file[fname_parse_pos] = '\0'; 
....................  
....................    // find the file inside of its subdirectory 
....................    if(set_file(target_file, 0x20, &cur_stream) != GOODEC) 
....................    { 
....................       cur_stream.Flags |= File_Not_Found; 
....................       *stream = cur_stream; 
....................       return EOF; 
....................    } 
....................  
....................    // at this point, we've found the file 
....................    *stream = cur_stream; 
....................    return GOODEC; 
.................... #else // NO FAST_FAT 
....................    switch(mode[0]) 
04F7E:  MOVF   x33,W
04F80:  MOVWF  FE9
04F82:  MOVF   x34,W
04F84:  MOVWF  FEA
04F86:  MOVF   FEF,W
04F88:  XORLW  72
04F8A:  MOVLB  0
04F8C:  BZ    4F98
04F8E:  XORLW  05
04F90:  BZ    4FA0
04F92:  XORLW  16
04F94:  BZ    4FA8
04F96:  BRA    4FB2
....................    { 
....................       case 'r': 
....................          cur_stream.Flags = Read; 
04F98:  MOVLW  01
04F9A:  MOVLB  5
04F9C:  MOVWF  x71
....................          break; 
04F9E:  BRA    4FBA
....................       case 'w': 
....................          cur_stream.Flags = Write; 
04FA0:  MOVLW  02
04FA2:  MOVLB  5
04FA4:  MOVWF  x71
....................          break; 
04FA6:  BRA    4FBA
....................       case 'a': 
....................          cur_stream.Flags = Append; 
04FA8:  MOVLW  04
04FAA:  MOVLB  5
04FAC:  MOVWF  x71
....................          break; 
04FAE:  BRA    4FBA
04FB0:  MOVLB  0
....................       default: 
....................          return EOF; 
04FB2:  MOVLW  FF
04FB4:  MOVWF  01
04FB6:  BRA    51F8
04FB8:  MOVLB  5
....................    } 
....................  
....................    if(mode[1] == 'b') 
04FBA:  MOVLW  01
04FBC:  ADDWF  x33,W
04FBE:  MOVWF  FE9
04FC0:  MOVLW  00
04FC2:  ADDWFC x34,W
04FC4:  MOVWF  FEA
04FC6:  MOVF   FEF,W
04FC8:  SUBLW  62
04FCA:  BNZ   4FCE
....................       cur_stream.Flags |= Binary; 
04FCC:  BSF    x71.3
....................  
....................    // start looking for the file, start at root 
....................    cur_stream.Start_Addr = cur_stream.Parent_Start_Addr = Root_Dir; 
04FCE:  MOVFF  3A8,567
04FD2:  MOVFF  3A7,566
04FD6:  MOVFF  3A6,565
04FDA:  MOVFF  3A5,564
04FDE:  MOVFF  567,56F
04FE2:  MOVFF  566,56E
04FE6:  MOVFF  565,56D
04FEA:  MOVFF  564,56C
....................  
....................    // figure out how deep we have to go, count how many '/' we have in the string 
....................    while(fname[fname_parse_pos] != '\0') 
04FEE:  CLRF   03
04FF0:  MOVF   x37,W
04FF2:  ADDWF  x31,W
04FF4:  MOVWF  FE9
04FF6:  MOVF   x32,W
04FF8:  ADDWFC 03,W
04FFA:  MOVWF  FEA
04FFC:  MOVF   FEF,F
04FFE:  BZ    501C
....................    { 
....................       if(fname[fname_parse_pos] == '/') 
05000:  CLRF   03
05002:  MOVF   x37,W
05004:  ADDWF  x31,W
05006:  MOVWF  FE9
05008:  MOVF   x32,W
0500A:  ADDWFC 03,W
0500C:  MOVWF  FEA
0500E:  MOVF   FEF,W
05010:  SUBLW  2F
05012:  BNZ   5016
....................          depth++; 
05014:  INCF   x92,F
....................       fname_parse_pos += 1; 
05016:  MOVLW  01
05018:  ADDWF  x37,F
0501A:  BRA    4FEE
....................    } 
....................  
....................    // start the fname index at 1 to skip over the '/' 
....................    fname_parse_pos = 1; 
0501C:  MOVLW  01
0501E:  MOVWF  x37
....................  
....................    // open up to the subdirectory, if possible 
....................    while(depth > 0) 
05020:  MOVF   x92,F
05022:  BZ    50F2
....................    { 
....................       // find the name of our next target directory 
....................       target_file_parse_pos = 0; 
05024:  CLRF   x93
....................       while(fname[fname_parse_pos] != '/') 
05026:  CLRF   03
05028:  MOVF   x37,W
0502A:  ADDWF  x31,W
0502C:  MOVWF  FE9
0502E:  MOVF   x32,W
05030:  ADDWFC 03,W
05032:  MOVWF  FEA
05034:  MOVF   FEF,W
05036:  SUBLW  2F
05038:  BZ    508C
....................       { 
....................          // check to make sure that we're not at the end of a poorly formatted string 
....................          if(fname[fname_parse_pos] == '\0') 
0503A:  CLRF   03
0503C:  MOVF   x37,W
0503E:  ADDWF  x31,W
05040:  MOVWF  FE9
05042:  MOVF   x32,W
05044:  ADDWFC 03,W
05046:  MOVWF  FEA
05048:  MOVF   FEF,F
0504A:  BNZ   5056
....................             return EOF; 
0504C:  MOVLW  FF
0504E:  MOVWF  01
05050:  MOVLB  0
05052:  BRA    51F8
05054:  MOVLB  5
....................  
....................          // fill up the buffer and increment the indexes 
....................          target_file[target_file_parse_pos] = fname[fname_parse_pos]; 
05056:  CLRF   03
05058:  MOVF   x93,W
0505A:  ADDLW  38
0505C:  MOVWF  01
0505E:  MOVLW  05
05060:  ADDWFC 03,F
05062:  MOVFF  03,595
05066:  CLRF   03
05068:  MOVF   x37,W
0506A:  ADDWF  x31,W
0506C:  MOVWF  FE9
0506E:  MOVF   x32,W
05070:  ADDWFC 03,W
05072:  MOVWF  FEA
05074:  MOVFF  FEF,596
05078:  MOVFF  595,FEA
0507C:  MOVFF  01,FE9
05080:  MOVFF  596,FEF
....................          fname_parse_pos += 1; 
05084:  MOVLW  01
05086:  ADDWF  x37,F
....................          target_file_parse_pos += 1; 
05088:  ADDWF  x93,F
0508A:  BRA    5026
....................       } 
....................  
....................       // increment the fname index one more because it's currently pointing at the '/' 
....................       fname_parse_pos += 1; 
0508C:  MOVLW  01
0508E:  ADDWF  x37,F
....................  
....................       // tack on a \0 to the end of the target file to terminate the string 
....................       target_file[target_file_parse_pos] = '\0'; 
05090:  CLRF   03
05092:  MOVF   x93,W
05094:  ADDLW  38
05096:  MOVWF  FE9
05098:  MOVLW  05
0509A:  ADDWFC 03,W
0509C:  MOVWF  FEA
0509E:  CLRF   FEF
....................  
....................       // check to see if the directory exists and open it if possible, otherwise exit because the directory doesn't exist 
....................       if(set_file(target_file, 0x10, &cur_stream) != GOODEC) 
050A0:  MOVLW  05
050A2:  MOVWF  x95
050A4:  MOVLW  38
050A6:  MOVWF  x94
050A8:  MOVLW  10
050AA:  MOVWF  x96
050AC:  MOVLW  05
050AE:  MOVWF  x98
050B0:  MOVLW  58
050B2:  MOVWF  x97
050B4:  MOVLB  0
050B6:  CALL   4852
050BA:  MOVF   01,F
050BC:  BZ    50EA
....................       { 
....................          cur_stream.Flags |= File_Not_Found; 
050BE:  MOVLB  5
050C0:  BSF    x71.7
....................          *stream = cur_stream; 
050C2:  MOVFF  536,03
050C6:  MOVFF  535,FE9
050CA:  MOVFF  536,FEA
050CE:  MOVLW  05
050D0:  MOVWF  FE2
050D2:  MOVLW  58
050D4:  MOVWF  FE1
050D6:  MOVLW  3A
050D8:  MOVWF  01
050DA:  MOVFF  FE6,FEE
050DE:  DECFSZ 01,F
050E0:  BRA    50DA
....................          return EOF; 
050E2:  MOVLW  FF
050E4:  MOVWF  01
050E6:  MOVLB  0
050E8:  BRA    51F8
....................       } 
....................       depth -= 1; 
050EA:  MOVLW  01
050EC:  MOVLB  5
050EE:  SUBWF  x92,F
050F0:  BRA    5020
....................    } 
....................  
....................    // check to see if we're trying to open just a directory 
....................    if(fname[fname_parse_pos] == '\0') 
050F2:  CLRF   03
050F4:  MOVF   x37,W
050F6:  ADDWF  x31,W
050F8:  MOVWF  FE9
050FA:  MOVF   x32,W
050FC:  ADDWFC 03,W
050FE:  MOVWF  FEA
05100:  MOVF   FEF,F
05102:  BNZ   512E
....................    { 
....................       *stream = cur_stream; 
05104:  MOVFF  536,03
05108:  MOVFF  535,FE9
0510C:  MOVFF  536,FEA
05110:  MOVLW  05
05112:  MOVWF  FE2
05114:  MOVLW  58
05116:  MOVWF  FE1
05118:  MOVLW  3A
0511A:  MOVWF  01
0511C:  MOVFF  FE6,FEE
05120:  DECFSZ 01,F
05122:  BRA    511C
....................       return GOODEC; 
05124:  MOVLW  00
05126:  MOVWF  01
05128:  MOVLB  0
0512A:  BRA    51F8
0512C:  MOVLB  5
....................    } 
....................  
....................    // now that we have the location of the subdirectory that the file is in, attempt to open the file 
....................    target_file_parse_pos = 0; 
0512E:  CLRF   x93
....................    while(fname[fname_parse_pos] != '\0') 
05130:  CLRF   03
05132:  MOVF   x37,W
05134:  ADDWF  x31,W
05136:  MOVWF  FE9
05138:  MOVF   x32,W
0513A:  ADDWFC 03,W
0513C:  MOVWF  FEA
0513E:  MOVF   FEF,F
05140:  BZ    5178
....................    { 
....................       // fill up the buffer and increment the indexes 
....................       target_file[target_file_parse_pos] = fname[fname_parse_pos]; 
05142:  CLRF   03
05144:  MOVF   x93,W
05146:  ADDLW  38
05148:  MOVWF  01
0514A:  MOVLW  05
0514C:  ADDWFC 03,F
0514E:  MOVFF  03,595
05152:  CLRF   03
05154:  MOVF   x37,W
05156:  ADDWF  x31,W
05158:  MOVWF  FE9
0515A:  MOVF   x32,W
0515C:  ADDWFC 03,W
0515E:  MOVWF  FEA
05160:  MOVFF  FEF,596
05164:  MOVFF  595,FEA
05168:  MOVFF  01,FE9
0516C:  MOVFF  596,FEF
....................       fname_parse_pos += 1; 
05170:  MOVLW  01
05172:  ADDWF  x37,F
....................       target_file_parse_pos += 1; 
05174:  ADDWF  x93,F
05176:  BRA    5130
....................    } 
....................  
....................    // tack on a \0 to the end of the target file to terminate the string 
....................    target_file[target_file_parse_pos] = '\0'; 
05178:  CLRF   03
0517A:  MOVF   x93,W
0517C:  ADDLW  38
0517E:  MOVWF  FE9
05180:  MOVLW  05
05182:  ADDWFC 03,W
05184:  MOVWF  FEA
05186:  CLRF   FEF
....................  
....................    // find the file inside of its subdirectory 
....................    if(set_file(target_file, 0x20, &cur_stream) != GOODEC) 
05188:  MOVLW  05
0518A:  MOVWF  x95
0518C:  MOVLW  38
0518E:  MOVWF  x94
05190:  MOVLW  20
05192:  MOVWF  x96
05194:  MOVLW  05
05196:  MOVWF  x98
05198:  MOVLW  58
0519A:  MOVWF  x97
0519C:  MOVLB  0
0519E:  CALL   4852
051A2:  MOVF   01,F
051A4:  BZ    51D2
....................    { 
....................       cur_stream.Flags |= File_Not_Found; 
051A6:  MOVLB  5
051A8:  BSF    x71.7
....................       *stream = cur_stream; 
051AA:  MOVFF  536,03
051AE:  MOVFF  535,FE9
051B2:  MOVFF  536,FEA
051B6:  MOVLW  05
051B8:  MOVWF  FE2
051BA:  MOVLW  58
051BC:  MOVWF  FE1
051BE:  MOVLW  3A
051C0:  MOVWF  01
051C2:  MOVFF  FE6,FEE
051C6:  DECFSZ 01,F
051C8:  BRA    51C2
....................       return EOF; 
051CA:  MOVLW  FF
051CC:  MOVWF  01
051CE:  MOVLB  0
051D0:  BRA    51F8
....................    } 
....................  
....................    // at this point, we've found the file 
....................    *stream = cur_stream; 
051D2:  MOVFF  536,03
051D6:  MOVLB  5
051D8:  MOVFF  535,FE9
051DC:  MOVFF  536,FEA
051E0:  MOVLW  05
051E2:  MOVWF  FE2
051E4:  MOVLW  58
051E6:  MOVWF  FE1
051E8:  MOVLW  3A
051EA:  MOVWF  01
051EC:  MOVFF  FE6,FEE
051F0:  DECFSZ 01,F
051F2:  BRA    51EC
....................    return GOODEC; 
051F4:  MOVLW  00
051F6:  MOVWF  01
051F8:  MOVLB  0
.................... #endif // #ifdef FAST_FAT 
051FA:  GOTO   5DE0 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int fatreopen(char fname[], char mode[], FILE* old_stream, FILE* new_stream) 
.................... Summary: This will close a stream and then reopen it using new parameters. 
.................... Param fname: The full path of the file to open. 
.................... Param mode: The mode to open up the stream into. 
....................              "r" = Read 
....................              "w" = Write 
....................              "a" = Append 
....................              "rb", "wb", "ab" = Read, Write, or Append in Binary mode 
.................... Param stream: The stream to close and reopen. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................          /Directory/filename.fil for a file in a subdirectory of root 
....................          /Directory/Subdirectory/filename.fil and so on... 
.................... Note: Standard C will make a file in case a file isn't found, 
....................        however due to recursion this is not possible in CCSC. 
.................... */ 
.................... signed int fatreopen(char fname[], char mode[], FILE* stream) 
.................... { 
....................    // close the old stream 
....................    if(fatclose(stream) == EOF) 
....................      return EOF; 
....................  
....................    // open the new stream 
....................    if(fatopen(fname, mode, stream) == EOF) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int fatclose(FILE* stream) 
.................... Summary: Closes a stream and commits any changes done to the file. 
.................... Param: The stream to close. 
.................... Returns: EOF if there was a problem, 0 if everything went okay. 
.................... */ 
.................... signed int fatclose(FILE* stream) 
.................... { 
....................    int ec = 0; 
....................  
....................    int32 first_cluster; 
....................  
....................    // commit data back to the stream's entry, if needed 
....................    if((stream->Flags & Write) || (stream->Flags & Append)) 
....................    {  
....................       // write the new size of the file 
....................       if(mmcsd_write_data(stream->Entry_Addr + 0x1C, 4, &(stream->Size)) != GOODEC) 
....................       { 
....................          stream->Flags |= Write_Error; 
....................          return EOF; 
....................       } 
....................  
....................       // check to see if the first cluster is already linked in the file 
....................       ec += mmcsd_read_data(stream->Entry_Addr + 0x14, 2, (int16*)&first_cluster + 1); 
....................       ec += mmcsd_read_data(stream->Entry_Addr + 0x1A, 2, &first_cluster); 
....................  
....................       if(ec != GOODEC) 
....................       { 
....................          stream->Flags |= Read_Error; 
....................          return EOF; 
....................       } 
....................  
....................       // write the first cluster to the entry if needed 
....................       if(first_cluster == 0) 
....................       { 
....................          // convert the start address to a cluster number 
....................          first_cluster = addr_to_cluster(stream->Start_Addr); 
....................  
....................          ec += mmcsd_write_data(stream->Entry_Addr + 0x14, 2, (int16*)&first_cluster + 1); 
....................          ec += mmcsd_write_data(stream->Entry_Addr + 0x1A, 2, &first_cluster); 
....................  
....................          if(ec != GOODEC) 
....................          { 
....................             stream->Flags |= Write_Error; 
....................             return EOF; 
....................          } 
....................       } 
....................        
....................       // dump the remaining buffer to the card 
....................       if(fatflush(stream) == EOF) 
....................          return EOF; 
....................    } 
....................    // nullify the data 
....................    stream->Cur_Char = 0; 
....................    stream->Entry_Addr = 0; 
....................    stream->Size = 0; 
....................    stream->Start_Addr = 0; 
....................    stream->Flags = 0; 
....................    return 0; 
.................... } 
....................  
.................... /* 
.................... signed int fatgetc(FILE* stream) 
.................... Summary: Gets a character from a stream. 
.................... Param: The stream to get a character from. 
.................... Returns: The character that was gotten from the stream, 
....................           EOF if the stream has reached the end of the file or doesn't have permissions to read, 
.................... */ 
.................... signed int fatgetc(FILE* stream) 
.................... { 
....................    char ch; // character read in 
....................  
....................    // check to see if the stream has proper permissions to read 
....................    if(stream->Flags & Read) 
....................    { 
....................       // when the number of bytes until eof hit zero, we know we are at the end of any file 
....................       if(stream->Bytes_Until_EOF == 0) 
....................       { 
....................          stream->Flags |= EOF_Reached; 
....................          return EOF; 
....................       } 
....................  
....................       // read in the next byte in the buffer 
....................       if(read_buffer(stream, &ch) == EOF) 
....................          return EOF; 
....................  
....................       // a 0x00 will signify the end of a non-binary file 
....................       if((ch == '\0') && !(stream->Flags & Binary)) 
....................       { 
....................          stream->Flags |= EOF_Reached; 
....................          return EOF; 
....................       } 
....................  
....................       // get the next contiguous address of the stream 
....................       if(get_next_addr(&(stream->Cur_Char)) != GOODEC) 
....................          return EOF; 
....................           
....................       // we just got 1 byte closer to the end of the file 
....................       stream->Bytes_Until_EOF -= 1; 
....................       return ch; 
....................    } 
....................  
....................    // if the stream doesn't have proper permissions to read, return an EOF 
....................    else 
....................       return EOF; 
.................... } 
....................  
.................... /* 
.................... signed int fatputc(int ch, FILE* stream) 
.................... Summary: Puts a character into a stream. 
.................... Param ch: The character to put into the stream. 
.................... Param stream: The stream to put a character into. 
.................... Returns: The character that was put into the stream, 
....................           EOF if the stream doesn't have permissions to write, or if a problem happened. 
.................... */ 
.................... signed int fatputc(int ch, FILE* stream) 
.................... { 
....................    // check to see if the stream has proper permissions to write 
....................    if(((stream->Flags & Write) || (stream->Flags & Append)) && (stream->File_Type == Data_File)) 
*
040C0:  MOVLW  19
040C2:  MOVLB  5
040C4:  ADDWF  xCF,W
040C6:  MOVWF  FE9
040C8:  MOVLW  00
040CA:  ADDWFC xD0,W
040CC:  MOVWF  FEA
040CE:  BTFSC  FEF.1
040D0:  BRA    40E2
040D2:  MOVLW  19
040D4:  ADDWF  xCF,W
040D6:  MOVWF  FE9
040D8:  MOVLW  00
040DA:  ADDWFC xD0,W
040DC:  MOVWF  FEA
040DE:  BTFSS  FEF.2
040E0:  BRA    43AE
040E2:  MOVLW  18
040E4:  ADDWF  xCF,W
040E6:  MOVWF  FE9
040E8:  MOVLW  00
040EA:  ADDWFC xD0,W
040EC:  MOVWF  FEA
040EE:  MOVF   FEF,F
040F0:  BTFSS  FD8.2
040F2:  BRA    43AE
....................    { 
....................       // if there isn't any space allocated yet, allocate some 
....................       if(stream->Cur_Char < Data_Start) 
040F4:  MOVLW  04
040F6:  ADDWF  xCF,W
040F8:  MOVWF  FE9
040FA:  MOVLW  00
040FC:  ADDWFC xD0,W
040FE:  MOVWF  FEA
04100:  MOVFF  FEF,5D1
04104:  MOVFF  FEC,5D2
04108:  MOVFF  FEC,5D3
0410C:  MOVFF  FEC,5D4
04110:  MOVF   xD4,W
04112:  MOVLB  3
04114:  SUBWF  x9C,W
04116:  BTFSS  FD8.0
04118:  BRA    421C
0411A:  BNZ   4148
0411C:  MOVLB  5
0411E:  MOVF   xD3,W
04120:  MOVLB  3
04122:  SUBWF  x9B,W
04124:  BTFSS  FD8.0
04126:  BRA    421C
04128:  BNZ   4148
0412A:  MOVLB  5
0412C:  MOVF   xD2,W
0412E:  MOVLB  3
04130:  SUBWF  x9A,W
04132:  BTFSS  FD8.0
04134:  BRA    421C
04136:  BNZ   4148
04138:  MOVF   x99,W
0413A:  MOVLB  5
0413C:  SUBWF  xD1,W
0413E:  BTFSS  FD8.0
04140:  BRA    4146
04142:  MOVLB  3
04144:  BRA    421C
04146:  MOVLB  3
....................       { 
....................          if(get_next_free_cluster(&Next_Free_Clust) == EOF) 
04148:  MOVLW  03
0414A:  MOVLB  5
0414C:  MOVWF  xE6
0414E:  MOVLW  A1
04150:  MOVWF  xE5
04152:  MOVLB  0
04154:  RCALL  3A9A
04156:  MOVF   01,W
04158:  SUBLW  FF
0415A:  BNZ   4162
....................             return EOF; 
0415C:  MOVLW  FF
0415E:  MOVWF  01
04160:  BRA    43B4
.................... #ifdef FAT32 
....................          if(write_fat(Next_Free_Clust, 0x0FFFFFFF) == EOF) 
04162:  MOVFF  3A4,5E8
04166:  MOVFF  3A3,5E7
0416A:  MOVFF  3A2,5E6
0416E:  MOVFF  3A1,5E5
04172:  MOVLW  0F
04174:  MOVLB  5
04176:  MOVWF  xEC
04178:  SETF   xEB
0417A:  SETF   xEA
0417C:  SETF   xE9
0417E:  MOVLB  0
04180:  CALL   3906
04184:  MOVF   01,W
04186:  SUBLW  FF
04188:  BNZ   4190
....................             return EOF; 
0418A:  MOVLW  FF
0418C:  MOVWF  01
0418E:  BRA    43B4
.................... #else // FAT16 
....................          if(write_fat(Next_Free_Clust, 0xFFFF) == EOF) 
....................             return EOF; 
.................... #endif // #ifdef FAT32 
....................          if(clear_cluster(Next_Free_Clust) == EOF) 
04190:  MOVFF  3A4,5E8
04194:  MOVFF  3A3,5E7
04198:  MOVFF  3A2,5E6
0419C:  MOVFF  3A1,5E5
041A0:  RCALL  3C1C
041A2:  MOVF   01,W
041A4:  SUBLW  FF
041A6:  BNZ   41AE
....................             return EOF; 
041A8:  MOVLW  FF
041AA:  MOVWF  01
041AC:  BRA    43B4
....................          stream->Cur_Char = stream->Start_Addr = cluster_to_addr(Next_Free_Clust); 
041AE:  MOVLW  04
041B0:  MOVLB  5
041B2:  ADDWF  xCF,W
041B4:  MOVWF  01
041B6:  MOVLW  00
041B8:  ADDWFC xD0,W
041BA:  MOVWF  03
041BC:  MOVFF  01,5D1
041C0:  MOVWF  xD2
041C2:  MOVLW  14
041C4:  ADDWF  xCF,W
041C6:  MOVWF  01
041C8:  MOVLW  00
041CA:  ADDWFC xD0,W
041CC:  MOVWF  03
041CE:  MOVFF  01,5D3
041D2:  MOVWF  xD4
041D4:  MOVFF  3A4,613
041D8:  MOVFF  3A3,612
041DC:  MOVFF  3A2,611
041E0:  MOVFF  3A1,610
041E4:  MOVLB  0
041E6:  CALL   32FA
041EA:  MOVFF  5D4,FEA
041EE:  MOVFF  5D3,FE9
041F2:  MOVFF  00,FEF
041F6:  MOVFF  01,FEC
041FA:  MOVFF  02,FEC
041FE:  MOVFF  03,FEC
04202:  MOVFF  5D2,FEA
04206:  MOVFF  5D1,FE9
0420A:  MOVFF  00,FEF
0420E:  MOVFF  01,FEC
04212:  MOVFF  02,FEC
04216:  MOVFF  03,FEC
0421A:  MOVLB  3
....................       } 
....................  
....................       // write the next character to the buffer 
....................       if(write_buffer(stream, ch) == EOF) 
0421C:  MOVFF  5D0,5D2
04220:  MOVFF  5CF,5D1
04224:  MOVFF  5CE,5D3
04228:  MOVLB  0
0422A:  BRA    3CD8
0422C:  MOVF   01,W
0422E:  SUBLW  FF
04230:  BNZ   4238
....................          return EOF; 
04232:  MOVLW  FF
04234:  MOVWF  01
04236:  BRA    43B4
....................  
....................       // get the next address, increment Cur_Char 
....................       if(get_next_addr(&(stream->Cur_Char)) == EOF) 
04238:  MOVLW  04
0423A:  MOVLB  5
0423C:  ADDWF  xCF,W
0423E:  MOVWF  01
04240:  MOVLW  00
04242:  ADDWFC xD0,W
04244:  MOVWF  03
04246:  MOVFF  01,5D1
0424A:  MOVWF  xD2
0424C:  MOVWF  xD4
0424E:  MOVFF  01,5D3
04252:  MOVLB  0
04254:  RCALL  3E2E
04256:  MOVF   01,W
04258:  SUBLW  FF
0425A:  BTFSS  FD8.2
0425C:  BRA    436A
....................       { 
....................          // write the current buffer to the end of the current cluster 
....................          if(mmcsd_write_data(stream->Cur_Char - STREAM_BUF_SIZE + 1, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
0425E:  MOVLW  04
04260:  MOVLB  5
04262:  ADDWF  xCF,W
04264:  MOVWF  FE9
04266:  MOVLW  00
04268:  ADDWFC xD0,W
0426A:  MOVWF  FEA
0426C:  MOVFF  FEF,5D1
04270:  MOVFF  FEC,5D2
04274:  MOVFF  FEC,5D3
04278:  MOVFF  FEC,5D4
0427C:  MOVLW  20
0427E:  SUBWF  xD1,F
04280:  MOVLW  00
04282:  SUBWFB xD2,F
04284:  SUBWFB xD3,F
04286:  SUBWFB xD4,F
04288:  MOVLW  01
0428A:  ADDWF  xD1,F
0428C:  MOVLW  00
0428E:  ADDWFC xD2,F
04290:  ADDWFC xD3,F
04292:  ADDWFC xD4,F
04294:  MOVLW  1A
04296:  ADDWF  xCF,W
04298:  MOVWF  01
0429A:  MOVLW  00
0429C:  ADDWFC xD0,W
0429E:  MOVWF  03
042A0:  MOVFF  01,5D5
042A4:  MOVWF  xD6
042A6:  MOVFF  5D4,617
042AA:  MOVFF  5D3,616
042AE:  MOVFF  5D2,615
042B2:  MOVFF  5D1,614
042B6:  MOVLB  6
042B8:  CLRF   x19
042BA:  MOVLW  20
042BC:  MOVWF  x18
042BE:  MOVFF  03,61B
042C2:  MOVFF  01,61A
042C6:  MOVLB  0
042C8:  CALL   3874
042CC:  MOVF   01,F
042CE:  BZ    42EC
....................          { 
....................             stream->Flags |= Write_Error; 
042D0:  MOVLW  19
042D2:  MOVLB  5
042D4:  ADDWF  xCF,W
042D6:  MOVWF  FE9
042D8:  MOVLW  00
042DA:  ADDWFC xD0,W
042DC:  MOVWF  FEA
042DE:  MOVF   FEF,W
042E0:  IORLW  40
042E2:  MOVWF  FEF
....................             return EOF; 
042E4:  MOVLW  FF
042E6:  MOVWF  01
042E8:  MOVLB  0
042EA:  BRA    43B4
....................          } 
....................          // start looking for a new cluster to allocate 
....................          if(alloc_clusters(addr_to_cluster(stream->Cur_Char), &(stream->Cur_Char)) == EOF) 
042EC:  MOVLW  04
042EE:  MOVLB  5
042F0:  ADDWF  xCF,W
042F2:  MOVWF  FE9
042F4:  MOVLW  00
042F6:  ADDWFC xD0,W
042F8:  MOVWF  FEA
042FA:  MOVFF  FEF,5D1
042FE:  MOVFF  FEC,5D2
04302:  MOVFF  FEC,5D3
04306:  MOVFF  FEC,5D4
0430A:  MOVFF  5D4,5E1
0430E:  MOVFF  5D3,5E0
04312:  MOVFF  5D2,5DF
04316:  MOVFF  5D1,5DE
0431A:  MOVLB  0
0431C:  CALL   31AA
04320:  MOVFF  03,5D4
04324:  MOVFF  02,5D3
04328:  MOVFF  01,5D2
0432C:  MOVFF  00,5D1
04330:  MOVLW  04
04332:  MOVLB  5
04334:  ADDWF  xCF,W
04336:  MOVWF  01
04338:  MOVLW  00
0433A:  ADDWFC xD0,W
0433C:  MOVWF  03
0433E:  MOVFF  01,5D5
04342:  MOVWF  xD6
04344:  MOVFF  5D4,5DA
04348:  MOVFF  02,5D9
0434C:  MOVFF  5D2,5D8
04350:  MOVFF  00,5D7
04354:  MOVWF  xDC
04356:  MOVFF  01,5DB
0435A:  MOVLB  0
0435C:  RCALL  3FCE
0435E:  MOVF   01,W
04360:  SUBLW  FF
04362:  BNZ   436A
....................             return EOF; 
04364:  MOVLW  FF
04366:  MOVWF  01
04368:  BRA    43B4
....................       } 
....................  
....................       // our file just got bigger by 1 byte 
....................       stream->Size += 1; 
0436A:  MOVLW  10
0436C:  MOVLB  5
0436E:  ADDWF  xCF,W
04370:  MOVWF  FE9
04372:  MOVLW  00
04374:  ADDWFC xD0,W
04376:  MOVWF  FEA
04378:  MOVLW  01
0437A:  ADDWF  FEF,W
0437C:  MOVWF  00
0437E:  MOVLW  00
04380:  ADDWFC FEC,W
04382:  MOVWF  01
04384:  MOVLW  00
04386:  ADDWFC FEC,W
04388:  MOVWF  02
0438A:  MOVLW  00
0438C:  ADDWFC FEC,W
0438E:  MOVF   FED,F
04390:  MOVF   FED,F
04392:  MOVF   FED,F
04394:  MOVFF  00,FEF
04398:  MOVFF  01,FEC
0439C:  MOVFF  02,FEC
043A0:  MOVWF  FEC
....................  
....................       return ch; 
043A2:  MOVFF  5CE,01
043A6:  MOVLB  0
043A8:  BRA    43B4
....................    } 
043AA:  BRA    43B4
043AC:  MOVLB  5
....................  
....................    // if the stream doesn't have proper permissions to write, return an EOF 
....................    else 
....................       return EOF; 
043AE:  MOVLW  FF
043B0:  MOVWF  01
043B2:  MOVLB  0
043B4:  GOTO   44CE (RETURN)
.................... } 
....................  
.................... /* 
.................... char* fatgets(char* str, int num, FILE* stream) 
.................... Summary: Reads characters from a stream into a string. 
.................... Param str: A pointer to the beginning of the string to put characters into. 
.................... Param num: The number of characters to put into the string - 1. 
.................... Param stream: The stream to read from. 
.................... Returns: A pointer to the most recently added character, or NULL if there was an error. 
.................... Note: If a newline is read from the stream, then str will be terminated with a newline. 
....................        If num - 1 or EOF is reached, then str will be null terminated. 
.................... */ 
.................... char* fatgets(char* str, int num, FILE* stream) 
.................... { 
....................    int i;   // counter for loops 
....................  
....................    // loop until num - 1 
....................    for(i = 0; i < num - 1; i += 1) 
....................    { 
....................       str[i] = fatgetc(stream); 
....................       if(str[i] == '\n') 
....................          return str; 
....................       if(str[i] == EOF) 
....................          break; 
....................    } 
....................  
....................    // close off str with a null terminator 
....................    str[i] = '\0'; 
....................  
....................    return str; 
.................... } 
....................  
.................... /* 
.................... signed int fatputs(char* str, FILE* stream) 
.................... Summary: Writes characters from a string into a stream. 
.................... Param str: A pointer to the beginning of the string to write into the stream. 
.................... Param stream: The stream to write into. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int fatputs(char* str, FILE* stream) 
.................... { 
....................    int i = 0;   // counter for loops 
....................  
....................    // fatputc every character in the stream 
....................    while(str[i] != '\0') 
....................    { 
....................       if(fatputc(str[i], stream) == EOF) 
....................         return EOF; 
....................       i += 1; 
....................    } 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int fatprintf(FILE* stream) 
.................... Summary: This will print off the entire contents of the stream to the console. 
.................... Param: The stream to print off. 
.................... Returns: The last character printed off to the console. 
.................... */ 
.................... signed int fatprintf(FILE* stream) 
.................... { 
....................    signed int ch; // character read in 
....................  
....................    // keep on printf any characters read in as long as we don't run into an end of file or a media error 
....................    do 
....................    { 
....................       ch = fatgetc(stream); 
....................       printf("%c", ch); 
....................    } while(ch != EOF); 
....................  
....................    return ch; 
.................... } 
....................  
.................... /* 
.................... signed int fatgetpos(FILE* stream, fatpos_t* position) 
.................... Summary: Returns the current position of where the stream is pointing to relative to the beginning of the stream. 
.................... Param stream: The stream to get the position of. 
.................... Param position: A pointer to a variable put the current position of the pointer into. 
.................... Returns: 0 on success. 
.................... */ 
.................... signed int fatgetpos(FILE* stream, fatpos_t* position) 
.................... { 
....................    *position = stream->Size - stream->Bytes_Until_EOF; 
....................    return 0; 
.................... } 
....................  
.................... /* 
.................... signed int fatsetpos(FILE* stream, fatpos_t* position) 
.................... Summary: Sets the current position of where the stream is pointing to in memory relative to the beginning of the stream. 
.................... Param stream: The stream to set the position of. 
.................... Param position: A pointer the a variable that has the value of the new position. 
.................... Returns: 0 on success, or EOF if there was error. 
.................... */ 
.................... signed int fatsetpos(FILE* stream, fatpos_t* position) 
.................... { 
.................... #ifndef FAST_FAT 
.................... #ifdef FAT32 
....................    int32 cur_cluster; // the current cluster we're pointing to 
.................... #else // FAT16 
....................    int16 cur_cluster; // the current cluster we're pointing to 
.................... #endif // #ifdef FAT32 
....................    int32 i;    // pointer to memory 
.................... #endif // #ifndef FAST_FAT 
....................  
....................    // check to see if we want to just rewind the file 
....................    if(*position == 0) 
043B8:  MOVFF  5C5,03
043BC:  MOVLB  5
043BE:  MOVFF  5C4,FE9
043C2:  MOVFF  5C5,FEA
043C6:  MOVFF  FEF,5CE
043CA:  MOVFF  FEC,5CF
043CE:  MOVFF  FEC,5D0
043D2:  MOVFF  FEC,5D1
043D6:  MOVF   xCE,F
043D8:  BNZ   43FC
043DA:  MOVF   xCF,F
043DC:  BNZ   43FC
043DE:  MOVF   xD0,F
043E0:  BNZ   43FC
043E2:  MOVF   xD1,F
043E4:  BNZ   43FC
....................    { 
....................       rewind(stream); 
043E6:  MOVFF  5C3,5CF
043EA:  MOVFF  5C2,5CE
043EE:  MOVLB  0
043F0:  GOTO   3A18
....................       return GOODEC; 
043F4:  MOVLW  00
043F6:  MOVWF  01
043F8:  BRA    47EC
043FA:  MOVLB  5
....................    } 
....................     
....................    // this whole process is much different and easier if we're writing or appending at a spot after EOF 
....................    //  this will essentially write null characters to the file from EOF to the desired position 
....................    if(((stream->Flags & Write) || (stream->Flags & Append)) && (stream->Size < *position)) 
043FC:  MOVLW  19
043FE:  ADDWF  xC2,W
04400:  MOVWF  FE9
04402:  MOVLW  00
04404:  ADDWFC xC3,W
04406:  MOVWF  FEA
04408:  BTFSC  FEF.1
0440A:  BRA    441C
0440C:  MOVLW  19
0440E:  ADDWF  xC2,W
04410:  MOVWF  FE9
04412:  MOVLW  00
04414:  ADDWFC xC3,W
04416:  MOVWF  FEA
04418:  BTFSS  FEF.2
0441A:  BRA    44E8
0441C:  MOVLW  10
0441E:  ADDWF  xC2,W
04420:  MOVWF  FE9
04422:  MOVLW  00
04424:  ADDWFC xC3,W
04426:  MOVWF  FEA
04428:  MOVFF  FEF,5CE
0442C:  MOVFF  FEC,5CF
04430:  MOVFF  FEC,5D0
04434:  MOVFF  FEC,5D1
04438:  MOVFF  5C4,FE9
0443C:  MOVFF  5C5,FEA
04440:  MOVFF  FEF,00
04444:  MOVFF  FEC,01
04448:  MOVFF  FEC,02
0444C:  MOVFF  FEC,03
04450:  MOVF   xD1,W
04452:  SUBWF  03,W
04454:  BNC   44E8
04456:  BNZ   446E
04458:  MOVF   xD0,W
0445A:  SUBWF  02,W
0445C:  BNC   44E8
0445E:  BNZ   446E
04460:  MOVF   xCF,W
04462:  SUBWF  01,W
04464:  BNC   44E8
04466:  BNZ   446E
04468:  MOVF   00,W
0446A:  SUBWF  xCE,W
0446C:  BC    44E8
....................    { 
....................       while(stream->Size < *position) 
0446E:  MOVLW  10
04470:  ADDWF  xC2,W
04472:  MOVWF  FE9
04474:  MOVLW  00
04476:  ADDWFC xC3,W
04478:  MOVWF  FEA
0447A:  MOVFF  FEF,5CE
0447E:  MOVFF  FEC,5CF
04482:  MOVFF  FEC,5D0
04486:  MOVFF  FEC,5D1
0448A:  MOVFF  5C4,FE9
0448E:  MOVFF  5C5,FEA
04492:  MOVFF  FEF,00
04496:  MOVFF  FEC,01
0449A:  MOVFF  FEC,02
0449E:  MOVFF  FEC,03
044A2:  MOVF   xD1,W
044A4:  SUBWF  03,W
044A6:  BNC   44DE
044A8:  BNZ   44C0
044AA:  MOVF   xD0,W
044AC:  SUBWF  02,W
044AE:  BNC   44DE
044B0:  BNZ   44C0
044B2:  MOVF   xCF,W
044B4:  SUBWF  01,W
044B6:  BNC   44DE
044B8:  BNZ   44C0
044BA:  MOVF   00,W
044BC:  SUBWF  xCE,W
044BE:  BC    44DE
....................          if(fatputc('\0', stream) == EOF) 
044C0:  CLRF   xCE
044C2:  MOVFF  5C3,5D0
044C6:  MOVFF  5C2,5CF
044CA:  MOVLB  0
044CC:  BRA    40C0
044CE:  MOVF   01,W
044D0:  SUBLW  FF
044D2:  BNZ   44DA
....................             return EOF; 
044D4:  MOVLW  FF
044D6:  MOVWF  01
044D8:  BRA    47EC
044DA:  MOVLB  5
044DC:  BRA    446E
....................        
....................       return 0; 
044DE:  MOVLW  00
044E0:  MOVWF  01
044E2:  MOVLB  0
044E4:  BRA    47EC
044E6:  MOVLB  5
....................    } 
....................  
.................... #ifdef FAST_FAT 
....................    stream->Cur_Char = stream->Start_Addr + *position; 
.................... #else // NO FAST_FAT 
....................    // figure out how many clusters into the file the position is to be set to 
....................    i = *position / Bytes_Per_Cluster; 
044E8:  MOVFF  5C5,03
044EC:  MOVFF  5C4,FE9
044F0:  MOVFF  5C5,FEA
044F4:  MOVFF  FEF,5CE
044F8:  MOVFF  FEC,5CF
044FC:  MOVFF  FEC,5D0
04500:  MOVFF  FEC,5D1
04504:  MOVFF  FEA,5D3
04508:  MOVFF  FE9,5D2
0450C:  BCF    FD8.1
0450E:  MOVFF  5D1,5E9
04512:  MOVFF  5D0,5E8
04516:  MOVFF  5CF,5E7
0451A:  MOVFF  5CE,5E6
0451E:  CLRF   xED
04520:  CLRF   xEC
04522:  MOVFF  396,5EB
04526:  MOVFF  395,5EA
0452A:  MOVLB  0
0452C:  CALL   3116
04530:  MOVFF  5D3,FEA
04534:  MOVFF  5D2,FE9
04538:  MOVFF  03,5CD
0453C:  MOVFF  02,5CC
04540:  MOVFF  01,5CB
04544:  MOVFF  00,5CA
....................    cur_cluster = addr_to_cluster(stream->Start_Addr); 
04548:  MOVLW  14
0454A:  MOVLB  5
0454C:  ADDWF  xC2,W
0454E:  MOVWF  FE9
04550:  MOVLW  00
04552:  ADDWFC xC3,W
04554:  MOVWF  FEA
04556:  MOVFF  FEF,5CE
0455A:  MOVFF  FEC,5CF
0455E:  MOVFF  FEC,5D0
04562:  MOVFF  FEC,5D1
04566:  MOVFF  5D1,5E1
0456A:  MOVFF  5D0,5E0
0456E:  MOVFF  5CF,5DF
04572:  MOVFF  5CE,5DE
04576:  MOVLB  0
04578:  CALL   31AA
0457C:  MOVFF  03,5C9
04580:  MOVFF  02,5C8
04584:  MOVFF  01,5C7
04588:  MOVFF  00,5C6
....................  
....................    // head to that cluster 
....................    while(i > 0) 
0458C:  MOVLB  5
0458E:  MOVF   xCA,F
04590:  BNZ   459E
04592:  MOVF   xCB,F
04594:  BNZ   459E
04596:  MOVF   xCC,F
04598:  BNZ   459E
0459A:  MOVF   xCD,F
0459C:  BZ    45C6
....................    { 
....................       if(get_next_cluster(&cur_cluster) != GOODEC) 
0459E:  MOVLW  05
045A0:  MOVWF  xDA
045A2:  MOVLW  C6
045A4:  MOVWF  xD9
045A6:  MOVLB  0
045A8:  CALL   37A6
045AC:  MOVF   01,F
045AE:  BZ    45B6
....................          return EOF; 
045B0:  MOVLW  FF
045B2:  MOVWF  01
045B4:  BRA    47EC
....................       i -= 1; 
045B6:  MOVLW  01
045B8:  MOVLB  5
045BA:  SUBWF  xCA,F
045BC:  MOVLW  00
045BE:  SUBWFB xCB,F
045C0:  SUBWFB xCC,F
045C2:  SUBWFB xCD,F
045C4:  BRA    458E
....................    } 
....................  
....................    // head to the correct cluster 
....................    stream->Cur_Char = cluster_to_addr(cur_cluster); 
045C6:  MOVLW  04
045C8:  ADDWF  xC2,W
045CA:  MOVWF  01
045CC:  MOVLW  00
045CE:  ADDWFC xC3,W
045D0:  MOVWF  03
045D2:  MOVFF  01,5CE
045D6:  MOVWF  xCF
045D8:  MOVFF  5C9,613
045DC:  MOVFF  5C8,612
045E0:  MOVFF  5C7,611
045E4:  MOVFF  5C6,610
045E8:  MOVLB  0
045EA:  CALL   32FA
045EE:  MOVFF  5CF,FEA
045F2:  MOVFF  5CE,FE9
045F6:  MOVFF  00,FEF
045FA:  MOVFF  01,FEC
045FE:  MOVFF  02,FEC
04602:  MOVFF  03,FEC
....................  
....................    // now that we're in the correct cluster, tack on the remaining position 
....................    stream->Cur_Char += (*position % Bytes_Per_Cluster); 
04606:  MOVLW  04
04608:  MOVLB  5
0460A:  ADDWF  xC2,W
0460C:  MOVWF  01
0460E:  MOVLW  00
04610:  ADDWFC xC3,W
04612:  MOVFF  01,5CE
04616:  MOVWF  xCF
04618:  MOVWF  FEA
0461A:  MOVFF  01,FE9
0461E:  MOVFF  FEF,5D0
04622:  MOVFF  FEC,5D1
04626:  MOVFF  FEC,5D2
0462A:  MOVFF  FEC,5D3
0462E:  MOVFF  5C5,03
04632:  MOVFF  5C4,FE9
04636:  MOVFF  5C5,FEA
0463A:  MOVFF  FEF,5D4
0463E:  MOVFF  FEC,5D5
04642:  MOVFF  FEC,5D6
04646:  MOVFF  FEC,5D7
0464A:  MOVFF  FEA,5D9
0464E:  MOVFF  FE9,5D8
04652:  BSF    FD8.1
04654:  MOVLW  05
04656:  MOVWF  FEA
04658:  MOVLW  DA
0465A:  MOVWF  FE9
0465C:  MOVFF  5D7,5E9
04660:  MOVFF  5D6,5E8
04664:  MOVFF  5D5,5E7
04668:  MOVFF  5D4,5E6
0466C:  CLRF   xED
0466E:  CLRF   xEC
04670:  MOVFF  396,5EB
04674:  MOVFF  395,5EA
04678:  MOVLB  0
0467A:  CALL   3116
0467E:  MOVFF  5DA,00
04682:  MOVFF  5DB,01
04686:  MOVFF  5DC,02
0468A:  MOVFF  5DD,03
0468E:  MOVFF  5D9,FEA
04692:  MOVFF  5D8,FE9
04696:  MOVLB  5
04698:  MOVF   xD0,W
0469A:  ADDWF  00,F
0469C:  MOVF   xD1,W
0469E:  ADDWFC 01,F
046A0:  MOVF   xD2,W
046A2:  ADDWFC 02,F
046A4:  MOVF   xD3,W
046A6:  ADDWFC 03,F
046A8:  MOVFF  5CF,FEA
046AC:  MOVFF  5CE,FE9
046B0:  MOVFF  00,FEF
046B4:  MOVFF  01,FEC
046B8:  MOVFF  02,FEC
046BC:  MOVFF  03,FEC
....................  
....................    if(stream->Flags & Read) 
046C0:  MOVLW  19
046C2:  ADDWF  xC2,W
046C4:  MOVWF  FE9
046C6:  MOVLW  00
046C8:  ADDWFC xC3,W
046CA:  MOVWF  FEA
046CC:  BTFSS  FEF.0
046CE:  BRA    47AA
....................    { 
....................       // we now need to change how far it is until EOF 
....................       stream->Bytes_Until_EOF = stream->Size - *position; 
046D0:  MOVLW  10
046D2:  ADDWF  xC2,W
046D4:  MOVWF  FE9
046D6:  MOVLW  00
046D8:  ADDWFC xC3,W
046DA:  MOVWF  FEA
046DC:  MOVFF  FEF,5D0
046E0:  MOVFF  FEC,5D1
046E4:  MOVFF  FEC,5D2
046E8:  MOVFF  FEC,5D3
046EC:  MOVFF  5C4,FE9
046F0:  MOVFF  5C5,FEA
046F4:  MOVFF  FEF,00
046F8:  MOVFF  FEC,01
046FC:  MOVFF  FEC,02
04700:  MOVFF  FEC,03
04704:  MOVF   00,W
04706:  SUBWF  xD0,W
04708:  MOVWF  00
0470A:  MOVF   01,W
0470C:  SUBWFB xD1,W
0470E:  MOVWF  01
04710:  MOVF   02,W
04712:  SUBWFB xD2,W
04714:  MOVWF  02
04716:  MOVF   03,W
04718:  SUBWFB xD3,W
0471A:  MOVFF  5C3,FEA
0471E:  MOVFF  5C2,FE9
04722:  MOVFF  00,FEF
04726:  MOVFF  01,FEC
0472A:  MOVFF  02,FEC
0472E:  MOVWF  FEC
....................  
....................       // fill up the buffer 
....................       if(mmcsd_read_data(stream->Cur_Char, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
04730:  MOVLW  04
04732:  ADDWF  xC2,W
04734:  MOVWF  FE9
04736:  MOVLW  00
04738:  ADDWFC xC3,W
0473A:  MOVWF  FEA
0473C:  MOVFF  FEF,5CE
04740:  MOVFF  FEC,5CF
04744:  MOVFF  FEC,5D0
04748:  MOVFF  FEC,5D1
0474C:  MOVLW  1A
0474E:  ADDWF  xC2,W
04750:  MOVWF  01
04752:  MOVLW  00
04754:  ADDWFC xC3,W
04756:  MOVWF  03
04758:  MOVFF  01,5D2
0475C:  MOVWF  xD3
0475E:  MOVFF  5D1,5FE
04762:  MOVFF  5D0,5FD
04766:  MOVFF  5CF,5FC
0476A:  MOVFF  5CE,5FB
0476E:  MOVLB  6
04770:  CLRF   x00
04772:  MOVLW  20
04774:  MOVLB  5
04776:  MOVWF  xFF
04778:  MOVFF  03,602
0477C:  MOVFF  01,601
04780:  MOVLB  0
04782:  CALL   2B2E
04786:  MOVF   01,F
04788:  BZ    47A6
....................       { 
....................          stream->Flags |= Read_Error; 
0478A:  MOVLW  19
0478C:  MOVLB  5
0478E:  ADDWF  xC2,W
04790:  MOVWF  FE9
04792:  MOVLW  00
04794:  ADDWFC xC3,W
04796:  MOVWF  FEA
04798:  MOVF   FEF,W
0479A:  IORLW  20
0479C:  MOVWF  FEF
....................          return EOF; 
0479E:  MOVLW  FF
047A0:  MOVWF  01
047A2:  MOVLB  0
047A4:  BRA    47EC
....................       } 
....................    } 
047A6:  BRA    47E8
047A8:  MOVLB  5
....................  
....................    else 
....................       stream->Size = *position; 
047AA:  MOVLW  10
047AC:  ADDWF  xC2,W
047AE:  MOVWF  01
047B0:  MOVLW  00
047B2:  ADDWFC xC3,W
047B4:  MOVFF  01,5CE
047B8:  MOVFF  5C4,FE9
047BC:  MOVFF  5C5,FEA
047C0:  MOVFF  FEF,00
047C4:  MOVFF  FEC,01
047C8:  MOVFF  FEC,02
047CC:  MOVFF  FEC,03
047D0:  MOVWF  FEA
047D2:  MOVFF  5CE,FE9
047D6:  MOVFF  00,FEF
047DA:  MOVFF  01,FEC
047DE:  MOVFF  02,FEC
047E2:  MOVFF  03,FEC
047E6:  MOVLB  0
.................... #endif // #ifdef FAST_FAT 
....................    return 0; 
047E8:  MOVLW  00
047EA:  MOVWF  01
047EC:  GOTO   4D14 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int fatseek(FILE* stream, int32 offset, int origin) 
.................... Summary: This will set the position of the file stream according to the input. The EOF flag will also be cleared. 
.................... Param stream: The stream to set the position of. 
.................... Param offset: How many bytes relative of origin the file stream position will be set. 
.................... Param origin: This will be one of 3 values... 
....................                SEEK_CUR: Set position relative to the current stream position. 
....................                SEEK_END: Set position relative to the end of the stream. 
....................                SEEK_SET: Set position relative to the beginning of the stream. 
.................... Returns: 0 on success, or EOF if there was error. 
.................... */ 
.................... signed int fatseek(FILE* stream, int32 offset, int origin) 
.................... { 
....................    int32 myoffset;   // since fatsetpos requires a pointer to a variable, we need this here 
....................  
....................    switch(origin) 
....................    { 
....................       case SEEK_CUR: 
....................          myoffset = stream->Cur_Char + offset; 
....................          if(fatsetpos(stream, &myoffset) != 0) 
....................             return EOF; 
....................          break; 
....................       case SEEK_END: 
....................          myoffset = stream->Size - offset; 
....................          if(fatsetpos(stream, &myoffset) != 0) 
....................             return EOF; 
....................          break; 
....................       case SEEK_SET: 
....................          myoffset = offset; 
....................          if(fatsetpos(stream, &myoffset) != 0) 
....................             return EOF; 
....................          break; 
....................       default: 
....................          return EOF; 
....................    } 
....................  
....................    // clear the EOF flag 
....................    stream->Flags &= 0xEF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int fateof(FILE* stream) 
.................... Summary: Determines whether or not the stream is at the end of the file. 
.................... Param: The stream to query for EOF. 
.................... Returns: A non-zero value if the file is at EOF, 
....................           0 if the file is not at EOF. 
.................... */ 
.................... signed int fateof(FILE* stream) 
.................... { 
....................    return stream->Flags & EOF_Reached; 
.................... } 
....................  
.................... /* 
.................... signed int fatread(void* buffer, int size, int32 num, FILE* stream) 
.................... Summary: Fills up an array with data from a stream. 
.................... Param buffer: A pointer to the beginning of an array of any type. 
.................... Param size: How many bytes each element in the array is. 
.................... Param num: How many elements to fill in the array. 
.................... Param stream: The stream to read from. 
.................... Returns: How many values were written to the array. 
.................... */ 
.................... signed int fatread(void* buffer, int size, int32 num, FILE* stream) 
.................... { 
....................    int32 i; // counter for loop 
....................  
....................    // fill up every byte 
....................    for(i = 0; i < (num * size); i += 1) 
....................       buffer[i] = fatgetc(stream); 
....................  
....................    return i; 
.................... } 
....................  
.................... /* 
.................... signed int fatwrite(void* buffer, int size, int32 count, FILE* stream ) 
.................... Summary: Fills up a stream with data from an array 
.................... Param buffer: A pointer to the beginning of an array of any type. 
.................... Param size: How many bytes each element in the array is. 
.................... Param num: How many elements to write to the stream. 
.................... Param stream: The stream to write to. 
.................... Returns: How many values were written to the stream. 
.................... */ 
.................... signed int fatwrite(void* buffer, int size, int32 count, FILE* stream ) 
.................... { 
....................    int32 i; // counter for loop 
....................  
....................    // write every byte 
....................    for(i = 0; i < (count * (int32)size); i += 1) 
....................       if(fatputc(buffer[i], stream) == EOF) 
....................          return EOF; 
....................  
....................    return i; 
.................... } 
....................  
.................... /* 
.................... signed int fatflush(FILE* stream) 
.................... Summary: Flushes the buffer of a given stream. 
.................... Param: The stream to flush the buffer of. 
.................... Returns: EOF if there was a problem, 0 if everything went okay 
.................... */ 
.................... signed int fatflush(FILE* stream) 
.................... { 
....................    // check to see if we have a buffer 
....................    if((stream->Flags & Write) || (stream->Flags & Append)) 
....................    { 
....................       // check to see if we need to flush the buffer 
....................       if(stream->Cur_Char % STREAM_BUF_SIZE == 0) 
....................       { 
....................          // flush the buffer to the card 
....................          if(mmcsd_write_data(stream->Cur_Char - STREAM_BUF_SIZE, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
....................          { 
....................             stream->Flags |= Write_Error; 
....................             return EOF; 
....................          } 
....................       } 
....................       else 
....................       { 
....................          // flush the buffer to the card 
....................          //  we need to make sure that the buffer gets flushed into the proper location, hence all this weird % math 
....................          if(mmcsd_write_data(stream->Cur_Char - (stream->Cur_Char % STREAM_BUF_SIZE), STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
....................          { 
....................             stream->Flags |= Write_Error; 
....................             return EOF; 
....................          } 
....................       } 
....................       return(mmcsd_flush_buffer()); 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* 
.................... signed int remove(char* fname) 
.................... Summary: Removes a file from disk. 
.................... Param: The full path of the file to remove. 
.................... Returns: 0 on success, or EOF if there was error. 
.................... Note: This function does not work for removing directories, use rm_dir instead. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... */ 
.................... signed int remove(char* fname) 
.................... { 
....................    if(rm_file(fname) == EOF) 
....................        return EOF; 
....................  
....................    return 0; 
.................... } 
....................  
.................... /* 
.................... signed int faterror(FILE* stream) 
.................... Summary: Checks for an error in a given stream. 
.................... Param: The stream to check for an error in. 
.................... Returns: A non-zero value of there is an error in the stream, 
....................           0 if there is no error in the stream 
.................... */ 
.................... signed int faterror(FILE* stream) 
.................... { 
....................    return stream->Flags & 0xF0; 
.................... } 
....................  
.................... /* 
.................... void clearerr(FILE* stream) 
.................... Summary: Clears off all error in a given stream. 
.................... Param: The stream to clear off the errors in. 
.................... Returns: Nothing. 
.................... */ 
.................... void clearerr(FILE* stream) 
.................... { 
....................    stream->Flags &= 0x0F; 
.................... } 
....................  
.................... /* 
.................... void rewind(FILE* stream) 
.................... Summary: Sets the stream to point back to the beginning of a file. 
.................... Param: The stream to rewind. 
.................... Returns: Nothing. 
.................... */ 
.................... void rewind(FILE* stream) 
.................... { 
....................    // set the stream back to the beginning 
....................    stream->Cur_Char = stream->Start_Addr; 
*
03A18:  MOVLW  04
03A1A:  MOVLB  5
03A1C:  ADDWF  xCE,W
03A1E:  MOVWF  01
03A20:  MOVLW  00
03A22:  ADDWFC xCF,W
03A24:  MOVWF  03
03A26:  MOVFF  01,5D0
03A2A:  MOVWF  xD1
03A2C:  MOVLW  14
03A2E:  ADDWF  xCE,W
03A30:  MOVWF  FE9
03A32:  MOVLW  00
03A34:  ADDWFC xCF,W
03A36:  MOVWF  FEA
03A38:  MOVFF  FEF,00
03A3C:  MOVFF  FEC,01
03A40:  MOVFF  FEC,02
03A44:  MOVFF  FEC,03
03A48:  MOVFF  5D1,FEA
03A4C:  MOVFF  5D0,FE9
03A50:  MOVFF  00,FEF
03A54:  MOVFF  01,FEC
03A58:  MOVFF  02,FEC
03A5C:  MOVFF  03,FEC
....................    stream->Bytes_Until_EOF = stream->Size; 
03A60:  MOVLW  10
03A62:  ADDWF  xCE,W
03A64:  MOVWF  FE9
03A66:  MOVLW  00
03A68:  ADDWFC xCF,W
03A6A:  MOVWF  FEA
03A6C:  MOVFF  FEF,00
03A70:  MOVFF  FEC,01
03A74:  MOVFF  FEC,02
03A78:  MOVFF  FEC,03
03A7C:  MOVFF  5CF,FEA
03A80:  MOVFF  5CE,FE9
03A84:  MOVFF  00,FEF
03A88:  MOVFF  01,FEC
03A8C:  MOVFF  02,FEC
03A90:  MOVFF  03,FEC
03A94:  MOVLB  0
03A96:  GOTO   43F4 (RETURN)
.................... } 
....................  
.................... /* 
.................... fatpos_t fattell(FILE* stream) 
.................... Summary: Returns the current position of where the stream is pointing to relative to the beginning of the stream. 
.................... Param: The stream to return the position of. 
.................... Returns: The position of where the stream is pointing to relative to the beginning of the stream, or 0 if there was a problem. 
.................... */ 
.................... fatpos_t fattell(FILE* stream) 
.................... { 
....................    fatpos_t retval; 
....................  
....................    if(fatgetpos(stream, &retval) != 0) 
....................       return 0; 
....................  
....................    return retval; 
.................... } 
....................  
.................... /// Non-Standard C Functions /// 
....................  
.................... /* 
.................... signed int rm_file(char fname[]) 
.................... Summary: Deletes a file. 
.................... Param: The full path of the file to delete. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... */ 
.................... signed int rm_file(char fname[]) 
.................... { 
....................    int 
....................       order, 
....................       ulinked_entry = 0xE5; // 0xE5 is put into the file's entry to indicate unlinking 
....................  
....................    int32 i; 
....................  
....................    char mode[] = "r";        // r is the safest mode to remove files with 
....................  
....................    FILE stream;              // the stream that we'll be working with 
....................  
....................    // attempt to open the stream 
....................    if(fatopen(fname, mode, &stream) == EOF) 
....................       return EOF; 
....................  
....................    // we need to un-link the file's clusters from the FAT if there are clusters allocated 
....................    if(stream.Start_Addr > Root_Dir) 
....................    { 
....................       if(dealloc_clusters(addr_to_cluster(stream.Start_Addr)) == EOF) 
....................          return EOF; 
....................    } 
....................    // get rid of the first entry 
....................    i = stream.Entry_Addr; 
....................    if(mmcsd_write_data(i, 1, &ulinked_entry) == EOF) 
....................       return EOF; 
....................     
....................    // check to see if there is a long file name 
....................    get_prev_entry(&i); 
....................    if(mmcsd_read_data(i + 11, 1, &order) == EOF) 
....................       return EOF; 
....................  
....................    // get rid of all of the long file name entries if they're there 
....................    while(order == 0x0F) 
....................    { 
....................       if(mmcsd_write_data(i, 1, &ulinked_entry) == EOF) 
....................          return EOF; 
....................  
....................       if(get_prev_entry(&i) == EOF) 
....................          return EOF; 
....................  
....................       if(mmcsd_read_data(i + 11, 1, &order) == EOF) 
....................          return EOF; 
....................    } 
....................     
....................    if(fatclose(&stream) == EOF) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int rm_dir(char dname[]) 
.................... Summary: Deletes a directory. 
.................... Param: The full path of the directory to delete. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: dname must be in the form of /Dirname/ for a directory in the root directory 
....................        /Dirname/Subdirname/ for a directory in a subdirectory of root and so on... 
.................... Note: This function cannot remove all of the files 
....................        and subdirectories of the directory. Manually remove all subdirectories 
....................        and files before calling this command. 
.................... */ 
.................... signed int rm_dir(char dname[]) 
.................... { 
....................    char mode[] = "r";        // r is the safest mode to remove files with 
....................  
....................    FILE stream;              // the stream that we'll be working with 
....................  
....................    // attempt to open the stream 
....................    if(fatopen(dname, mode, &stream) == EOF) 
....................       return EOF; 
....................  
....................    // jump over the . and .. entries in the directory 
....................    stream.Entry_Addr = stream.Start_Addr + 64; 
....................     
....................    // check to make sure that there isn't stuff in this directory 
....................    if(get_next_file(&stream) != EOF) 
....................       return EOF; 
....................  
....................    // since removing files is a lot like removing directories, we 
....................    //  can just call rm_file 
....................    if(rm_file(dname) == EOF) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int mk_file(char fname[]) 
.................... Summary: Creates a file. 
.................... Param: The full path of the file to create. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: This function will not create directories if parent directories don't exist. 
.................... Note: fname must be in the form of /filename.fil for a file in the root directory 
....................        /Directory/filename.fil for a file in a subdirectory of root 
....................        /Directory/Subdirectory/filename.fil and so on... 
.................... */ 
.................... signed int mk_file(char fname[]) 
*
05DBE:  CLRF   xF1
.................... { 
....................    char 
....................       filename[MAX_FILE_NAME_LENGTH],   // the file name we're trying to make 
....................       mode[] = "r";                     // reading is the safest mode to work in 
*
05DB6:  MOVLW  72
05DB8:  MOVLB  4
05DBA:  MOVWF  xCE
05DBC:  CLRF   xCF
....................  
....................    int 
....................       buf,               // buffer to hold values 
....................       entire_entry[0x20],// entire first entry 
....................       filename_pos = 0,  // the current parse position of the file name we're trying to create 
....................       fname_pos;         // the current parse position of the input the the function 
....................  
....................    int32 i;      // pointer to memory 
....................  
....................    FILE stream;   // the stream that we'll be working with 
....................  
....................    // attempt to open up to the directory 
....................    if(fatopen(fname, mode, &stream) == GOODEC) 
*
05DC0:  MOVFF  4AD,532
05DC4:  MOVFF  4AC,531
05DC8:  MOVLW  04
05DCA:  MOVLB  5
05DCC:  MOVWF  x34
05DCE:  MOVLW  CE
05DD0:  MOVWF  x33
05DD2:  MOVLW  04
05DD4:  MOVWF  x36
05DD6:  MOVLW  F7
05DD8:  MOVWF  x35
05DDA:  MOVLB  0
05DDC:  GOTO   4F76
05DE0:  MOVF   01,F
05DE2:  BNZ   5DEA
....................       return EOF; // we shouldn't get an GOODEC back from fatopen() 
05DE4:  MOVLW  FF
05DE6:  MOVWF  01
05DE8:  BRA    5F50
....................  
....................    // check to see if the file is already there. 
....................    if(!(stream.Flags & File_Not_Found)) 
05DEA:  MOVLB  5
05DEC:  BTFSC  x10.7
05DEE:  BRA    5DFA
....................       return EOF; 
05DF0:  MOVLW  FF
05DF2:  MOVWF  01
05DF4:  MOVLB  0
05DF6:  BRA    5F50
05DF8:  MOVLB  5
....................  
....................    // make a file name 
....................    fname_pos = strrchr(fname, '/') - fname + 1; 
05DFA:  MOVFF  4AD,532
05DFE:  MOVFF  4AC,531
05E02:  MOVLW  2F
05E04:  MOVWF  x33
05E06:  MOVLB  0
05E08:  GOTO   51FE
05E0C:  MOVFF  02,532
05E10:  MOVFF  01,531
05E14:  MOVLB  4
05E16:  MOVF   xAC,W
05E18:  MOVLB  5
05E1A:  SUBWF  x31,F
05E1C:  MOVLB  4
05E1E:  MOVF   xAD,W
05E20:  MOVLB  5
05E22:  SUBWFB x32,F
05E24:  MOVLW  01
05E26:  ADDWF  x31,W
05E28:  MOVLB  4
05E2A:  MOVWF  xF2
....................    while((fname[fname_pos] != '\0') && (filename_pos < MAX_FILE_NAME_LENGTH)) 
05E2C:  CLRF   03
05E2E:  MOVF   xF2,W
05E30:  ADDWF  xAC,W
05E32:  MOVWF  FE9
05E34:  MOVF   xAD,W
05E36:  ADDWFC 03,W
05E38:  MOVWF  FEA
05E3A:  MOVF   FEF,F
05E3C:  BZ    5E82
05E3E:  MOVF   xF1,W
05E40:  SUBLW  1F
05E42:  BNC   5E82
....................    { 
....................       filename[filename_pos] = fname[fname_pos]; 
05E44:  CLRF   03
05E46:  MOVF   xF1,W
05E48:  ADDLW  AE
05E4A:  MOVWF  01
05E4C:  MOVLW  04
05E4E:  ADDWFC 03,F
05E50:  MOVLB  5
05E52:  MOVFF  03,532
05E56:  CLRF   03
05E58:  MOVLB  4
05E5A:  MOVF   xF2,W
05E5C:  ADDWF  xAC,W
05E5E:  MOVWF  FE9
05E60:  MOVF   xAD,W
05E62:  ADDWFC 03,W
05E64:  MOVWF  FEA
05E66:  MOVFF  FEF,533
05E6A:  MOVLB  5
05E6C:  MOVFF  532,FEA
05E70:  MOVFF  01,FE9
05E74:  MOVFF  533,FEF
....................       fname_pos += 1; 
05E78:  MOVLW  01
05E7A:  MOVLB  4
05E7C:  ADDWF  xF2,F
....................       filename_pos += 1; 
05E7E:  ADDWF  xF1,F
05E80:  BRA    5E2C
....................    } 
....................    filename[filename_pos] = '\0'; 
05E82:  CLRF   03
05E84:  MOVF   xF1,W
05E86:  ADDLW  AE
05E88:  MOVWF  FE9
05E8A:  MOVLW  04
05E8C:  ADDWFC 03,W
05E8E:  MOVWF  FEA
05E90:  CLRF   FEF
....................  
....................    // write the name 
....................    if(set_file_name(stream.Start_Addr, &i, filename) == EOF) 
05E92:  MOVFF  50E,534
05E96:  MOVFF  50D,533
05E9A:  MOVFF  50C,532
05E9E:  MOVFF  50B,531
05EA2:  MOVLW  04
05EA4:  MOVLB  5
05EA6:  MOVWF  x36
05EA8:  MOVLW  F3
05EAA:  MOVWF  x35
05EAC:  MOVLW  04
05EAE:  MOVWF  x38
05EB0:  MOVLW  AE
05EB2:  MOVWF  x37
05EB4:  MOVLB  0
05EB6:  BRA    5AD0
05EB8:  MOVF   01,W
05EBA:  SUBLW  FF
05EBC:  BNZ   5EC4
....................       return EOF; 
05EBE:  MOVLW  FF
05EC0:  MOVWF  01
05EC2:  BRA    5F50
....................  
....................    // throw in some values in the file's first entry 
....................    for(buf = 0; buf < 0x20; buf += 1) 
05EC4:  MOVLB  4
05EC6:  CLRF   xD0
05EC8:  MOVF   xD0,W
05ECA:  SUBLW  1F
05ECC:  BNC   5EE4
....................       entire_entry[buf] = 0; 
05ECE:  CLRF   03
05ED0:  MOVF   xD0,W
05ED2:  ADDLW  D1
05ED4:  MOVWF  FE9
05ED6:  MOVLW  04
05ED8:  ADDWFC 03,W
05EDA:  MOVWF  FEA
05EDC:  CLRF   FEF
05EDE:  MOVLW  01
05EE0:  ADDWF  xD0,F
05EE2:  BRA    5EC8
....................  
....................    // this is a file 
....................    entire_entry[0x0B] = 0x20; 
05EE4:  MOVLW  20
05EE6:  MOVWF  xDC
....................  
....................    // read what set_file_name gave us for the short name 
....................    if(mmcsd_read_data(i, 11, entire_entry) != GOODEC) 
05EE8:  MOVFF  4F6,5FE
05EEC:  MOVFF  4F5,5FD
05EF0:  MOVFF  4F4,5FC
05EF4:  MOVFF  4F3,5FB
05EF8:  MOVLB  6
05EFA:  CLRF   x00
05EFC:  MOVLW  0B
05EFE:  MOVLB  5
05F00:  MOVWF  xFF
05F02:  MOVLW  04
05F04:  MOVLB  6
05F06:  MOVWF  x02
05F08:  MOVLW  D1
05F0A:  MOVWF  x01
05F0C:  MOVLB  0
05F0E:  CALL   2B2E
05F12:  MOVF   01,F
05F14:  BZ    5F1C
....................       return EOF; 
05F16:  MOVLW  FF
05F18:  MOVWF  01
05F1A:  BRA    5F50
....................  
....................    // write the entry 
....................    if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
05F1C:  MOVFF  4F6,617
05F20:  MOVFF  4F5,616
05F24:  MOVFF  4F4,615
05F28:  MOVFF  4F3,614
05F2C:  MOVLB  6
05F2E:  CLRF   x19
05F30:  MOVLW  20
05F32:  MOVWF  x18
05F34:  MOVLW  04
05F36:  MOVWF  x1B
05F38:  MOVLW  D1
05F3A:  MOVWF  x1A
05F3C:  MOVLB  0
05F3E:  CALL   3874
05F42:  MOVF   01,F
05F44:  BZ    5F4C
....................       return EOF; 
05F46:  MOVLW  FF
05F48:  MOVWF  01
05F4A:  BRA    5F50
....................  
....................    return GOODEC; 
05F4C:  MOVLW  00
05F4E:  MOVWF  01
05F50:  GOTO   5F9A (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int mk_dir(char dname[]) 
.................... Summary: Creates a directory. 
.................... Param: The full path of the directory to create. 
.................... Returns: GOODEC if everything went okay, EOF if there was a problem. 
.................... Note: This function will not create directories if parent directories don't exist. 
.................... Note: dname must be in the form of /Dirname/ for a directory in the root directory 
....................        /Dirname/Subdirname/ for a directory in a subdirectory of root and so on... 
.................... */ 
.................... signed int mk_dir(char dname[]) 
.................... { 
....................    char 
....................       dirname[MAX_FILE_NAME_LENGTH],    // the directory name we're trying to make 
....................       entire_entry[0x20],               // used to hold the link entries (. and ..) to the directory and its parent 
....................       mode[] = "r";                     // reading is the safest mode to work in 
....................  
....................    int 
....................       dirname_pos = 0,   // the current parse position of the directory name we're trying to create 
....................       dname_pos,         // the current parse position of the input the the function 
....................       j;                 // counter for loops 
....................  
....................    int32 i;   // pointer to memory 
....................  
....................    FILE stream;   // the stream that we'll be working with 
....................  
....................    // attempt to open up to the directory 
....................    if(fatopen(dname, mode, &stream) == GOODEC) 
....................       return EOF; // we shouldn't get an GOODEC back from fatopen() 
....................  
....................    // check to see if the directory is already there. 
....................    if(!(stream.Flags & File_Not_Found)) 
....................       return EOF; 
....................  
....................    // make the directory name 
....................    dname_pos = strrchr(dname, '/') - dname; 
....................    dname[dname_pos] = '\0'; 
....................    dname_pos = strrchr(dname, '/') - dname + 1; 
....................    while((dname[dname_pos] != '\0') && (dirname_pos < MAX_FILE_NAME_LENGTH)) 
....................    { 
....................       dirname[dirname_pos] = dname[dname_pos]; 
....................       dname_pos += 1; 
....................       dirname_pos += 1; 
....................    } 
....................    dirname[dirname_pos] = '\0'; 
....................    dname[dname_pos] = '/'; 
....................  
....................    // write the file's name 
....................    if(set_file_name(stream.Start_Addr, &i, dirname) == EOF) 
....................       return EOF; 
....................  
....................    // find and allocate an open cluster 
....................    if(get_next_free_cluster(&Next_Free_Clust) == EOF) 
....................       return EOF; 
....................    if(clear_cluster(Next_Free_Clust) == EOF) 
....................       return EOF; 
.................... #ifdef FAT32 
....................    if(write_fat(Next_Free_Clust, 0x0FFFFFFF) == EOF) 
....................       return EOF; 
.................... #else // FAT16 
....................    if(write_fat(Next_Free_Cluster, 0xFFFF) == EOF) 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................    // throw in some values in the file's first entry 
....................    for(j = 0; j < 0x20; j += 1) 
....................       entire_entry[j] = 0; 
....................  
....................    // this is a directory 
....................    entire_entry[0x0B] = 0x10; 
....................  
....................    entire_entry[0x1A] = make8(Next_Free_Clust, 0); 
....................    entire_entry[0x1B] = make8(Next_Free_Clust, 1); 
.................... #ifdef FAT32 
....................    entire_entry[0x14] = make8(Next_Free_Clust, 2); 
....................    entire_entry[0x15] = make8(Next_Free_Clust, 3); 
.................... #endif // #ifdef FAT32 
....................  
....................    if(mmcsd_read_data(i, 11, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    // write the file's first entry 
....................    if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    // make the two links that point to the directory and the directory's parent 
....................    i = cluster_to_addr(Next_Free_Clust); 
....................  
....................    // put in the first link that points to the directory itself 
....................    for(j = 0; j < 0x20; j += 1) 
....................    { 
....................       if(j < 0x01) 
....................          entire_entry[j] = '.'; 
....................       else if(j < 0x0B) 
....................          entire_entry[j] = 0x20; 
....................       else if(j == 0x0B) 
....................          entire_entry[j] = 0x10; 
....................       else 
....................          entire_entry[j] = 0x00; 
....................    } 
....................  
....................    entire_entry[0x1A] = make8(Next_Free_Clust, 0); 
....................    entire_entry[0x1B] = make8(Next_Free_Clust, 1); 
.................... #ifdef FAT32 
....................    entire_entry[0x14] = make8(Next_Free_Clust, 2); 
....................    entire_entry[0x15] = make8(Next_Free_Clust, 3); 
.................... #endif // #ifdef FAT32 
....................  
....................    if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    for(j = 0; j < 0x0C; j += 1) 
....................    { 
....................       if(j < 0x02) 
....................          entire_entry[j] = '.'; 
....................       else if(j < 0x0B) 
....................          entire_entry[j] = 0x20; 
....................       else 
....................          entire_entry[j] = 0x10; 
....................    } 
....................  
....................    if(stream.Parent_Start_Addr == Root_Dir) 
....................    { 
....................       entire_entry[0x14] = 0x00; 
....................       entire_entry[0x15] = 0x00; 
....................       entire_entry[0x1A] = 0x00; 
....................       entire_entry[0x1B] = 0x00; 
....................    } 
....................    else 
....................    { 
....................       entire_entry[0x1A] = make8(addr_to_cluster(stream.Parent_Start_Addr), 0); 
....................       entire_entry[0x1B] = make8(addr_to_cluster(stream.Parent_Start_Addr), 1); 
.................... #ifdef FAT32 
....................       entire_entry[0x14] = make8(addr_to_cluster(stream.Parent_Start_Addr), 2); 
....................       entire_entry[0x15] = make8(addr_to_cluster(stream.Parent_Start_Addr), 3); 
.................... #endif // #ifdef FAT32 
....................    } 
....................  
....................    if(mmcsd_write_data(i + 0x20, 0x20, entire_entry) != GOODEC) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /// Functions' Utility Functions /// 
.................... /// NOTE: A library user should not need to use any of the functions in this section /// 
....................  
.................... /* 
.................... signed int set_file(char fname[], int attrib, FILE* stream) 
.................... Summary: This will set the stream to point to the specified file. 
.................... Param fname: The file name to search for. 
.................... Param attrib: The file attributes to search for. 0x10 is a directory, 0x20 is a file. 
.................... Param stream: The stream to set. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: The stream has to be pointing to the parent directory's start address when coming in to this function. 
.................... */ 
.................... signed int set_file(char fname[], int attrib, FILE* stream) 
*
04852:  MOVLB  5
04854:  CLRF   x9B
.................... { 
....................    int 
....................       cur_attrib,    // the attribute of the most recently read entry 
....................       cur_state,     // the state of the most recently read entry 
....................       ec = 0;        // error checking byte 
....................  
....................    int32 i;   // pointer to memory 
.................... #ifndef FAST_FAT 
....................    char name_buffer[MAX_FILE_NAME_LENGTH];   // buffer to hold in the most recently read in name 
.................... #endif // #ifndef FAST_FAT 
....................  
....................    // set the memory pointer to the parent start address 
....................    i = stream->Start_Addr; 
04856:  MOVLW  14
04858:  ADDWF  x97,W
0485A:  MOVWF  FE9
0485C:  MOVLW  00
0485E:  ADDWFC x98,W
04860:  MOVWF  FEA
04862:  MOVFF  FEF,59C
04866:  MOVFF  FEC,59D
0486A:  MOVFF  FEC,59E
0486E:  MOVFF  FEC,59F
....................  
....................    // search for the name of our target file inside of the parent directory 
....................    do 
....................    { 
....................       // read the state and the attribute of the current entry 
....................       ec += mmcsd_read_data(i, 1, &cur_state); 
04872:  MOVFF  59F,5FE
04876:  MOVFF  59E,5FD
0487A:  MOVFF  59D,5FC
0487E:  MOVFF  59C,5FB
04882:  MOVLB  6
04884:  CLRF   x00
04886:  MOVLW  01
04888:  MOVLB  5
0488A:  MOVWF  xFF
0488C:  MOVLW  05
0488E:  MOVLB  6
04890:  MOVWF  x02
04892:  MOVLW  9A
04894:  MOVWF  x01
04896:  MOVLB  0
04898:  CALL   2B2E
0489C:  MOVF   01,W
0489E:  MOVLB  5
048A0:  ADDWF  x9B,F
....................       ec += mmcsd_read_data(i + 0x0B, 1, &cur_attrib); 
048A2:  MOVLW  0B
048A4:  ADDWF  x9C,W
048A6:  MOVWF  xC0
048A8:  MOVLW  00
048AA:  ADDWFC x9D,W
048AC:  MOVWF  xC1
048AE:  MOVLW  00
048B0:  ADDWFC x9E,W
048B2:  MOVWF  xC2
048B4:  MOVLW  00
048B6:  ADDWFC x9F,W
048B8:  MOVWF  xC3
048BA:  MOVWF  xFE
048BC:  MOVFF  5C2,5FD
048C0:  MOVFF  5C1,5FC
048C4:  MOVFF  5C0,5FB
048C8:  MOVLB  6
048CA:  CLRF   x00
048CC:  MOVLW  01
048CE:  MOVLB  5
048D0:  MOVWF  xFF
048D2:  MOVLW  05
048D4:  MOVLB  6
048D6:  MOVWF  x02
048D8:  MOVLW  99
048DA:  MOVWF  x01
048DC:  MOVLB  0
048DE:  CALL   2B2E
048E2:  MOVF   01,W
048E4:  MOVLB  5
048E6:  ADDWF  x9B,F
....................       if(ec != GOODEC) 
048E8:  MOVF   x9B,F
048EA:  BZ    4904
....................       { 
....................          stream->Flags |= Read_Error; 
048EC:  MOVLW  19
048EE:  ADDWF  x97,W
048F0:  MOVWF  FE9
048F2:  MOVLW  00
048F4:  ADDWFC x98,W
048F6:  MOVWF  FEA
048F8:  MOVF   FEF,W
048FA:  IORLW  20
048FC:  MOVWF  FEF
....................          return EOF; 
048FE:  MOVLW  FF
04900:  MOVWF  01
04902:  BRA    4F72
....................       } 
....................  
....................        // check to make sure that this entry exists and the entry is the type we're looking for 
....................       if((cur_state != 0xE5) && (cur_attrib == attrib)) 
04904:  MOVF   x9A,W
04906:  SUBLW  E5
04908:  BTFSC  FD8.2
0490A:  BRA    4F34
0490C:  MOVF   x96,W
0490E:  SUBWF  x99,W
04910:  BTFSS  FD8.2
04912:  BRA    4F34
....................       { 
.................... #ifndef FAST_FAT 
....................          // get the long file name of the current entry 
....................          if(get_file_name(i, name_buffer) == EOF) 
04914:  MOVFF  59F,5C3
04918:  MOVFF  59E,5C2
0491C:  MOVFF  59D,5C1
04920:  MOVFF  59C,5C0
04924:  MOVLW  05
04926:  MOVWF  xC5
04928:  MOVLW  A0
0492A:  MOVWF  xC4
0492C:  MOVLB  0
0492E:  GOTO   359C
04932:  MOVF   01,W
04934:  SUBLW  FF
04936:  BNZ   4942
....................             return EOF; 
04938:  MOVLW  FF
0493A:  MOVWF  01
0493C:  MOVLB  5
0493E:  BRA    4F72
04940:  MOVLB  0
....................  
....................          // if the target entry and the long file name are equal, strcmp will return a zero 
....................          if(strcmp(fname, name_buffer) == 0) 
04942:  MOVFF  595,5C1
04946:  MOVFF  594,5C0
0494A:  MOVLW  05
0494C:  MOVLB  5
0494E:  MOVWF  xC3
04950:  MOVLW  A0
04952:  MOVWF  xC2
04954:  MOVLB  0
04956:  CALL   372E
0495A:  MOVF   01,F
0495C:  BTFSS  FD8.2
0495E:  BRA    4F36
.................... #endif // #ifndef FAST_FAT 
....................          { 
....................             // we have found our target entry, set the current entry and break out of this function 
....................             // set stream's parent address 
....................             stream->Parent_Start_Addr = stream->Start_Addr; 
04960:  MOVLW  0C
04962:  MOVLB  5
04964:  ADDWF  x97,W
04966:  MOVWF  01
04968:  MOVLW  00
0496A:  ADDWFC x98,W
0496C:  MOVWF  03
0496E:  MOVFF  01,5C0
04972:  MOVWF  xC1
04974:  MOVLW  14
04976:  ADDWF  x97,W
04978:  MOVWF  FE9
0497A:  MOVLW  00
0497C:  ADDWFC x98,W
0497E:  MOVWF  FEA
04980:  MOVFF  FEF,00
04984:  MOVFF  FEC,01
04988:  MOVFF  FEC,02
0498C:  MOVFF  FEC,03
04990:  MOVFF  5C1,FEA
04994:  MOVFF  5C0,FE9
04998:  MOVFF  00,FEF
0499C:  MOVFF  01,FEC
049A0:  MOVFF  02,FEC
049A4:  MOVFF  03,FEC
....................  
....................             ec += mmcsd_read_data(i + 0x1C, 4, &(stream->Size)); 
049A8:  MOVLW  1C
049AA:  ADDWF  x9C,W
049AC:  MOVWF  xC0
049AE:  MOVLW  00
049B0:  ADDWFC x9D,W
049B2:  MOVWF  xC1
049B4:  MOVLW  00
049B6:  ADDWFC x9E,W
049B8:  MOVWF  xC2
049BA:  MOVLW  00
049BC:  ADDWFC x9F,W
049BE:  MOVWF  xC3
049C0:  MOVLW  10
049C2:  ADDWF  x97,W
049C4:  MOVWF  01
049C6:  MOVLW  00
049C8:  ADDWFC x98,W
049CA:  MOVWF  03
049CC:  MOVFF  01,5C4
049D0:  MOVWF  xC5
049D2:  MOVFF  5C3,5FE
049D6:  MOVFF  5C2,5FD
049DA:  MOVFF  5C1,5FC
049DE:  MOVFF  5C0,5FB
049E2:  MOVLB  6
049E4:  CLRF   x00
049E6:  MOVLW  04
049E8:  MOVLB  5
049EA:  MOVWF  xFF
049EC:  MOVFF  03,602
049F0:  MOVFF  01,601
049F4:  MOVLB  0
049F6:  CALL   2B2E
049FA:  MOVF   01,W
049FC:  MOVLB  5
049FE:  ADDWF  x9B,F
....................  
....................             // stream->Start_Addr is going to temporarily have a cluster number 
....................             ec += mmcsd_read_data(i + 0x14, 2, (int16*)&stream->Start_Addr + 1); 
04A00:  MOVLW  14
04A02:  ADDWF  x9C,W
04A04:  MOVWF  xC0
04A06:  MOVLW  00
04A08:  ADDWFC x9D,W
04A0A:  MOVWF  xC1
04A0C:  MOVLW  00
04A0E:  ADDWFC x9E,W
04A10:  MOVWF  xC2
04A12:  MOVLW  00
04A14:  ADDWFC x9F,W
04A16:  MOVWF  xC3
04A18:  MOVLW  14
04A1A:  ADDWF  x97,W
04A1C:  MOVWF  01
04A1E:  MOVLW  00
04A20:  ADDWFC x98,W
04A22:  MOVWF  03
04A24:  MOVFF  01,5C4
04A28:  MOVWF  xC5
04A2A:  MOVLW  02
04A2C:  ADDWF  xC4,F
04A2E:  MOVLW  00
04A30:  ADDWFC xC5,F
04A32:  MOVFF  5C3,5FE
04A36:  MOVFF  5C2,5FD
04A3A:  MOVFF  5C1,5FC
04A3E:  MOVFF  5C0,5FB
04A42:  MOVLB  6
04A44:  CLRF   x00
04A46:  MOVLW  02
04A48:  MOVLB  5
04A4A:  MOVWF  xFF
04A4C:  MOVFF  5C5,602
04A50:  MOVFF  5C4,601
04A54:  MOVLB  0
04A56:  CALL   2B2E
04A5A:  MOVF   01,W
04A5C:  MOVLB  5
04A5E:  ADDWF  x9B,F
....................             ec += mmcsd_read_data(i + 0x1A, 2, &stream->Start_Addr); 
04A60:  MOVLW  1A
04A62:  ADDWF  x9C,W
04A64:  MOVWF  xC0
04A66:  MOVLW  00
04A68:  ADDWFC x9D,W
04A6A:  MOVWF  xC1
04A6C:  MOVLW  00
04A6E:  ADDWFC x9E,W
04A70:  MOVWF  xC2
04A72:  MOVLW  00
04A74:  ADDWFC x9F,W
04A76:  MOVWF  xC3
04A78:  MOVLW  14
04A7A:  ADDWF  x97,W
04A7C:  MOVWF  01
04A7E:  MOVLW  00
04A80:  ADDWFC x98,W
04A82:  MOVWF  03
04A84:  MOVFF  01,5C4
04A88:  MOVWF  xC5
04A8A:  MOVFF  5C3,5FE
04A8E:  MOVFF  5C2,5FD
04A92:  MOVFF  5C1,5FC
04A96:  MOVFF  5C0,5FB
04A9A:  MOVLB  6
04A9C:  CLRF   x00
04A9E:  MOVLW  02
04AA0:  MOVLB  5
04AA2:  MOVWF  xFF
04AA4:  MOVFF  03,602
04AA8:  MOVFF  01,601
04AAC:  MOVLB  0
04AAE:  CALL   2B2E
04AB2:  MOVF   01,W
04AB4:  MOVLB  5
04AB6:  ADDWF  x9B,F
....................  
....................             if(ec != GOODEC) 
04AB8:  MOVF   x9B,F
04ABA:  BZ    4AD4
....................             { 
....................                stream->Flags |= Read_Error; 
04ABC:  MOVLW  19
04ABE:  ADDWF  x97,W
04AC0:  MOVWF  FE9
04AC2:  MOVLW  00
04AC4:  ADDWFC x98,W
04AC6:  MOVWF  FEA
04AC8:  MOVF   FEF,W
04ACA:  IORLW  20
04ACC:  MOVWF  FEF
....................                return EOF; 
04ACE:  MOVLW  FF
04AD0:  MOVWF  01
04AD2:  BRA    4F72
....................             } 
....................  
....................             // convert stream->Start_Addr to an address 
....................             stream->Start_Addr = cluster_to_addr(stream->Start_Addr); 
04AD4:  MOVLW  14
04AD6:  ADDWF  x97,W
04AD8:  MOVWF  01
04ADA:  MOVLW  00
04ADC:  ADDWFC x98,W
04ADE:  MOVWF  03
04AE0:  MOVFF  01,5C0
04AE4:  MOVWF  xC1
04AE6:  MOVLW  14
04AE8:  ADDWF  x97,W
04AEA:  MOVWF  FE9
04AEC:  MOVLW  00
04AEE:  ADDWFC x98,W
04AF0:  MOVWF  FEA
04AF2:  MOVFF  FEF,5C2
04AF6:  MOVFF  FEC,5C3
04AFA:  MOVFF  FEC,5C4
04AFE:  MOVFF  FEC,5C5
04B02:  MOVFF  5C5,613
04B06:  MOVFF  5C4,612
04B0A:  MOVFF  5C3,611
04B0E:  MOVFF  5C2,610
04B12:  MOVLB  0
04B14:  CALL   32FA
04B18:  MOVFF  5C1,FEA
04B1C:  MOVFF  5C0,FE9
04B20:  MOVFF  00,FEF
04B24:  MOVFF  01,FEC
04B28:  MOVFF  02,FEC
04B2C:  MOVFF  03,FEC
....................  
....................             stream->Entry_Addr = i; 
04B30:  MOVLW  08
04B32:  MOVLB  5
04B34:  ADDWF  x97,W
04B36:  MOVWF  FE9
04B38:  MOVLW  00
04B3A:  ADDWFC x98,W
04B3C:  MOVWF  FEA
04B3E:  MOVFF  59C,FEF
04B42:  MOVFF  59D,FEC
04B46:  MOVFF  59E,FEC
04B4A:  MOVFF  59F,FEC
....................             stream->Bytes_Until_EOF = stream->Size; 
04B4E:  MOVLW  10
04B50:  ADDWF  x97,W
04B52:  MOVWF  FE9
04B54:  MOVLW  00
04B56:  ADDWFC x98,W
04B58:  MOVWF  FEA
04B5A:  MOVFF  FEF,00
04B5E:  MOVFF  FEC,01
04B62:  MOVFF  FEC,02
04B66:  MOVFF  FEC,03
04B6A:  MOVFF  598,FEA
04B6E:  MOVFF  597,FE9
04B72:  MOVFF  00,FEF
04B76:  MOVFF  01,FEC
04B7A:  MOVFF  02,FEC
04B7E:  MOVFF  03,FEC
....................  
....................             // set up some permission-specific parameters if we're at a file 
....................             if(attrib == 0x20) 
04B82:  MOVF   x96,W
04B84:  SUBLW  20
04B86:  BTFSS  FD8.2
04B88:  BRA    4F1E
....................             { 
....................                stream->File_Type = Data_File; 
04B8A:  MOVLW  18
04B8C:  ADDWF  x97,W
04B8E:  MOVWF  FE9
04B90:  MOVLW  00
04B92:  ADDWFC x98,W
04B94:  MOVWF  FEA
04B96:  CLRF   FEF
....................                if(stream->Flags & Write) 
04B98:  MOVLW  19
04B9A:  ADDWF  x97,W
04B9C:  MOVWF  FE9
04B9E:  MOVLW  00
04BA0:  ADDWFC x98,W
04BA2:  MOVWF  FEA
04BA4:  BTFSS  FEF.1
04BA6:  BRA    4CB0
....................                { 
....................                   // delete all previous data in the file 
....................                   stream->Bytes_Until_EOF = stream->Size = 0; 
04BA8:  MOVLW  10
04BAA:  ADDWF  x97,W
04BAC:  MOVWF  FE9
04BAE:  MOVLW  00
04BB0:  ADDWFC x98,W
04BB2:  MOVWF  FEA
04BB4:  MOVF   FEE,F
04BB6:  MOVF   FEE,F
04BB8:  CLRF   FEC
04BBA:  MOVF   FED,F
04BBC:  CLRF   FEF
04BBE:  MOVF   FED,F
04BC0:  CLRF   FEF
04BC2:  MOVF   FED,F
04BC4:  CLRF   FEF
04BC6:  MOVLW  00
04BC8:  MOVFF  598,FEA
04BCC:  MOVFF  597,FE9
04BD0:  MOVFF  00,FEF
04BD4:  MOVFF  597,FEC
04BD8:  MOVFF  02,FEC
04BDC:  MOVFF  598,FEC
....................  
....................                   // if there is already space allocated, get rid of it 
....................                   if(stream->Start_Addr >= Data_Start) 
04BE0:  MOVLW  14
04BE2:  ADDWF  x97,W
04BE4:  MOVWF  FE9
04BE6:  MOVLW  00
04BE8:  ADDWFC x98,W
04BEA:  MOVWF  FEA
04BEC:  MOVFF  FEF,5C0
04BF0:  MOVFF  FEC,5C1
04BF4:  MOVFF  FEC,5C2
04BF8:  MOVFF  FEC,5C3
04BFC:  MOVLB  3
04BFE:  MOVF   x9C,W
04C00:  MOVLB  5
04C02:  SUBWF  xC3,W
04C04:  BNC   4C8E
04C06:  BNZ   4C2A
04C08:  MOVLB  3
04C0A:  MOVF   x9B,W
04C0C:  MOVLB  5
04C0E:  SUBWF  xC2,W
04C10:  BNC   4C8E
04C12:  BNZ   4C2A
04C14:  MOVLB  3
04C16:  MOVF   x9A,W
04C18:  MOVLB  5
04C1A:  SUBWF  xC1,W
04C1C:  BNC   4C8E
04C1E:  BNZ   4C2A
04C20:  MOVLB  3
04C22:  MOVF   x99,W
04C24:  MOVLB  5
04C26:  SUBWF  xC0,W
04C28:  BNC   4C8E
....................                      if(dealloc_clusters(addr_to_cluster(stream->Start_Addr)) == EOF) 
04C2A:  MOVLW  14
04C2C:  ADDWF  x97,W
04C2E:  MOVWF  FE9
04C30:  MOVLW  00
04C32:  ADDWFC x98,W
04C34:  MOVWF  FEA
04C36:  MOVFF  FEF,5C0
04C3A:  MOVFF  FEC,5C1
04C3E:  MOVFF  FEC,5C2
04C42:  MOVFF  FEC,5C3
04C46:  MOVFF  5C3,5E1
04C4A:  MOVFF  5C2,5E0
04C4E:  MOVFF  5C1,5DF
04C52:  MOVFF  5C0,5DE
04C56:  MOVLB  0
04C58:  CALL   31AA
04C5C:  MOVFF  03,5C3
04C60:  MOVFF  02,5C2
04C64:  MOVFF  01,5C1
04C68:  MOVFF  00,5C0
04C6C:  MOVFF  03,5C7
04C70:  MOVFF  02,5C6
04C74:  MOVFF  01,5C5
04C78:  MOVFF  00,5C4
04C7C:  GOTO   396E
04C80:  MOVF   01,W
04C82:  SUBLW  FF
04C84:  BNZ   4C90
....................                         return EOF; 
04C86:  MOVLW  FF
04C88:  MOVWF  01
04C8A:  MOVLB  5
04C8C:  BRA    4F72
04C8E:  MOVLB  0
....................                   stream->Cur_Char = 0; 
04C90:  MOVLW  04
04C92:  MOVLB  5
04C94:  ADDWF  x97,W
04C96:  MOVWF  FE9
04C98:  MOVLW  00
04C9A:  ADDWFC x98,W
04C9C:  MOVWF  FEA
04C9E:  MOVF   FEE,F
04CA0:  MOVF   FEE,F
04CA2:  CLRF   FEC
04CA4:  MOVF   FED,F
04CA6:  CLRF   FEF
04CA8:  MOVF   FED,F
04CAA:  CLRF   FEF
04CAC:  MOVF   FED,F
04CAE:  CLRF   FEF
....................                } 
....................  
....................                if((stream->Flags & Append) && (stream->Size != 0)) 
04CB0:  MOVLW  19
04CB2:  ADDWF  x97,W
04CB4:  MOVWF  FE9
04CB6:  MOVLW  00
04CB8:  ADDWFC x98,W
04CBA:  MOVWF  FEA
04CBC:  BTFSS  FEF.2
04CBE:  BRA    4E4E
04CC0:  MOVLW  10
04CC2:  ADDWF  x97,W
04CC4:  MOVWF  FE9
04CC6:  MOVLW  00
04CC8:  ADDWFC x98,W
04CCA:  MOVWF  FEA
04CCC:  MOVFF  FEF,5C0
04CD0:  MOVFF  FEC,5C1
04CD4:  MOVFF  FEC,5C2
04CD8:  MOVFF  FEC,5C3
04CDC:  MOVF   xC0,F
04CDE:  BNZ   4CEE
04CE0:  MOVF   xC1,F
04CE2:  BNZ   4CEE
04CE4:  MOVF   xC2,F
04CE6:  BNZ   4CEE
04CE8:  MOVF   xC3,F
04CEA:  BTFSC  FD8.2
04CEC:  BRA    4E4E
....................                { 
....................                   // set the position to the end of the file and fill the buffer with the contents of the end of the file 
....................                   ec = fatsetpos(stream, &(stream->Size)); 
04CEE:  MOVLW  10
04CF0:  ADDWF  x97,W
04CF2:  MOVWF  01
04CF4:  MOVLW  00
04CF6:  ADDWFC x98,W
04CF8:  MOVWF  03
04CFA:  MOVFF  01,5C0
04CFE:  MOVWF  xC1
04D00:  MOVFF  598,5C3
04D04:  MOVFF  597,5C2
04D08:  MOVWF  xC5
04D0A:  MOVFF  01,5C4
04D0E:  MOVLB  0
04D10:  GOTO   43B8
04D14:  MOVFF  01,59B
....................                   if(stream->Cur_Char % STREAM_BUF_SIZE == 0) 
04D18:  MOVLW  04
04D1A:  MOVLB  5
04D1C:  ADDWF  x97,W
04D1E:  MOVWF  FE9
04D20:  MOVLW  00
04D22:  ADDWFC x98,W
04D24:  MOVWF  FEA
04D26:  MOVFF  FEF,5C0
04D2A:  MOVFF  FEC,5C1
04D2E:  MOVFF  FEC,5C2
04D32:  MOVFF  FEC,5C3
04D36:  MOVLW  1F
04D38:  ANDWF  xC0,F
04D3A:  CLRF   xC1
04D3C:  CLRF   xC2
04D3E:  CLRF   xC3
04D40:  MOVF   xC0,F
04D42:  BNZ   4DBA
04D44:  MOVF   xC1,F
04D46:  BNZ   4DBA
04D48:  MOVF   xC2,F
04D4A:  BNZ   4DBA
04D4C:  MOVF   xC3,F
04D4E:  BNZ   4DBA
....................                      ec += mmcsd_read_data(stream->Cur_Char - STREAM_BUF_SIZE, STREAM_BUF_SIZE, stream->Buf); 
04D50:  MOVLW  04
04D52:  ADDWF  x97,W
04D54:  MOVWF  FE9
04D56:  MOVLW  00
04D58:  ADDWFC x98,W
04D5A:  MOVWF  FEA
04D5C:  MOVFF  FEF,5C0
04D60:  MOVFF  FEC,5C1
04D64:  MOVFF  FEC,5C2
04D68:  MOVFF  FEC,5C3
04D6C:  MOVLW  20
04D6E:  SUBWF  xC0,F
04D70:  MOVLW  00
04D72:  SUBWFB xC1,F
04D74:  SUBWFB xC2,F
04D76:  SUBWFB xC3,F
04D78:  MOVLW  1A
04D7A:  ADDWF  x97,W
04D7C:  MOVWF  01
04D7E:  MOVLW  00
04D80:  ADDWFC x98,W
04D82:  MOVWF  03
04D84:  MOVFF  01,5C4
04D88:  MOVWF  xC5
04D8A:  MOVFF  5C3,5FE
04D8E:  MOVFF  5C2,5FD
04D92:  MOVFF  5C1,5FC
04D96:  MOVFF  5C0,5FB
04D9A:  MOVLB  6
04D9C:  CLRF   x00
04D9E:  MOVLW  20
04DA0:  MOVLB  5
04DA2:  MOVWF  xFF
04DA4:  MOVFF  03,602
04DA8:  MOVFF  01,601
04DAC:  MOVLB  0
04DAE:  CALL   2B2E
04DB2:  MOVF   01,W
04DB4:  MOVLB  5
04DB6:  ADDWF  x9B,F
04DB8:  BRA    4E4E
....................                   else 
....................                      ec += mmcsd_read_data(stream->Cur_Char - (stream->Cur_Char % STREAM_BUF_SIZE), STREAM_BUF_SIZE, stream->Buf); 
04DBA:  MOVLW  04
04DBC:  ADDWF  x97,W
04DBE:  MOVWF  FE9
04DC0:  MOVLW  00
04DC2:  ADDWFC x98,W
04DC4:  MOVWF  FEA
04DC6:  MOVFF  FEF,5C0
04DCA:  MOVFF  FEC,5C1
04DCE:  MOVFF  FEC,5C2
04DD2:  MOVFF  FEC,5C3
04DD6:  MOVLW  04
04DD8:  ADDWF  x97,W
04DDA:  MOVWF  FE9
04DDC:  MOVLW  00
04DDE:  ADDWFC x98,W
04DE0:  MOVWF  FEA
04DE2:  MOVFF  FEF,5C4
04DE6:  MOVFF  FEC,5C5
04DEA:  MOVFF  FEC,5C6
04DEE:  MOVFF  FEC,5C7
04DF2:  MOVF   xC4,W
04DF4:  ANDLW  1F
04DF6:  MOVWF  00
04DF8:  CLRF   01
04DFA:  CLRF   02
04DFC:  CLRF   03
04DFE:  MOVF   00,W
04E00:  SUBWF  xC0,F
04E02:  MOVF   01,W
04E04:  SUBWFB xC1,F
04E06:  MOVF   02,W
04E08:  SUBWFB xC2,F
04E0A:  MOVF   03,W
04E0C:  SUBWFB xC3,F
04E0E:  MOVLW  1A
04E10:  ADDWF  x97,W
04E12:  MOVWF  01
04E14:  MOVLW  00
04E16:  ADDWFC x98,W
04E18:  MOVWF  03
04E1A:  MOVFF  01,5C4
04E1E:  MOVWF  xC5
04E20:  MOVFF  5C3,5FE
04E24:  MOVFF  5C2,5FD
04E28:  MOVFF  5C1,5FC
04E2C:  MOVFF  5C0,5FB
04E30:  MOVLB  6
04E32:  CLRF   x00
04E34:  MOVLW  20
04E36:  MOVLB  5
04E38:  MOVWF  xFF
04E3A:  MOVFF  03,602
04E3E:  MOVFF  01,601
04E42:  MOVLB  0
04E44:  CALL   2B2E
04E48:  MOVF   01,W
04E4A:  MOVLB  5
04E4C:  ADDWF  x9B,F
....................                } 
.................... #ifndef FAST_FAT 
....................                if(stream->Flags & Read) 
04E4E:  MOVLW  19
04E50:  ADDWF  x97,W
04E52:  MOVWF  FE9
04E54:  MOVLW  00
04E56:  ADDWFC x98,W
04E58:  MOVWF  FEA
04E5A:  BTFSS  FEF.0
04E5C:  BRA    4F00
....................                { 
....................                   stream->Cur_Char = stream->Start_Addr; 
04E5E:  MOVLW  04
04E60:  ADDWF  x97,W
04E62:  MOVWF  01
04E64:  MOVLW  00
04E66:  ADDWFC x98,W
04E68:  MOVWF  03
04E6A:  MOVFF  01,5C0
04E6E:  MOVWF  xC1
04E70:  MOVLW  14
04E72:  ADDWF  x97,W
04E74:  MOVWF  FE9
04E76:  MOVLW  00
04E78:  ADDWFC x98,W
04E7A:  MOVWF  FEA
04E7C:  MOVFF  FEF,00
04E80:  MOVFF  FEC,01
04E84:  MOVFF  FEC,02
04E88:  MOVFF  FEC,03
04E8C:  MOVFF  5C1,FEA
04E90:  MOVFF  5C0,FE9
04E94:  MOVFF  00,FEF
04E98:  MOVFF  01,FEC
04E9C:  MOVFF  02,FEC
04EA0:  MOVFF  03,FEC
....................  
....................                   // fill up the read buffer for reading 
....................                   ec = mmcsd_read_data(stream->Cur_Char, STREAM_BUF_SIZE, stream->Buf); 
04EA4:  MOVLW  04
04EA6:  ADDWF  x97,W
04EA8:  MOVWF  FE9
04EAA:  MOVLW  00
04EAC:  ADDWFC x98,W
04EAE:  MOVWF  FEA
04EB0:  MOVFF  FEF,5C0
04EB4:  MOVFF  FEC,5C1
04EB8:  MOVFF  FEC,5C2
04EBC:  MOVFF  FEC,5C3
04EC0:  MOVLW  1A
04EC2:  ADDWF  x97,W
04EC4:  MOVWF  01
04EC6:  MOVLW  00
04EC8:  ADDWFC x98,W
04ECA:  MOVWF  03
04ECC:  MOVFF  01,5C4
04ED0:  MOVWF  xC5
04ED2:  MOVFF  5C3,5FE
04ED6:  MOVFF  5C2,5FD
04EDA:  MOVFF  5C1,5FC
04EDE:  MOVFF  5C0,5FB
04EE2:  MOVLB  6
04EE4:  CLRF   x00
04EE6:  MOVLW  20
04EE8:  MOVLB  5
04EEA:  MOVWF  xFF
04EEC:  MOVFF  03,602
04EF0:  MOVFF  01,601
04EF4:  MOVLB  0
04EF6:  CALL   2B2E
04EFA:  MOVFF  01,59B
04EFE:  MOVLB  5
....................                } 
.................... #endif // #ifndef FAST_FAT 
....................                if(ec != GOODEC) 
04F00:  MOVF   x9B,F
04F02:  BZ    4F1C
....................                { 
....................                   stream->Flags |= Read_Error; 
04F04:  MOVLW  19
04F06:  ADDWF  x97,W
04F08:  MOVWF  FE9
04F0A:  MOVLW  00
04F0C:  ADDWFC x98,W
04F0E:  MOVWF  FEA
04F10:  MOVF   FEF,W
04F12:  IORLW  20
04F14:  MOVWF  FEF
....................                   return EOF; 
04F16:  MOVLW  FF
04F18:  MOVWF  01
04F1A:  BRA    4F72
....................                }                
....................             } 
04F1C:  BRA    4F2E
....................             else 
....................                stream->File_Type = Directory; 
04F1E:  MOVLW  18
04F20:  ADDWF  x97,W
04F22:  MOVWF  FE9
04F24:  MOVLW  00
04F26:  ADDWFC x98,W
04F28:  MOVWF  FEA
04F2A:  MOVLW  01
04F2C:  MOVWF  FEF
....................             return GOODEC; 
04F2E:  MOVLW  00
04F30:  MOVWF  01
04F32:  BRA    4F72
04F34:  MOVLB  0
....................          } 
....................       } 
....................  
....................       // check to make sure that the next iteration will give us a contiguous cluster 
....................       if(get_next_entry(&i) == EOF) 
04F36:  MOVLW  05
04F38:  MOVLB  5
04F3A:  MOVWF  xC1
04F3C:  MOVLW  9C
04F3E:  MOVWF  xC0
04F40:  MOVLB  0
04F42:  RCALL  47F0
04F44:  MOVF   01,W
04F46:  SUBLW  FF
04F48:  BNZ   4F54
....................          return EOF; 
04F4A:  MOVLW  FF
04F4C:  MOVWF  01
04F4E:  MOVLB  5
04F50:  BRA    4F72
04F52:  MOVLB  0
....................  
....................    } while(cur_state != 0x00); 
04F54:  MOVLB  5
04F56:  MOVF   x9A,F
04F58:  BTFSS  FD8.2
04F5A:  BRA    4872
....................  
....................    // if we reach this point, we know that the file won't be found 
....................    stream->Flags |= File_Not_Found; 
04F5C:  MOVLW  19
04F5E:  ADDWF  x97,W
04F60:  MOVWF  FE9
04F62:  MOVLW  00
04F64:  ADDWFC x98,W
04F66:  MOVWF  FEA
04F68:  MOVF   FEF,W
04F6A:  IORLW  80
04F6C:  MOVWF  FEF
....................    return EOF; 
04F6E:  MOVLW  FF
04F70:  MOVWF  01
04F72:  MOVLB  0
04F74:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_file_name(int32 file_entry_addr, char name[]) 
.................... Summary: This will get a name of a file. 
.................... Param file_entry_addr: The position in memory that the file's entry is. 
.................... Param name[]: The place to put the name of the file into. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_file_name(int32 file_entry_addr, char name[]) 
*
0359C:  MOVLB  5
0359E:  CLRF   xC7
.................... { 
....................    int 
....................       j,       // counter for loops 
....................       k = 0,   // current character in array 
....................       order,   // byte to hold the current long file name order 
....................       type;    // the type of entry that was just read in 
....................  
....................    int32 i;          // pointer for memory 
....................  
....................    // the long file name isn't fragmented across clusters 
....................    i = file_entry_addr; 
035A0:  MOVFF  5C3,5CD
035A4:  MOVFF  5C2,5CC
035A8:  MOVFF  5C1,5CB
035AC:  MOVFF  5C0,5CA
....................  
....................    // check to make sure that this file has a long file name 
....................    if(mmcsd_read_data(i - 0x15, 1, &type) != GOODEC) 
035B0:  MOVLW  15
035B2:  SUBWF  xCA,W
035B4:  MOVWF  xCE
035B6:  MOVLW  00
035B8:  SUBWFB xCB,W
035BA:  MOVWF  xCF
035BC:  MOVLW  00
035BE:  SUBWFB xCC,W
035C0:  MOVWF  xD0
035C2:  MOVLW  00
035C4:  SUBWFB xCD,W
035C6:  MOVWF  xD1
035C8:  MOVWF  xFE
035CA:  MOVFF  5D0,5FD
035CE:  MOVFF  5CF,5FC
035D2:  MOVFF  5CE,5FB
035D6:  MOVLB  6
035D8:  CLRF   x00
035DA:  MOVLW  01
035DC:  MOVLB  5
035DE:  MOVWF  xFF
035E0:  MOVLW  05
035E2:  MOVLB  6
035E4:  MOVWF  x02
035E6:  MOVLW  C9
035E8:  MOVWF  x01
035EA:  MOVLB  0
035EC:  CALL   2B2E
035F0:  MOVF   01,F
035F2:  BZ    35FA
....................       return EOF; 
035F4:  MOVLW  FF
035F6:  MOVWF  01
035F8:  BRA    3728
....................  
....................    if(type != 0x0F) 
035FA:  MOVLB  5
035FC:  MOVF   xC9,W
035FE:  SUBLW  0F
03600:  BZ    3636
....................    { 
....................       // this file doesn't have a long file name 
....................       if(get_short_file_name(i, name, type) == EOF) 
03602:  MOVFF  5CD,5D1
03606:  MOVFF  5CC,5D0
0360A:  MOVFF  5CB,5CF
0360E:  MOVFF  5CA,5CE
03612:  MOVFF  5C5,5D3
03616:  MOVFF  5C4,5D2
0361A:  MOVFF  5C9,5D4
0361E:  MOVLB  0
03620:  BRA    2FD6
03622:  MOVF   01,W
03624:  SUBLW  FF
03626:  BNZ   362E
....................          return EOF; 
03628:  MOVLW  FF
0362A:  MOVWF  01
0362C:  BRA    3728
....................       return GOODEC; 
0362E:  MOVLW  00
03630:  MOVWF  01
03632:  BRA    3728
03634:  MOVLB  5
....................    } 
....................  
....................    do 
....................    { 
....................       // head to the previous entry 
....................       if(get_prev_entry(&i) == EOF) 
03636:  MOVLW  05
03638:  MOVWF  xCF
0363A:  MOVLW  CA
0363C:  MOVWF  xCE
0363E:  MOVLB  0
03640:  BRA    353A
03642:  MOVF   01,W
03644:  SUBLW  FF
03646:  BNZ   364E
....................          return EOF; 
03648:  MOVLW  FF
0364A:  MOVWF  01
0364C:  BRA    3728
....................  
....................       for(j = 1; j < 0x20; j += 2, k += 1) 
0364E:  MOVLW  01
03650:  MOVLB  5
03652:  MOVWF  xC6
03654:  MOVF   xC6,W
03656:  SUBLW  1F
03658:  BNC   36DA
....................       { 
....................          if(j == 11) 
0365A:  MOVF   xC6,W
0365C:  SUBLW  0B
0365E:  BNZ   3666
....................             j = 14; 
03660:  MOVLW  0E
03662:  MOVWF  xC6
03664:  BRA    3670
....................          else if(j == 26) 
03666:  MOVF   xC6,W
03668:  SUBLW  1A
0366A:  BNZ   3670
....................             j = 28; 
0366C:  MOVLW  1C
0366E:  MOVWF  xC6
....................          if(mmcsd_read_data(j + i, 1, &(name[k])) != GOODEC) 
03670:  MOVF   xC6,W
03672:  ADDWF  xCA,W
03674:  MOVWF  xCE
03676:  MOVLW  00
03678:  ADDWFC xCB,W
0367A:  MOVWF  xCF
0367C:  MOVLW  00
0367E:  ADDWFC xCC,W
03680:  MOVWF  xD0
03682:  MOVLW  00
03684:  ADDWFC xCD,W
03686:  MOVWF  xD1
03688:  CLRF   03
0368A:  MOVF   xC7,W
0368C:  ADDWF  xC4,W
0368E:  MOVWF  01
03690:  MOVF   xC5,W
03692:  ADDWFC 03,F
03694:  MOVFF  01,5D2
03698:  MOVFF  03,5D3
0369C:  MOVFF  5D1,5FE
036A0:  MOVFF  5D0,5FD
036A4:  MOVFF  5CF,5FC
036A8:  MOVFF  5CE,5FB
036AC:  MOVLB  6
036AE:  CLRF   x00
036B0:  MOVLW  01
036B2:  MOVLB  5
036B4:  MOVWF  xFF
036B6:  MOVFF  03,602
036BA:  MOVFF  01,601
036BE:  MOVLB  0
036C0:  CALL   2B2E
036C4:  MOVF   01,F
036C6:  BZ    36CE
....................             return EOF; 
036C8:  MOVLW  FF
036CA:  MOVWF  01
036CC:  BRA    3728
036CE:  MOVLW  02
036D0:  MOVLB  5
036D2:  ADDWF  xC6,F
036D4:  MOVLW  01
036D6:  ADDWF  xC7,F
036D8:  BRA    3654
....................       } 
....................  
....................       // now that that's done with, get the entry's order 
....................       if(mmcsd_read_data(i, 1, &order) != GOODEC) 
036DA:  MOVFF  5CD,5FE
036DE:  MOVFF  5CC,5FD
036E2:  MOVFF  5CB,5FC
036E6:  MOVFF  5CA,5FB
036EA:  MOVLB  6
036EC:  CLRF   x00
036EE:  MOVLW  01
036F0:  MOVLB  5
036F2:  MOVWF  xFF
036F4:  MOVLW  05
036F6:  MOVLB  6
036F8:  MOVWF  x02
036FA:  MOVLW  C8
036FC:  MOVWF  x01
036FE:  MOVLB  0
03700:  CALL   2B2E
03704:  MOVF   01,F
03706:  BZ    370E
....................          return EOF; 
03708:  MOVLW  FF
0370A:  MOVWF  01
0370C:  BRA    3728
....................  
....................    } while(!(order & 0x40));  // the last entry will be 0b01xxxxxx 
0370E:  MOVLB  5
03710:  BTFSS  xC8.6
03712:  BRA    3636
....................  
....................    // end the name[] buffer with a \0 
....................    name[k] = '\0'; 
03714:  CLRF   03
03716:  MOVF   xC7,W
03718:  ADDWF  xC4,W
0371A:  MOVWF  FE9
0371C:  MOVF   xC5,W
0371E:  ADDWFC 03,W
03720:  MOVWF  FEA
03722:  CLRF   FEF
....................  
....................    return GOODEC; 
03724:  MOVLW  00
03726:  MOVWF  01
03728:  MOVLB  0
0372A:  GOTO   4932 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int set_file_name(int32 parent_dir_addr, int32 entry_addr, char name[]) 
.................... Summary: Creates both a short and long file name at the first free entry in a directory. 
.................... Param parent_dir_addr: The address of the parent directory to create the short file name in. 
.................... Param entry_addr: The address the function put the short file name entry. 
.................... Param name: The full file name. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int set_file_name(int32 parent_dir_addr, int32* entry_addr, char name[]) 
*
05AD0:  MOVLB  5
05AD2:  CLRF   x45
05AD4:  MOVLW  01
05AD6:  MOVWF  x68
.................... { 
....................    char sname[12];   // place to hold the short file name 
....................  
....................    signed int name_pos = 0;   // the current parse position of name[] 
....................  
....................    int 
....................       chksum,               // the long file name checksum 
....................       entire_entry[0x20],   // the entire entry to put write onto the media 
....................       entry_pos,            // the current position inside of entire_entry 
....................       long_entry = 1;       // the current long entry number we're on 
....................  
....................    int32 i;   // pointer to memory 
....................  
....................    // check for invalid characters 
....................    if(check_invalid_char(name) == EOF) 
05AD8:  MOVFF  538,56E
05ADC:  MOVFF  537,56D
05AE0:  MOVLB  0
05AE2:  GOTO   5246
05AE6:  MOVF   01,W
05AE8:  SUBLW  FF
05AEA:  BNZ   5AF2
....................       return EOF; 
05AEC:  MOVLW  FF
05AEE:  MOVWF  01
05AF0:  BRA    5DB0
....................  
....................    // make a short file name of this 
....................    if(make_short_file_name(parent_dir_addr, name, sname) == EOF) 
05AF2:  MOVFF  534,570
05AF6:  MOVFF  533,56F
05AFA:  MOVFF  532,56E
05AFE:  MOVFF  531,56D
05B02:  MOVFF  538,572
05B06:  MOVFF  537,571
05B0A:  MOVLW  05
05B0C:  MOVLB  5
05B0E:  MOVWF  x74
05B10:  MOVLW  39
05B12:  MOVWF  x73
05B14:  MOVLB  0
05B16:  BRA    53EC
05B18:  MOVF   01,W
05B1A:  SUBLW  FF
05B1C:  BNZ   5B24
....................       return EOF; 
05B1E:  MOVLW  FF
05B20:  MOVWF  01
05B22:  BRA    5DB0
....................  
....................    // get a checksum for the long file name entries 
....................    chksum = long_name_chksum(sname); 
05B24:  MOVLW  05
05B26:  MOVLB  5
05B28:  MOVWF  x6E
05B2A:  MOVLW  39
05B2C:  MOVWF  x6D
05B2E:  MOVLB  0
05B30:  BRA    5878
05B32:  MOVFF  01,546
....................  
....................    // start writing the long file name 
....................    // zero out entry[] 
....................    for(entry_pos = 0; entry_pos < 0x20; entry_pos += 1) 
05B36:  MOVLB  5
05B38:  CLRF   x67
05B3A:  MOVF   x67,W
05B3C:  SUBLW  1F
05B3E:  BNC   5B56
....................       entire_entry[entry_pos] = 0;    
05B40:  CLRF   03
05B42:  MOVF   x67,W
05B44:  ADDLW  47
05B46:  MOVWF  FE9
05B48:  MOVLW  05
05B4A:  ADDWFC 03,W
05B4C:  MOVWF  FEA
05B4E:  CLRF   FEF
05B50:  MOVLW  01
05B52:  ADDWF  x67,F
05B54:  BRA    5B3A
....................  
....................    i = parent_dir_addr; 
05B56:  MOVFF  534,56C
05B5A:  MOVFF  533,56B
05B5E:  MOVFF  532,56A
05B62:  MOVFF  531,569
....................    if(get_next_free_entry(&i) == EOF) 
05B66:  MOVLW  05
05B68:  MOVWF  x6E
05B6A:  MOVLW  69
05B6C:  MOVWF  x6D
05B6E:  MOVLB  0
05B70:  RCALL  58BE
05B72:  MOVF   01,W
05B74:  SUBLW  FF
05B76:  BNZ   5B7E
....................       return EOF; 
05B78:  MOVLW  FF
05B7A:  MOVWF  01
05B7C:  BRA    5DB0
....................  
....................    // 0x0F signifies an file entry 
....................    entire_entry[11] = 0x0F; 
05B7E:  MOVLW  0F
05B80:  MOVLB  5
05B82:  MOVWF  x52
....................  
....................    // since we're working in reverse, write the final long name entry 
....................    name_pos = strlen(name); 
05B84:  MOVFF  538,5D9
05B88:  MOVFF  537,5D8
05B8C:  MOVLB  0
05B8E:  CALL   2F9C
05B92:  MOVFF  01,545
....................    name_pos %= 13; 
05B96:  MOVFF  545,56D
05B9A:  MOVLW  0D
05B9C:  MOVLB  5
05B9E:  MOVWF  x6E
05BA0:  MOVLB  0
05BA2:  RCALL  59DA
05BA4:  MOVFF  00,545
....................  
....................    if(name_pos != 0) 
05BA8:  MOVLB  5
05BAA:  MOVF   x45,F
05BAC:  BZ    5BC6
....................    { 
....................       // add 1 to account for the \0 terminator 
....................       name_pos += 1; 
05BAE:  MOVLW  01
05BB0:  ADDWF  x45,F
....................  
....................       fill_entry(entire_entry, 0xFF, name_pos); 
05BB2:  MOVLW  05
05BB4:  MOVWF  x6E
05BB6:  MOVLW  47
05BB8:  MOVWF  x6D
05BBA:  SETF   x6F
05BBC:  MOVFF  545,570
05BC0:  MOVLB  0
05BC2:  RCALL  5A26
05BC4:  MOVLB  5
....................    } 
....................  
....................    // start writing the long file name entries 
....................    name_pos = strlen(name); 
05BC6:  MOVFF  538,5D9
05BCA:  MOVFF  537,5D8
05BCE:  MOVLB  0
05BD0:  CALL   2F9C
05BD4:  MOVFF  01,545
....................  
....................    // figure out how many entries this name will take up 
....................    long_entry = (name_pos / 13) + 1; 
05BD8:  MOVFF  545,56D
05BDC:  MOVLW  0D
05BDE:  MOVLB  5
05BE0:  MOVWF  x6E
05BE2:  MOVLB  0
05BE4:  RCALL  59DA
05BE6:  MOVLW  01
05BE8:  ADDWF  01,W
05BEA:  MOVLB  5
05BEC:  MOVWF  x68
....................  
....................    if(name_pos % 13 == 0) 
05BEE:  MOVFF  545,56D
05BF2:  MOVLW  0D
05BF4:  MOVWF  x6E
05BF6:  MOVLB  0
05BF8:  RCALL  59DA
05BFA:  MOVF   00,F
05BFC:  BNZ   5C06
....................       long_entry -= 1; 
05BFE:  MOVLW  01
05C00:  MOVLB  5
05C02:  SUBWF  x68,F
05C04:  MOVLB  0
....................  
....................    // set the bit to signify this is the final entry 
....................    long_entry |= 0x40; 
05C06:  MOVLB  5
05C08:  BSF    x68.6
....................  
....................    while(name_pos >= 0) 
05C0A:  BTFSC  x45.7
05C0C:  BRA    5D62
....................    { 
....................       entry_pos = name_pos % 13; 
05C0E:  MOVFF  545,56D
05C12:  MOVLW  0D
05C14:  MOVWF  x6E
05C16:  MOVLB  0
05C18:  RCALL  59DA
05C1A:  MOVFF  00,567
05C1E:  MOVLB  5
....................  
....................       if(entry_pos < 5) 
05C20:  MOVF   x67,W
05C22:  SUBLW  04
05C24:  BNC   5C5E
....................          entire_entry[(entry_pos << 1) + 1] = name[name_pos]; 
05C26:  BCF    FD8.0
05C28:  RLCF   x67,W
05C2A:  ADDLW  01
05C2C:  CLRF   03
05C2E:  ADDLW  47
05C30:  MOVWF  01
05C32:  MOVLW  05
05C34:  ADDWFC 03,F
05C36:  MOVFF  01,56D
05C3A:  MOVFF  03,56E
05C3E:  CLRF   03
05C40:  MOVF   x45,W
05C42:  ADDWF  x37,W
05C44:  MOVWF  FE9
05C46:  MOVF   x38,W
05C48:  ADDWFC 03,W
05C4A:  MOVWF  FEA
05C4C:  MOVFF  FEF,56F
05C50:  MOVFF  56E,FEA
05C54:  MOVFF  01,FE9
05C58:  MOVFF  56F,FEF
05C5C:  BRA    5CCE
....................  
....................       else if(entry_pos < 11) 
05C5E:  MOVF   x67,W
05C60:  SUBLW  0A
05C62:  BNC   5C9C
....................          entire_entry[(entry_pos << 1) + 4] = name[name_pos]; 
05C64:  BCF    FD8.0
05C66:  RLCF   x67,W
05C68:  ADDLW  04
05C6A:  CLRF   03
05C6C:  ADDLW  47
05C6E:  MOVWF  01
05C70:  MOVLW  05
05C72:  ADDWFC 03,F
05C74:  MOVFF  01,56D
05C78:  MOVFF  03,56E
05C7C:  CLRF   03
05C7E:  MOVF   x45,W
05C80:  ADDWF  x37,W
05C82:  MOVWF  FE9
05C84:  MOVF   x38,W
05C86:  ADDWFC 03,W
05C88:  MOVWF  FEA
05C8A:  MOVFF  FEF,56F
05C8E:  MOVFF  56E,FEA
05C92:  MOVFF  01,FE9
05C96:  MOVFF  56F,FEF
05C9A:  BRA    5CCE
....................  
....................       else 
....................          entire_entry[(entry_pos << 1) + 6] = name[name_pos]; 
05C9C:  BCF    FD8.0
05C9E:  RLCF   x67,W
05CA0:  ADDLW  06
05CA2:  CLRF   03
05CA4:  ADDLW  47
05CA6:  MOVWF  01
05CA8:  MOVLW  05
05CAA:  ADDWFC 03,F
05CAC:  MOVFF  03,56E
05CB0:  CLRF   03
05CB2:  MOVF   x45,W
05CB4:  ADDWF  x37,W
05CB6:  MOVWF  FE9
05CB8:  MOVF   x38,W
05CBA:  ADDWFC 03,W
05CBC:  MOVWF  FEA
05CBE:  MOVFF  FEF,56F
05CC2:  MOVFF  56E,FEA
05CC6:  MOVFF  01,FE9
05CCA:  MOVFF  56F,FEF
....................  
....................       if((entry_pos == 0) 
....................          && (name_pos != strlen (name))) 
05CCE:  MOVF   x67,F
05CD0:  BTFSS  FD8.2
05CD2:  BRA    5D5C
05CD4:  MOVFF  538,5D9
05CD8:  MOVFF  537,5D8
05CDC:  MOVLB  0
05CDE:  CALL   2F9C
05CE2:  MOVF   01,W
05CE4:  MOVLB  5
05CE6:  SUBWF  x45,W
05CE8:  BZ    5D5C
....................       { 
....................          entire_entry[0] = long_entry; 
05CEA:  MOVFF  568,547
....................  
....................          // clear off the bits at positions 6 and 7 if the most recent entry was the final one. 
....................          if(name_pos != 0) 
05CEE:  MOVF   x45,F
05CF0:  BZ    5CF6
....................             long_entry &= 0x3F; 
05CF2:  MOVLW  3F
05CF4:  ANDWF  x68,F
....................  
....................          long_entry -= 1; 
05CF6:  MOVLW  01
05CF8:  SUBWF  x68,F
....................  
....................          entire_entry[13] = chksum; 
05CFA:  MOVFF  546,554
....................          if(mmcsd_write_data(i, 0x20, entire_entry) != GOODEC) 
05CFE:  MOVFF  56C,617
05D02:  MOVFF  56B,616
05D06:  MOVFF  56A,615
05D0A:  MOVFF  569,614
05D0E:  MOVLB  6
05D10:  CLRF   x19
05D12:  MOVLW  20
05D14:  MOVWF  x18
05D16:  MOVLW  05
05D18:  MOVWF  x1B
05D1A:  MOVLW  47
05D1C:  MOVWF  x1A
05D1E:  MOVLB  0
05D20:  CALL   3874
05D24:  MOVF   01,F
05D26:  BZ    5D2E
....................             return EOF; 
05D28:  MOVLW  FF
05D2A:  MOVWF  01
05D2C:  BRA    5DB0
....................          if(get_next_free_entry(&i) == EOF) 
05D2E:  MOVLW  05
05D30:  MOVLB  5
05D32:  MOVWF  x6E
05D34:  MOVLW  69
05D36:  MOVWF  x6D
05D38:  MOVLB  0
05D3A:  RCALL  58BE
05D3C:  MOVF   01,W
05D3E:  SUBLW  FF
05D40:  BNZ   5D48
....................             return EOF; 
05D42:  MOVLW  FF
05D44:  MOVWF  01
05D46:  BRA    5DB0
....................          fill_entry(entire_entry, 0x00, 0); 
05D48:  MOVLW  05
05D4A:  MOVLB  5
05D4C:  MOVWF  x6E
05D4E:  MOVLW  47
05D50:  MOVWF  x6D
05D52:  CLRF   x6F
05D54:  CLRF   x70
05D56:  MOVLB  0
05D58:  RCALL  5A26
05D5A:  MOVLB  5
....................       } 
....................       name_pos -= 1; 
05D5C:  MOVLW  01
05D5E:  SUBWF  x45,F
05D60:  BRA    5C0A
....................    } 
....................  
....................    // write the short file name to the entry 
....................    if(mmcsd_write_data(i, 11, sname) != GOODEC) 
05D62:  MOVFF  56C,617
05D66:  MOVFF  56B,616
05D6A:  MOVFF  56A,615
05D6E:  MOVFF  569,614
05D72:  MOVLB  6
05D74:  CLRF   x19
05D76:  MOVLW  0B
05D78:  MOVWF  x18
05D7A:  MOVLW  05
05D7C:  MOVWF  x1B
05D7E:  MOVLW  39
05D80:  MOVWF  x1A
05D82:  MOVLB  0
05D84:  CALL   3874
05D88:  MOVF   01,F
05D8A:  BZ    5D92
....................       return EOF; 
05D8C:  MOVLW  FF
05D8E:  MOVWF  01
05D90:  BRA    5DB0
....................  
....................    // set the new entry addr 
....................    *entry_addr = i; 
05D92:  MOVLB  5
05D94:  MOVFF  535,FE9
05D98:  MOVFF  536,FEA
05D9C:  MOVFF  569,FEF
05DA0:  MOVFF  56A,FEC
05DA4:  MOVFF  56B,FEC
05DA8:  MOVFF  56C,FEC
....................  
....................    return GOODEC; 
05DAC:  MOVLW  00
05DAE:  MOVWF  01
05DB0:  MOVLB  0
05DB2:  GOTO   5EB8 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_short_file_name(int32 file_entry_addr, char sname[], int type) 
.................... Summary: Reads a file's short file name, puts all the characters into lower case, and puts it into a buffer. 
.................... Param file_entry_addr: Where the file's entry address is located. 
.................... Param sname: The buffer to put the short file name. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_short_file_name(int32 file_entry_addr, char sname[], int type) 
*
02FD6:  MOVLB  5
02FD8:  CLRF   xD7
.................... { 
....................    int 
....................       buf, 
....................       i, 
....................       j = 0; 
....................  
....................    // one short file name has, at the most, 11 characters 
....................    for(i = 0; i < 11; i += 1) 
02FDA:  CLRF   xD6
02FDC:  MOVF   xD6,W
02FDE:  SUBLW  0A
02FE0:  BNC   3060
....................    {       
....................       // read in a character 
....................       if(mmcsd_read_data(i + file_entry_addr, 1, &buf) != GOODEC) 
02FE2:  MOVF   xD6,W
02FE4:  ADDWF  xCE,W
02FE6:  MOVWF  xD8
02FE8:  MOVLW  00
02FEA:  ADDWFC xCF,W
02FEC:  MOVWF  xD9
02FEE:  MOVLW  00
02FF0:  ADDWFC xD0,W
02FF2:  MOVWF  xDA
02FF4:  MOVLW  00
02FF6:  ADDWFC xD1,W
02FF8:  MOVWF  xDB
02FFA:  MOVWF  xFE
02FFC:  MOVFF  5DA,5FD
03000:  MOVFF  5D9,5FC
03004:  MOVFF  5D8,5FB
03008:  MOVLB  6
0300A:  CLRF   x00
0300C:  MOVLW  01
0300E:  MOVLB  5
03010:  MOVWF  xFF
03012:  MOVLW  05
03014:  MOVLB  6
03016:  MOVWF  x02
03018:  MOVLW  D5
0301A:  MOVWF  x01
0301C:  MOVLB  0
0301E:  RCALL  2B2E
03020:  MOVF   01,F
03022:  BZ    302A
....................          return EOF; 
03024:  MOVLW  FF
03026:  MOVWF  01
03028:  BRA    3110
....................        
....................       // convert the character 
....................       if(buf != ' ') 
0302A:  MOVLB  5
0302C:  MOVF   xD5,W
0302E:  SUBLW  20
03030:  BZ    305A
....................       {          
....................          sname[j] = tolower(buf); 
03032:  CLRF   03
03034:  MOVF   xD7,W
03036:  ADDWF  xD2,W
03038:  MOVWF  FE9
0303A:  MOVF   xD3,W
0303C:  ADDWFC 03,W
0303E:  MOVWF  FEA
03040:  MOVF   xD5,W
03042:  SUBLW  40
03044:  BC    3052
03046:  MOVF   xD5,W
03048:  SUBLW  5A
0304A:  BNC   3052
0304C:  MOVF   xD5,W
0304E:  IORLW  20
03050:  BRA    3054
03052:  MOVF   xD5,W
03054:  MOVWF  FEF
....................          j += 1; 
03056:  MOVLW  01
03058:  ADDWF  xD7,F
....................       } 
0305A:  MOVLW  01
0305C:  ADDWF  xD6,F
0305E:  BRA    2FDC
....................        
....................    }    
....................  
....................    // tack on a null terminator 
....................    sname[j] = '\0'; 
03060:  CLRF   03
03062:  MOVF   xD7,W
03064:  ADDWF  xD2,W
03066:  MOVWF  FE9
03068:  MOVF   xD3,W
0306A:  ADDWFC 03,W
0306C:  MOVWF  FEA
0306E:  CLRF   FEF
....................     
....................    //printf("\r\n%s, %u\r\n",sname, strlen(sname)); 
....................  
....................    if(type != 0x10 && strlen(sname) > 3) 
03070:  MOVF   xD4,W
03072:  SUBLW  10
03074:  BZ    30FA
03076:  MOVFF  5D3,5D9
0307A:  MOVFF  5D2,5D8
0307E:  MOVLB  0
03080:  RCALL  2F9C
03082:  MOVF   01,W
03084:  SUBLW  03
03086:  BTFSS  FD8.0
03088:  BRA    308E
0308A:  MOVLB  5
0308C:  BRA    30FA
....................    { 
....................       j = strlen(sname); 
0308E:  MOVFF  5D3,5D9
03092:  MOVFF  5D2,5D8
03096:  RCALL  2F9C
03098:  MOVFF  01,5D7
....................       for(i=j; i > j-3; --i) 
0309C:  MOVFF  5D7,5D6
030A0:  MOVLW  03
030A2:  MOVLB  5
030A4:  SUBWF  xD7,W
030A6:  SUBWF  xD6,W
030A8:  BZ    30E8
030AA:  BNC   30E8
....................          sname[i] = sname[i-1]; 
030AC:  CLRF   03
030AE:  MOVF   xD6,W
030B0:  ADDWF  xD2,W
030B2:  MOVWF  01
030B4:  MOVF   xD3,W
030B6:  ADDWFC 03,F
030B8:  MOVFF  01,5D8
030BC:  MOVFF  03,5D9
030C0:  MOVLW  01
030C2:  SUBWF  xD6,W
030C4:  CLRF   03
030C6:  ADDWF  xD2,W
030C8:  MOVWF  FE9
030CA:  MOVF   xD3,W
030CC:  ADDWFC 03,W
030CE:  MOVWF  FEA
030D0:  MOVFF  FEF,5DA
030D4:  MOVFF  5D9,FEA
030D8:  MOVFF  01,FE9
030DC:  MOVFF  5DA,FEF
030E0:  DECF   xD6,F
030E2:  MOVLB  0
030E4:  BRA    30A0
030E6:  MOVLB  5
....................       sname[i] = '.'; 
030E8:  CLRF   03
030EA:  MOVF   xD6,W
030EC:  ADDWF  xD2,W
030EE:  MOVWF  FE9
030F0:  MOVF   xD3,W
030F2:  ADDWFC 03,W
030F4:  MOVWF  FEA
030F6:  MOVLW  2E
030F8:  MOVWF  FEF
....................    } 
....................     
....................    sname[j+1] = '\0'; 
030FA:  MOVLW  01
030FC:  ADDWF  xD7,W
030FE:  CLRF   03
03100:  ADDWF  xD2,W
03102:  MOVWF  FE9
03104:  MOVF   xD3,W
03106:  ADDWFC 03,W
03108:  MOVWF  FEA
0310A:  CLRF   FEF
....................  
....................    return GOODEC; 
0310C:  MOVLW  00
0310E:  MOVWF  01
03110:  MOVLB  0
03112:  GOTO   3622 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int make_short_file_name(int32 parent_dir_addr, char fname[], char sname[]) 
.................... Summary: Creates a unique short file name in a directory. 
.................... Param parent_dir_addr: The address of the parent directory to create the short file name in. 
.................... Param fname: The full file name. 
.................... Param sname: Character array that will hold the short file name upon function completion. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int make_short_file_name(int32 parent_dir_addr, char fname[], char sname[]) 
*
0542E:  CLRF   x96
05430:  CLRF   x97
05432:  CLRF   x9B
05434:  CLRF   x9A
05436:  CLRF   x99
05438:  CLRF   x98
.................... { 
....................    char 
....................       val[12] = "           ", 
*
053EC:  MOVLW  20
053EE:  MOVLB  5
053F0:  MOVWF  x75
053F2:  MOVWF  x76
053F4:  MOVWF  x77
053F6:  MOVWF  x78
053F8:  MOVWF  x79
053FA:  MOVWF  x7A
053FC:  MOVWF  x7B
053FE:  MOVWF  x7C
05400:  MOVWF  x7D
05402:  MOVWF  x7E
05404:  MOVWF  x7F
05406:  CLRF   x80
....................       cur_fname[12] = "           ", 
05408:  MOVWF  x81
0540A:  MOVWF  x82
0540C:  MOVWF  x83
0540E:  MOVWF  x84
05410:  MOVWF  x85
05412:  MOVWF  x86
05414:  MOVWF  x87
05416:  MOVWF  x88
05418:  MOVWF  x89
0541A:  MOVWF  x8A
0541C:  MOVWF  x8B
0541E:  CLRF   x8C
....................       cur_fnum[7] = "      "; 
05420:  MOVWF  x8D
05422:  MOVWF  x8E
05424:  MOVWF  x8F
05426:  MOVWF  x90
05428:  MOVWF  x91
0542A:  MOVWF  x92
0542C:  CLRF   x93
....................  
....................    int 
....................       buf, 
....................       ext_pos, 
....................       fname_parse_pos = 0, 
....................       val_parse_pos = 0; 
....................  
....................    int32 
....................       fnum = 0, 
....................       i; 
....................  
....................    // figure out where the extension position is 
....................    ext_pos = strchr(fname, '.'); 
*
0543A:  MOVFF  572,5A1
0543E:  MOVFF  571,5A0
05442:  MOVLW  2E
05444:  MOVWF  xA2
05446:  MOVLB  0
05448:  RCALL  52C0
0544A:  MOVFF  01,595
....................  
....................    // check to see if this file has an extension 
....................    if(ext_pos == 0) 
0544E:  MOVLB  5
05450:  MOVF   x95,F
05452:  BNZ   54E8
....................    { 
....................       while((val_parse_pos < 8) && (fname[fname_parse_pos] != '\0')) 
05454:  MOVF   x97,W
05456:  SUBLW  07
05458:  BNC   54E6
0545A:  CLRF   03
0545C:  MOVF   x96,W
0545E:  ADDWF  x71,W
05460:  MOVWF  FE9
05462:  MOVF   x72,W
05464:  ADDWFC 03,W
05466:  MOVWF  FEA
05468:  MOVF   FEF,F
0546A:  BZ    54E6
....................       { 
....................          val[val_parse_pos] = toupper(fname[fname_parse_pos]); 
0546C:  CLRF   03
0546E:  MOVF   x97,W
05470:  ADDLW  75
05472:  MOVWF  01
05474:  MOVLW  05
05476:  ADDWFC 03,F
05478:  MOVFF  01,5A0
0547C:  MOVFF  03,5A1
05480:  CLRF   03
05482:  MOVF   x96,W
05484:  ADDWF  x71,W
05486:  MOVWF  FE9
05488:  MOVF   x72,W
0548A:  ADDWFC 03,W
0548C:  MOVWF  FEA
0548E:  MOVFF  FEF,5A2
05492:  MOVF   xA2,W
05494:  SUBLW  60
05496:  BC    54A4
05498:  MOVF   xA2,W
0549A:  SUBLW  7A
0549C:  BNC   54A4
0549E:  MOVF   xA2,W
054A0:  ANDLW  DF
054A2:  BRA    54A6
054A4:  MOVF   xA2,W
054A6:  MOVFF  5A1,FEA
054AA:  MOVFF  5A0,FE9
054AE:  MOVWF  FEF
....................          val_parse_pos += 1; 
054B0:  MOVLW  01
054B2:  ADDWF  x97,F
....................          fname_parse_pos += 1; 
054B4:  ADDWF  x96,F
....................  
....................          // we can't have a '.' or ' ' in the short name 
....................          while((fname[fname_parse_pos] == '.') || (fname[fname_parse_pos] == ' ')) 
054B6:  CLRF   03
054B8:  MOVF   x96,W
054BA:  ADDWF  x71,W
054BC:  MOVWF  FE9
054BE:  MOVF   x72,W
054C0:  ADDWFC 03,W
054C2:  MOVWF  FEA
054C4:  MOVF   FEF,W
054C6:  SUBLW  2E
054C8:  BZ    54DE
054CA:  CLRF   03
054CC:  MOVF   x96,W
054CE:  ADDWF  x71,W
054D0:  MOVWF  FE9
054D2:  MOVF   x72,W
054D4:  ADDWFC 03,W
054D6:  MOVWF  FEA
054D8:  MOVF   FEF,W
054DA:  SUBLW  20
054DC:  BNZ   54E4
....................             fname_parse_pos += 1; 
054DE:  MOVLW  01
054E0:  ADDWF  x96,F
054E2:  BRA    54B6
054E4:  BRA    5454
....................       } 
....................    } 
054E6:  BRA    559E
....................    else 
....................    { 
....................       ext_pos -= fname - 1; 
054E8:  MOVLW  01
054EA:  SUBWF  x71,W
054EC:  MOVWF  00
054EE:  MOVLW  00
054F0:  SUBWFB x72,W
054F2:  MOVF   00,W
054F4:  SUBWF  x95,F
....................       while((val_parse_pos < 11) && (fname[fname_parse_pos] != '\0')) 
054F6:  MOVF   x97,W
054F8:  SUBLW  0A
054FA:  BNC   559E
054FC:  CLRF   03
054FE:  MOVF   x96,W
05500:  ADDWF  x71,W
05502:  MOVWF  FE9
05504:  MOVF   x72,W
05506:  ADDWFC 03,W
05508:  MOVWF  FEA
0550A:  MOVF   FEF,F
0550C:  BZ    559E
....................       { 
....................          val[val_parse_pos] = toupper(fname[fname_parse_pos]); 
0550E:  CLRF   03
05510:  MOVF   x97,W
05512:  ADDLW  75
05514:  MOVWF  01
05516:  MOVLW  05
05518:  ADDWFC 03,F
0551A:  MOVFF  01,5A0
0551E:  MOVFF  03,5A1
05522:  CLRF   03
05524:  MOVF   x96,W
05526:  ADDWF  x71,W
05528:  MOVWF  FE9
0552A:  MOVF   x72,W
0552C:  ADDWFC 03,W
0552E:  MOVWF  FEA
05530:  MOVFF  FEF,5A2
05534:  MOVF   xA2,W
05536:  SUBLW  60
05538:  BC    5546
0553A:  MOVF   xA2,W
0553C:  SUBLW  7A
0553E:  BNC   5546
05540:  MOVF   xA2,W
05542:  ANDLW  DF
05544:  BRA    5548
05546:  MOVF   xA2,W
05548:  MOVFF  5A1,FEA
0554C:  MOVFF  5A0,FE9
05550:  MOVWF  FEF
....................          val_parse_pos += 1; 
05552:  MOVLW  01
05554:  ADDWF  x97,F
....................          fname_parse_pos += 1; 
05556:  ADDWF  x96,F
....................  
....................          // we can't have a '.' or ' ' in the short name 
....................          while((fname[fname_parse_pos] == '.') || (fname[fname_parse_pos] == ' ')) 
05558:  CLRF   03
0555A:  MOVF   x96,W
0555C:  ADDWF  x71,W
0555E:  MOVWF  FE9
05560:  MOVF   x72,W
05562:  ADDWFC 03,W
05564:  MOVWF  FEA
05566:  MOVF   FEF,W
05568:  SUBLW  2E
0556A:  BZ    5580
0556C:  CLRF   03
0556E:  MOVF   x96,W
05570:  ADDWF  x71,W
05572:  MOVWF  FE9
05574:  MOVF   x72,W
05576:  ADDWFC 03,W
05578:  MOVWF  FEA
0557A:  MOVF   FEF,W
0557C:  SUBLW  20
0557E:  BNZ   5586
....................             fname_parse_pos += 1; 
05580:  MOVLW  01
05582:  ADDWF  x96,F
05584:  BRA    5558
....................  
....................          // check to see if it's time to skip val_parse_pos ahead to the file extension 
....................          if(fname_parse_pos == ext_pos) 
05586:  MOVF   x95,W
05588:  SUBWF  x96,W
0558A:  BNZ   5592
....................             val_parse_pos = 8; 
0558C:  MOVLW  08
0558E:  MOVWF  x97
05590:  BRA    559C
....................  
....................          // check to see if it's time to skip name_parse_pos ahead to the file extension 
....................          else if(val_parse_pos == 8) 
05592:  MOVF   x97,W
05594:  SUBLW  08
05596:  BNZ   559C
....................             fname_parse_pos = ext_pos; 
05598:  MOVFF  595,596
0559C:  BRA    54F6
....................       } 
....................    } 
....................  
....................    // now that we've got the short file name, we need to make it unique 
....................    i = parent_dir_addr; 
0559E:  MOVFF  570,59F
055A2:  MOVFF  56F,59E
055A6:  MOVFF  56E,59D
055AA:  MOVFF  56D,59C
....................    if(mmcsd_read_data(i + 0x0B, 1, &buf) != GOODEC) 
055AE:  MOVLW  0B
055B0:  ADDWF  x9C,W
055B2:  MOVWF  xA0
055B4:  MOVLW  00
055B6:  ADDWFC x9D,W
055B8:  MOVWF  xA1
055BA:  MOVLW  00
055BC:  ADDWFC x9E,W
055BE:  MOVWF  xA2
055C0:  MOVLW  00
055C2:  ADDWFC x9F,W
055C4:  MOVWF  xA3
055C6:  MOVWF  xFE
055C8:  MOVFF  5A2,5FD
055CC:  MOVFF  5A1,5FC
055D0:  MOVFF  5A0,5FB
055D4:  MOVLB  6
055D6:  CLRF   x00
055D8:  MOVLW  01
055DA:  MOVLB  5
055DC:  MOVWF  xFF
055DE:  MOVLW  05
055E0:  MOVLB  6
055E2:  MOVWF  x02
055E4:  MOVLW  94
055E6:  MOVWF  x01
055E8:  MOVLB  0
055EA:  CALL   2B2E
055EE:  MOVF   01,F
055F0:  BZ    55F8
....................       return EOF; 
055F2:  MOVLW  FF
055F4:  MOVWF  01
055F6:  BRA    5872
....................  
....................    // keep reading until we hit empty space 
....................    while(buf != 0x00) 
055F8:  MOVLB  5
055FA:  MOVF   x94,F
055FC:  BTFSC  FD8.2
055FE:  BRA    5818
....................    { 
....................       // check to see if this is a short file name entry 
....................       if((buf == 0x20) || (buf == 0x10)) 
05600:  MOVF   x94,W
05602:  SUBLW  20
05604:  BZ    560E
05606:  MOVF   x94,W
05608:  SUBLW  10
0560A:  BTFSS  FD8.2
0560C:  BRA    5760
....................       { 
....................          // read in the short file name that we're currently pointing at 
....................          if(mmcsd_read_data(i, 11, cur_fname) != GOODEC) 
0560E:  MOVFF  59F,5FE
05612:  MOVFF  59E,5FD
05616:  MOVFF  59D,5FC
0561A:  MOVFF  59C,5FB
0561E:  MOVLB  6
05620:  CLRF   x00
05622:  MOVLW  0B
05624:  MOVLB  5
05626:  MOVWF  xFF
05628:  MOVLW  05
0562A:  MOVLB  6
0562C:  MOVWF  x02
0562E:  MOVLW  81
05630:  MOVWF  x01
05632:  MOVLB  0
05634:  CALL   2B2E
05638:  MOVF   01,F
0563A:  BZ    5642
....................             return EOF; 
0563C:  MOVLW  FF
0563E:  MOVWF  01
05640:  BRA    5872
....................  
....................          cur_fname[11] = '\0'; 
05642:  MOVLB  5
05644:  CLRF   x8C
....................  
....................          // strcmp will return a 0 if the file name we're currently pointing at and the file name that we created above are the same 
....................          if(strcmp(cur_fname, val) == 0) 
05646:  MOVLW  05
05648:  MOVWF  xC1
0564A:  MOVLW  81
0564C:  MOVWF  xC0
0564E:  MOVLW  05
05650:  MOVWF  xC3
05652:  MOVLW  75
05654:  MOVWF  xC2
05656:  MOVLB  0
05658:  CALL   372E
0565C:  MOVF   01,F
0565E:  BTFSS  FD8.2
05660:  BRA    5762
....................          { 
....................             // we now need to create a unique file name 
....................             //  increment the unique file number by one 
....................             fnum += 1; 
05662:  MOVLW  01
05664:  MOVLB  5
05666:  ADDWF  x98,F
05668:  MOVLW  00
0566A:  ADDWFC x99,F
0566C:  ADDWFC x9A,F
0566E:  ADDWFC x9B,F
....................  
....................             // convert the unique file number to a string 
....................             sprintf(cur_fnum, "%lu", fnum); 
05670:  MOVLW  05
05672:  MOVLB  3
05674:  MOVWF  xAA
05676:  MOVLW  8D
05678:  MOVWF  xA9
0567A:  MOVLW  41
0567C:  MOVWF  FE9
0567E:  MOVFF  59B,5A3
05682:  MOVFF  59A,5A2
05686:  MOVFF  599,5A1
0568A:  MOVFF  598,5A0
0568E:  MOVLB  0
05690:  BRA    5328
....................  
....................             // put the unique file number, along with a '~' into our short file name 
....................             fname_parse_pos = 0; 
05692:  MOVLB  5
05694:  CLRF   x96
....................  
....................             // find out the last posiiton of a space 
....................             val_parse_pos = strchr(val, ' '); 
05696:  MOVLW  05
05698:  MOVWF  xA1
0569A:  MOVLW  75
0569C:  MOVWF  xA0
0569E:  MOVLW  20
056A0:  MOVWF  xA2
056A2:  MOVLB  0
056A4:  RCALL  52C0
056A6:  MOVFF  01,597
....................             if(val_parse_pos == 0) 
056AA:  MOVLB  5
056AC:  MOVF   x97,F
056AE:  BNZ   56CA
....................                // if there isn't a space, then we're going to have to put the ~x at the end of the short name 
....................                val_parse_pos = 7 - strlen(cur_fnum); 
056B0:  MOVLW  05
056B2:  MOVWF  xD9
056B4:  MOVLW  8D
056B6:  MOVWF  xD8
056B8:  MOVLB  0
056BA:  CALL   2F9C
056BE:  MOVLW  07
056C0:  BSF    FD8.0
056C2:  SUBFWB 01,W
056C4:  MOVLB  5
056C6:  MOVWF  x97
056C8:  BRA    56CE
....................             else 
....................                // if there is a space, then put the ~x there 
....................                val_parse_pos -= val + 2; 
056CA:  MOVLW  77
056CC:  SUBWF  x97,F
....................  
....................             // make some room for extra digits 
....................             buf = 10; 
056CE:  MOVLW  0A
056D0:  MOVWF  x94
....................             while(fnum >= buf) 
056D2:  MOVF   x9B,F
056D4:  BNZ   56E4
056D6:  MOVF   x9A,F
056D8:  BNZ   56E4
056DA:  MOVF   x99,F
056DC:  BNZ   56E4
056DE:  MOVF   x94,W
056E0:  SUBWF  x98,W
056E2:  BNC   56F2
....................             { 
....................                val_parse_pos -= 1; 
056E4:  MOVLW  01
056E6:  SUBWF  x97,F
....................                buf *= 10; 
056E8:  MOVF   x94,W
056EA:  MULLW  0A
056EC:  MOVFF  FF3,594
056F0:  BRA    56D2
....................             } 
....................  
....................             // write in the ~ 
....................             val[val_parse_pos] = '~'; 
056F2:  CLRF   03
056F4:  MOVF   x97,W
056F6:  ADDLW  75
056F8:  MOVWF  FE9
056FA:  MOVLW  05
056FC:  ADDWFC 03,W
056FE:  MOVWF  FEA
05700:  MOVLW  7E
05702:  MOVWF  FEF
....................  
....................             // write in the number 
....................             val_parse_pos += 1; 
05704:  MOVLW  01
05706:  ADDWF  x97,F
....................             while(cur_fnum[fname_parse_pos] != '\0') 
05708:  CLRF   03
0570A:  MOVF   x96,W
0570C:  ADDLW  8D
0570E:  MOVWF  FE9
05710:  MOVLW  05
05712:  ADDWFC 03,W
05714:  MOVWF  FEA
05716:  MOVF   FEF,F
05718:  BZ    5750
....................             { 
....................                val[val_parse_pos] = cur_fnum[fname_parse_pos]; 
0571A:  CLRF   03
0571C:  MOVF   x97,W
0571E:  ADDLW  75
05720:  MOVWF  01
05722:  MOVLW  05
05724:  ADDWFC 03,F
05726:  MOVFF  03,5A1
0572A:  CLRF   03
0572C:  MOVF   x96,W
0572E:  ADDLW  8D
05730:  MOVWF  FE9
05732:  MOVLW  05
05734:  ADDWFC 03,W
05736:  MOVWF  FEA
05738:  MOVFF  FEF,5A2
0573C:  MOVFF  5A1,FEA
05740:  MOVFF  01,FE9
05744:  MOVFF  5A2,FEF
....................                val_parse_pos += 1; 
05748:  MOVLW  01
0574A:  ADDWF  x97,F
....................                fname_parse_pos += 1; 
0574C:  ADDWF  x96,F
0574E:  BRA    5708
....................             } 
....................  
....................             // start the search over again to see if that unique file name/number combination is still taken up 
....................             i = parent_dir_addr; 
05750:  MOVFF  570,59F
05754:  MOVFF  56F,59E
05758:  MOVFF  56E,59D
0575C:  MOVFF  56D,59C
05760:  MOVLB  0
....................          } 
....................       } 
....................  
....................       // head to the next entry 
....................       if(get_next_entry(&i) == EOF) 
05762:  MOVLW  05
05764:  MOVLB  5
05766:  MOVWF  xC1
05768:  MOVLW  9C
0576A:  MOVWF  xC0
0576C:  MOVLB  0
0576E:  CALL   47F0
05772:  MOVF   01,W
05774:  SUBLW  FF
05776:  BNZ   57C8
....................       { 
....................          // we're going to have to allocate another cluster 
....................          if(alloc_clusters(addr_to_cluster(i), &i) == EOF) 
05778:  MOVFF  59F,5E1
0577C:  MOVFF  59E,5E0
05780:  MOVFF  59D,5DF
05784:  MOVFF  59C,5DE
05788:  CALL   31AA
0578C:  MOVFF  03,5A3
05790:  MOVFF  02,5A2
05794:  MOVFF  01,5A1
05798:  MOVFF  00,5A0
0579C:  MOVFF  03,5DA
057A0:  MOVFF  02,5D9
057A4:  MOVFF  01,5D8
057A8:  MOVFF  00,5D7
057AC:  MOVLW  05
057AE:  MOVLB  5
057B0:  MOVWF  xDC
057B2:  MOVLW  9C
057B4:  MOVWF  xDB
057B6:  MOVLB  0
057B8:  CALL   3FCE
057BC:  MOVF   01,W
057BE:  SUBLW  FF
057C0:  BNZ   57C8
....................             return EOF;          
057C2:  MOVLW  FF
057C4:  MOVWF  01
057C6:  BRA    5872
....................       } 
....................       if(mmcsd_read_data(i + 0x0B, 1, &buf) != GOODEC) 
057C8:  MOVLW  0B
057CA:  MOVLB  5
057CC:  ADDWF  x9C,W
057CE:  MOVWF  xA0
057D0:  MOVLW  00
057D2:  ADDWFC x9D,W
057D4:  MOVWF  xA1
057D6:  MOVLW  00
057D8:  ADDWFC x9E,W
057DA:  MOVWF  xA2
057DC:  MOVLW  00
057DE:  ADDWFC x9F,W
057E0:  MOVWF  xA3
057E2:  MOVWF  xFE
057E4:  MOVFF  5A2,5FD
057E8:  MOVFF  5A1,5FC
057EC:  MOVFF  5A0,5FB
057F0:  MOVLB  6
057F2:  CLRF   x00
057F4:  MOVLW  01
057F6:  MOVLB  5
057F8:  MOVWF  xFF
057FA:  MOVLW  05
057FC:  MOVLB  6
057FE:  MOVWF  x02
05800:  MOVLW  94
05802:  MOVWF  x01
05804:  MOVLB  0
05806:  CALL   2B2E
0580A:  MOVF   01,F
0580C:  BZ    5814
....................          return EOF; 
0580E:  MOVLW  FF
05810:  MOVWF  01
05812:  BRA    5872
05814:  BRA    55F8
05816:  MOVLB  5
....................    } 
....................  
....................    // copy the short name into the input buffer 
....................    for(i = 0; i < 12; i += 1) 
05818:  CLRF   x9F
0581A:  CLRF   x9E
0581C:  CLRF   x9D
0581E:  CLRF   x9C
05820:  MOVF   x9F,F
05822:  BNZ   586E
05824:  MOVF   x9E,F
05826:  BNZ   586E
05828:  MOVF   x9D,F
0582A:  BNZ   586E
0582C:  MOVF   x9C,W
0582E:  SUBLW  0B
05830:  BNC   586E
....................       sname[i] = val[i]; 
05832:  MOVF   x73,W
05834:  ADDWF  x9C,W
05836:  MOVWF  01
05838:  MOVF   x74,W
0583A:  ADDWFC x9D,W
0583C:  MOVWF  03
0583E:  MOVFF  01,5A0
05842:  MOVWF  xA1
05844:  MOVLW  75
05846:  ADDWF  x9C,W
05848:  MOVWF  FE9
0584A:  MOVLW  05
0584C:  ADDWFC x9D,W
0584E:  MOVWF  FEA
05850:  MOVFF  FEF,5A2
05854:  MOVFF  03,FEA
05858:  MOVFF  01,FE9
0585C:  MOVFF  5A2,FEF
05860:  MOVLW  01
05862:  ADDWF  x9C,F
05864:  MOVLW  00
05866:  ADDWFC x9D,F
05868:  ADDWFC x9E,F
0586A:  ADDWFC x9F,F
0586C:  BRA    5820
....................  
....................    return GOODEC; 
0586E:  MOVLW  00
05870:  MOVWF  01
05872:  MOVLB  0
05874:  GOTO   5B18 (RETURN)
.................... } 
....................  
.................... /* 
.................... int long_name_chksum (int* FcbName) 
.................... Summary: Returns an unsigned byte checksum computed on an unsigned byte 
....................           array. The array must be 11 bytes long and is assumed to contain 
....................           a name stored in the format of a MS-DOS directory entry. 
.................... Param: Pointer to an unsigned byte array assumed to be 11 bytes long. 
.................... Returns: Sum An 8-bit unsigned checksum of the array pointed to by pFcbName. 
.................... */ 
.................... int long_name_chksum (int* pFcbName) 
05878:  MOVLB  5
0587A:  CLRF   x70
.................... { 
....................    int 
....................       FcbNameLen, 
....................       Sum = 0; 
....................  
....................    for(FcbNameLen = 11; FcbNameLen != 0; FcbNameLen -= 1) 
0587C:  MOVLW  0B
0587E:  MOVWF  x6F
05880:  MOVF   x6F,F
05882:  BZ    58B4
....................       // The operation is an unsigned char rotate right 
....................       Sum = ((Sum & 1) ? 0x80 : 0) + (Sum >> 1) + *pFcbName++; 
05884:  BTFSS  x70.0
05886:  BRA    588C
05888:  MOVLW  80
0588A:  BRA    588E
0588C:  MOVLW  00
0588E:  MOVWF  x71
05890:  BCF    FD8.0
05892:  RRCF   x70,W
05894:  ADDWF  x71,F
05896:  MOVFF  56E,03
0589A:  MOVF   x6D,W
0589C:  INCF   x6D,F
0589E:  BTFSC  FD8.2
058A0:  INCF   x6E,F
058A2:  MOVWF  FE9
058A4:  MOVFF  03,FEA
058A8:  MOVF   FEF,W
058AA:  ADDWF  x71,W
058AC:  MOVWF  x70
058AE:  MOVLW  01
058B0:  SUBWF  x6F,F
058B2:  BRA    5880
....................  
....................    return Sum; 
058B4:  MOVFF  570,01
058B8:  MOVLB  0
058BA:  GOTO   5B32 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int check_invalid_char(char fname[]) 
.................... Summary: Checks the filename for any invalid characters. 
.................... Param: The name of the file to check. 
.................... Returns: EOF if an invalid character was found, GOODEC otherwise. 
.................... */ 
.................... signed int check_invalid_char(char fname[]) 
.................... { 
....................    int fname_pos; 
....................  
....................    for(fname_pos = 0; (fname[fname_pos] != '\0') && (fname_pos < MAX_FILE_NAME_LENGTH); fname_pos += 1) 
*
05246:  MOVLB  5
05248:  CLRF   x6F
0524A:  CLRF   03
0524C:  MOVF   x6F,W
0524E:  ADDWF  x6D,W
05250:  MOVWF  FE9
05252:  MOVF   x6E,W
05254:  ADDWFC 03,W
05256:  MOVWF  FEA
05258:  MOVF   FEF,F
0525A:  BZ    52B6
0525C:  MOVF   x6F,W
0525E:  SUBLW  1F
05260:  BNC   52B6
....................       if(isamoung(fname[fname_pos], "\\/:*?\"<>|")) 
05262:  CLRF   03
05264:  MOVF   x6F,W
05266:  ADDWF  x6D,W
05268:  MOVWF  FE9
0526A:  MOVF   x6E,W
0526C:  ADDWFC 03,W
0526E:  MOVWF  FEA
05270:  MOVFF  FEF,570
05274:  MOVF   x70,W
05276:  SUBLW  22
05278:  BZ    52AA
0527A:  MOVF   x70,W
0527C:  SUBLW  2A
0527E:  BZ    52AA
05280:  MOVF   x70,W
05282:  SUBLW  2F
05284:  BZ    52AA
05286:  MOVF   x70,W
05288:  SUBLW  3A
0528A:  BZ    52AA
0528C:  MOVF   x70,W
0528E:  SUBLW  3C
05290:  BZ    52AA
05292:  MOVF   x70,W
05294:  SUBLW  3D
05296:  BC    529E
05298:  MOVF   x70,W
0529A:  SUBLW  3F
0529C:  BC    52AA
0529E:  MOVF   x70,W
052A0:  SUBLW  5C
052A2:  BZ    52AA
052A4:  MOVF   x70,W
052A6:  SUBLW  7C
052A8:  BNZ   52B0
....................          return EOF; 
052AA:  MOVLW  FF
052AC:  MOVWF  01
052AE:  BRA    52BA
052B0:  MOVLW  01
052B2:  ADDWF  x6F,F
052B4:  BRA    524A
....................  
....................    return GOODEC; 
052B6:  MOVLW  00
052B8:  MOVWF  01
052BA:  MOVLB  0
052BC:  GOTO   5AE6 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_next_free_cluster(int16* my_cluster) 
.................... Summary: Will go through the FAT and find the first unallocated cluster. 
.................... Param: Pointer to a variable that will the the starting cluster of the serach. 
....................         When a free cluster is found, the cluster number will be put into this variable. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: This gets a little slow when dealing with a card with lots of stuff on it; sorry about that. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int get_next_free_cluster(int32* my_cluster) 
.................... #else 
.................... signed int get_next_free_cluster(int16* my_cluster) 
.................... #endif 
.................... { 
.................... #ifdef FAST_FAT 
....................    *my_cluster += 1; 
....................    return GOODEC; 
.................... #else // NO FAST_FAT 
....................  
.................... #ifdef FAT32 
....................    int val[4];            // buffer to hold values 
....................  
....................    int32 cur_cluster; 
....................  
....................    int32 
....................       FAT_addr,           // the current address that the algorithm is on 
....................       j; 
....................  
....................    // first, convert *my_cluster to an addressable location in the FAT 
....................    FAT_addr = (*my_cluster << 2) + FAT_Start; 
*
03A9A:  MOVLB  5
03A9C:  MOVFF  5E5,FE9
03AA0:  MOVFF  5E6,FEA
03AA4:  MOVFF  FEF,5F7
03AA8:  MOVFF  FEC,5F8
03AAC:  MOVFF  FEC,5F9
03AB0:  MOVFF  FEC,5FA
03AB4:  RLCF   xF7,F
03AB6:  RLCF   xF8,F
03AB8:  RLCF   xF9,F
03ABA:  RLCF   xFA,F
03ABC:  RLCF   xF7,F
03ABE:  RLCF   xF8,F
03AC0:  RLCF   xF9,F
03AC2:  RLCF   xFA,F
03AC4:  MOVLW  FC
03AC6:  ANDWF  xF7,F
03AC8:  MOVLB  3
03ACA:  MOVF   x97,W
03ACC:  MOVLB  5
03ACE:  ADDWF  xF7,W
03AD0:  MOVWF  xEF
03AD2:  MOVLB  3
03AD4:  MOVF   x98,W
03AD6:  MOVLB  5
03AD8:  ADDWFC xF8,W
03ADA:  MOVWF  xF0
03ADC:  MOVLW  00
03ADE:  ADDWFC xF9,W
03AE0:  MOVWF  xF1
03AE2:  MOVLW  00
03AE4:  ADDWFC xFA,W
03AE6:  MOVWF  xF2
....................  
....................    // the most logical place for the next free cluster would be next to the current cluster 
....................    for(j = 0; j < FAT_Length; j += 4) 
03AE8:  CLRF   xF6
03AEA:  CLRF   xF5
03AEC:  CLRF   xF4
03AEE:  CLRF   xF3
03AF0:  MOVF   xF6,W
03AF2:  MOVLB  3
03AF4:  SUBWF  xA0,W
03AF6:  BTFSS  FD8.0
03AF8:  BRA    3C14
03AFA:  BNZ   3B28
03AFC:  MOVLB  5
03AFE:  MOVF   xF5,W
03B00:  MOVLB  3
03B02:  SUBWF  x9F,W
03B04:  BTFSS  FD8.0
03B06:  BRA    3C14
03B08:  BNZ   3B28
03B0A:  MOVLB  5
03B0C:  MOVF   xF4,W
03B0E:  MOVLB  3
03B10:  SUBWF  x9E,W
03B12:  BTFSS  FD8.0
03B14:  BRA    3C14
03B16:  BNZ   3B28
03B18:  MOVF   x9D,W
03B1A:  MOVLB  5
03B1C:  SUBWF  xF3,W
03B1E:  BTFSS  FD8.0
03B20:  BRA    3B26
03B22:  MOVLB  3
03B24:  BRA    3C14
03B26:  MOVLB  3
....................    { 
....................       if(mmcsd_read_data(FAT_addr + j, 4, val) != GOODEC) 
03B28:  MOVLB  5
03B2A:  MOVF   xF3,W
03B2C:  ADDWF  xEF,W
03B2E:  MOVWF  xF7
03B30:  MOVF   xF4,W
03B32:  ADDWFC xF0,W
03B34:  MOVWF  xF8
03B36:  MOVF   xF5,W
03B38:  ADDWFC xF1,W
03B3A:  MOVWF  xF9
03B3C:  MOVF   xF6,W
03B3E:  ADDWFC xF2,W
03B40:  MOVWF  xFA
03B42:  MOVWF  xFE
03B44:  MOVFF  5F9,5FD
03B48:  MOVFF  5F8,5FC
03B4C:  MOVFF  5F7,5FB
03B50:  MOVLB  6
03B52:  CLRF   x00
03B54:  MOVLW  04
03B56:  MOVLB  5
03B58:  MOVWF  xFF
03B5A:  MOVLW  05
03B5C:  MOVLB  6
03B5E:  MOVWF  x02
03B60:  MOVLW  E7
03B62:  MOVWF  x01
03B64:  MOVLB  0
03B66:  CALL   2B2E
03B6A:  MOVF   01,F
03B6C:  BZ    3B74
....................          return EOF; 
03B6E:  MOVLW  FF
03B70:  MOVWF  01
03B72:  BRA    3C1A
....................  
....................       cur_cluster = make32(val[3], val[2], val[1], val[0]); 
03B74:  MOVFF  5EA,5EE
03B78:  MOVFF  5E9,5ED
03B7C:  MOVFF  5E8,5EC
03B80:  MOVFF  5E7,5EB
....................  
....................       if(cur_cluster == 0) 
03B84:  MOVLB  5
03B86:  MOVF   xEB,F
03B88:  BNZ   3C04
03B8A:  MOVF   xEC,F
03B8C:  BNZ   3C04
03B8E:  MOVF   xED,F
03B90:  BNZ   3C04
03B92:  MOVF   xEE,F
03B94:  BNZ   3C04
....................       { 
....................          // add on the last iteration of j, this is how far into the buffer we were when the algorithm terminated 
....................          FAT_addr += j; 
03B96:  MOVF   xF3,W
03B98:  ADDWF  xEF,F
03B9A:  MOVF   xF4,W
03B9C:  ADDWFC xF0,F
03B9E:  MOVF   xF5,W
03BA0:  ADDWFC xF1,F
03BA2:  MOVF   xF6,W
03BA4:  ADDWFC xF2,F
....................  
....................          // convert *my_cluster back into a cluster number 
....................          *my_cluster = (FAT_addr - FAT_Start) >> 2; 
03BA6:  MOVFF  5E5,FE9
03BAA:  MOVFF  5E6,FEA
03BAE:  MOVLB  3
03BB0:  MOVF   x97,W
03BB2:  MOVLB  5
03BB4:  SUBWF  xEF,W
03BB6:  MOVWF  xF9
03BB8:  MOVLB  3
03BBA:  MOVF   x98,W
03BBC:  MOVLB  5
03BBE:  SUBWFB xF0,W
03BC0:  MOVWF  xFA
03BC2:  MOVLW  00
03BC4:  SUBWFB xF1,W
03BC6:  MOVWF  xFB
03BC8:  MOVLW  00
03BCA:  SUBWFB xF2,W
03BCC:  MOVWF  xFC
03BCE:  RRCF   xFC,W
03BD0:  MOVWF  03
03BD2:  RRCF   xFB,W
03BD4:  MOVWF  02
03BD6:  RRCF   xFA,W
03BD8:  MOVWF  01
03BDA:  RRCF   xF9,W
03BDC:  MOVWF  00
03BDE:  RRCF   03,F
03BE0:  RRCF   02,F
03BE2:  RRCF   01,F
03BE4:  RRCF   00,F
03BE6:  MOVLW  3F
03BE8:  ANDWF  03,F
03BEA:  MOVFF  00,FEF
03BEE:  MOVFF  01,FEC
03BF2:  MOVFF  02,FEC
03BF6:  MOVFF  03,FEC
....................          return GOODEC; 
03BFA:  MOVLW  00
03BFC:  MOVWF  01
03BFE:  MOVLB  0
03C00:  BRA    3C1A
03C02:  MOVLB  5
....................       } 
03C04:  MOVLW  04
03C06:  ADDWF  xF3,F
03C08:  MOVLW  00
03C0A:  ADDWFC xF4,F
03C0C:  ADDWFC xF5,F
03C0E:  ADDWFC xF6,F
03C10:  BRA    3AF0
03C12:  MOVLB  3
....................    } 
.................... #else // FAT16 
....................    int val[2]; 
....................  
....................    int16 cur_cluster; 
....................  
....................    int32 
....................       FAT_addr,           // the current address that the algorithm is on 
....................       j; 
....................  
....................    // first, convert *my_cluster to an addressable location in the FAT 
....................    FAT_addr = (*my_cluster << 1) + FAT_Start; 
....................  
....................    // the most logical place for the next free cluster would be next to the current cluster 
....................    for(j = 0; j < FAT_Length; j += 2) 
....................    { 
....................       if(mmcsd_read_data(FAT_addr + j, 2, val) != GOODEC) 
....................          return EOF; 
....................  
....................       cur_cluster = make16(val[1], val[0]); 
....................  
....................       if(cur_cluster == 0) 
....................       { 
....................          // add on the last iteration of j, this is how far into the buffer we were when the algorithm terminated 
....................          FAT_addr += j; 
....................  
....................          // convert *my_cluster back into a cluster number 
....................          *my_cluster = (FAT_addr - FAT_Start) >> 1; 
....................          return GOODEC; 
....................       } 
....................    } 
....................  
.................... #endif // #ifdef FAT32 
....................    // if we reach this point, we are out of disk space 
....................    return EOF; 
03C14:  MOVLW  FF
03C16:  MOVWF  01
03C18:  MOVLB  0
.................... #endif // #ifdef FAST_FAT 
03C1A:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_next_file(FILE* stream) 
.................... Summary: Will point the stream to the next file in the directory. 
.................... Param: The stream to move. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: This will not set the Buf or Flag parameters. 
.................... */ 
.................... signed int get_next_file(FILE* stream) 
.................... { 
....................    int32 
....................       cluster, 
....................       cur_addr, 
....................       size; 
....................      
....................    int 
....................       fileentry, 
....................       filetype; 
....................     
....................    cur_addr = stream->Entry_Addr; 
....................      
....................    do 
....................    {      
....................       // go forward an entry 
....................       if(get_next_entry(&cur_addr) == EOF) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................        
....................       mmcsd_read_data(cur_addr, 1, &fileentry); 
....................       mmcsd_read_data(cur_addr + 0x0B, 1, &filetype); 
....................  
....................       if(fileentry == 0) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................   
....................    } while((fileentry == 0xE5) || (filetype == 0x0F)); 
....................     
....................    // change the stream's file type 
....................    if(filetype == 0x10) 
....................       stream->File_Type = Directory; 
....................    else 
....................       stream->File_Type = Data_File; 
....................  
....................    // change the stream's entry address 
....................    stream->Entry_Addr = cur_addr; 
....................     
....................    // read in the new starting cluster 
....................    mmcsd_read_data(cur_addr + 0x1A, 2, &cluster); 
....................    mmcsd_read_data(cur_addr + 0x14, 2, (int16*)&cluster + 1); 
....................     
....................    // change the stream's start adress and cur char to the beginning of the first cluster 
....................    stream->Start_Addr = stream->Cur_Char =  cluster_to_addr(cluster); 
....................     
....................    // read in the new file size 
....................    mmcsd_read_data(cur_addr + 0x1C, 4, &size); 
....................     
....................    // change the stream's size and bytes until EOF  
....................    stream->Size = stream->Bytes_Until_EOF = size; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_next_file(FILE* stream) 
.................... Summary: Will point the stream to the previous file in the directory. 
.................... Param: The stream to move. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... Note: This will not set the Buf or Flag parameters. 
.................... */ 
.................... signed int get_prev_file(FILE* stream) 
.................... { 
....................    int32 
....................       cluster, 
....................       cur_addr, 
....................       size; 
....................      
....................    int 
....................       fileentry = 0xE5, 
....................       filetype = 0; 
....................     
....................    cur_addr = stream->Entry_Addr; 
....................      
....................    do 
....................    {      
....................       // go backward an entry 
....................       if(get_prev_entry(&cur_addr) == EOF) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................        
....................       mmcsd_read_data(cur_addr, 1, &fileentry); 
....................       mmcsd_read_data(cur_addr + 0x0B, 1, &filetype); 
....................  
....................       if(fileentry == 0) 
....................       { 
....................          stream->File_Type = None; 
....................          return EOF; 
....................       } 
....................   
....................    } while((fileentry == 0xE5) || (filetype == 0x0F)); 
....................  
....................    // change the stream's file type 
....................    if(filetype == 0x10) 
....................       stream->File_Type = Directory; 
....................    else 
....................       stream->File_Type = Data_File; 
....................  
....................    // change the stream's entry address 
....................    stream->Entry_Addr = cur_addr; 
....................     
....................    // read in the new starting cluster 
....................    mmcsd_read_data(cur_addr + 0x1A, 2, &cluster); 
....................    mmcsd_read_data(cur_addr + 0x14, 2, (int16*)&cluster + 1); 
....................     
....................    // change the stream's start adress and cur char to the beginning of the first cluster 
....................    stream->Start_Addr = stream->Cur_Char =  addr_to_cluster(cluster); 
....................  
....................    // read in the new file size 
....................    mmcsd_read_data(cur_addr + 0x1C, 4, &size); 
....................     
....................    // change the stream's size and bytes until EOF  
....................    stream->Size = stream->Bytes_Until_EOF = size; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_next_free_addr(int32* my_addr) 
.................... Summary: Finds the next unallocated address. 
.................... Param: Pointer to a variable that will the the starting address of the serach. 
....................         When a free address is found, the address will be put into this variable. 
.................... Returns: EOF if there was a problem, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_free_addr(int32* my_addr) 
.................... { 
....................    int val;   // buffer to hold values 
....................  
....................    int32 cur_addr;   // pointer to memory 
....................  
....................    // make a copy of *my_addr 
....................    cur_addr = *my_addr; 
....................  
....................    // keep on getting addresses until we hit a free one 
....................    do 
....................    { 
....................       if(mmcsd_read_data(cur_addr, 1, &val) != GOODEC) 
....................          return EOF; 
....................  
....................       if(get_next_addr(&cur_addr) == EOF) 
....................          return EOF; 
....................    } while(val != 0); 
....................  
....................    *my_addr = cur_addr; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int get_next_entry(int32* start_addr) 
.................... Summary: Gets the next entry in a directory. 
.................... Param: The address to start looking for an entry. 
....................    If an entry is found, it will be put into this variable. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_entry(int32* start_addr) 
.................... { 
....................    int32 i; 
....................     
....................    i = *start_addr; 
*
047F0:  MOVLB  5
047F2:  MOVFF  5C0,FE9
047F6:  MOVFF  5C1,FEA
047FA:  MOVFF  FEF,5C2
047FE:  MOVFF  FEC,5C3
04802:  MOVFF  FEC,5C4
04806:  MOVFF  FEC,5C5
....................     
....................    i += 0x1F; 
0480A:  MOVLW  1F
0480C:  ADDWF  xC2,F
0480E:  MOVLW  00
04810:  ADDWFC xC3,F
04812:  ADDWFC xC4,F
04814:  ADDWFC xC5,F
....................     
....................    if(get_next_addr(&i) == EOF) 
04816:  MOVLW  05
04818:  MOVWF  xD4
0481A:  MOVLW  C2
0481C:  MOVWF  xD3
0481E:  MOVLB  0
04820:  CALL   3E2E
04824:  MOVF   01,W
04826:  SUBLW  FF
04828:  BNZ   4830
....................       return EOF; 
0482A:  MOVLW  FF
0482C:  MOVWF  01
0482E:  BRA    4850
....................     
....................    *start_addr = i; 
04830:  MOVLB  5
04832:  MOVFF  5C0,FE9
04836:  MOVFF  5C1,FEA
0483A:  MOVFF  5C2,FEF
0483E:  MOVFF  5C3,FEC
04842:  MOVFF  5C4,FEC
04846:  MOVFF  5C5,FEC
....................     
....................    return GOODEC; 
0484A:  MOVLW  00
0484C:  MOVWF  01
0484E:  MOVLB  0
04850:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_prev_entry(int32* start_addr) 
.................... Summary: Finds the next free entry in a directory. 
.................... Param: The address to start looking for a free entry. 
....................    If a free entry is found, it will be put into this variable. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_prev_entry(int32* start_addr) 
.................... { 
....................    int32 i; 
....................     
....................    i = *start_addr; 
*
0353A:  MOVLB  5
0353C:  MOVFF  5CE,FE9
03540:  MOVFF  5CF,FEA
03544:  MOVFF  FEF,5D0
03548:  MOVFF  FEC,5D1
0354C:  MOVFF  FEC,5D2
03550:  MOVFF  FEC,5D3
....................  
....................    i -= 0x1F; 
03554:  MOVLW  1F
03556:  SUBWF  xD0,F
03558:  MOVLW  00
0355A:  SUBWFB xD1,F
0355C:  SUBWFB xD2,F
0355E:  SUBWFB xD3,F
....................  
....................    if(get_prev_addr(&i) == EOF) 
03560:  MOVLW  05
03562:  MOVWF  xD5
03564:  MOVLW  D0
03566:  MOVWF  xD4
03568:  MOVLB  0
0356A:  BRA    3356
0356C:  MOVF   01,W
0356E:  SUBLW  FF
03570:  BNZ   3578
....................       return EOF; 
03572:  MOVLW  FF
03574:  MOVWF  01
03576:  BRA    3596
....................  
....................    *start_addr = i; 
03578:  MOVLB  5
0357A:  MOVFF  5CE,FE9
0357E:  MOVFF  5CF,FEA
03582:  MOVFF  5D0,FEF
03586:  MOVFF  5D1,FEC
0358A:  MOVFF  5D2,FEC
0358E:  MOVFF  5D3,FEC
....................     
....................    return GOODEC; 
03592:  MOVLW  00
03594:  MOVWF  01
03596:  MOVLB  0
03598:  GOTO   3642 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_next_free_entry(int32* start_addr) 
.................... Summary: Finds the next free entry in a directory. 
.................... Param: The address to start looking for a free entry. 
....................    If a free entry is found, it will be put into this variable. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_free_entry(int32* start_addr) 
.................... { 
....................    int buf; 
....................  
....................    int32 i; 
....................  
....................    i = *start_addr; 
*
058BE:  MOVLB  5
058C0:  MOVFF  56D,FE9
058C4:  MOVFF  56E,FEA
058C8:  MOVFF  FEF,570
058CC:  MOVFF  FEC,571
058D0:  MOVFF  FEC,572
058D4:  MOVFF  FEC,573
....................  
....................    if(mmcsd_read_data(i, 1, &buf) != GOODEC) 
058D8:  MOVFF  573,5FE
058DC:  MOVFF  572,5FD
058E0:  MOVFF  571,5FC
058E4:  MOVFF  570,5FB
058E8:  MOVLB  6
058EA:  CLRF   x00
058EC:  MOVLW  01
058EE:  MOVLB  5
058F0:  MOVWF  xFF
058F2:  MOVLW  05
058F4:  MOVLB  6
058F6:  MOVWF  x02
058F8:  MOVLW  6F
058FA:  MOVWF  x01
058FC:  MOVLB  0
058FE:  CALL   2B2E
05902:  MOVF   01,F
05904:  BZ    590C
....................      return EOF; 
05906:  MOVLW  FF
05908:  MOVWF  01
0590A:  BRA    59D8
....................  
....................    while(buf != 0) 
0590C:  MOVLB  5
0590E:  MOVF   x6F,F
05910:  BZ    59BA
....................    { 
....................       i += 0x1F; 
05912:  MOVLW  1F
05914:  ADDWF  x70,F
05916:  MOVLW  00
05918:  ADDWFC x71,F
0591A:  ADDWFC x72,F
0591C:  ADDWFC x73,F
....................       // get the next address 
....................       if(get_next_addr(&i) == EOF) 
0591E:  MOVLW  05
05920:  MOVWF  xD4
05922:  MOVLW  70
05924:  MOVWF  xD3
05926:  MOVLB  0
05928:  CALL   3E2E
0592C:  MOVF   01,W
0592E:  SUBLW  FF
05930:  BNZ   5982
....................          if(alloc_clusters(addr_to_cluster(i), &i) == EOF) 
05932:  MOVFF  573,5E1
05936:  MOVFF  572,5E0
0593A:  MOVFF  571,5DF
0593E:  MOVFF  570,5DE
05942:  CALL   31AA
05946:  MOVFF  03,577
0594A:  MOVFF  02,576
0594E:  MOVFF  01,575
05952:  MOVFF  00,574
05956:  MOVFF  03,5DA
0595A:  MOVFF  02,5D9
0595E:  MOVFF  01,5D8
05962:  MOVFF  00,5D7
05966:  MOVLW  05
05968:  MOVLB  5
0596A:  MOVWF  xDC
0596C:  MOVLW  70
0596E:  MOVWF  xDB
05970:  MOVLB  0
05972:  CALL   3FCE
05976:  MOVF   01,W
05978:  SUBLW  FF
0597A:  BNZ   5982
....................             return EOF; 
0597C:  MOVLW  FF
0597E:  MOVWF  01
05980:  BRA    59D8
....................  
....................       if(mmcsd_read_data(i, 1, &buf) != GOODEC) 
05982:  MOVFF  573,5FE
05986:  MOVFF  572,5FD
0598A:  MOVFF  571,5FC
0598E:  MOVFF  570,5FB
05992:  MOVLB  6
05994:  CLRF   x00
05996:  MOVLW  01
05998:  MOVLB  5
0599A:  MOVWF  xFF
0599C:  MOVLW  05
0599E:  MOVLB  6
059A0:  MOVWF  x02
059A2:  MOVLW  6F
059A4:  MOVWF  x01
059A6:  MOVLB  0
059A8:  CALL   2B2E
059AC:  MOVF   01,F
059AE:  BZ    59B6
....................         return EOF; 
059B0:  MOVLW  FF
059B2:  MOVWF  01
059B4:  BRA    59D8
059B6:  BRA    590C
059B8:  MOVLB  5
....................    } 
....................  
....................    *start_addr = i; 
059BA:  MOVFF  56D,FE9
059BE:  MOVFF  56E,FEA
059C2:  MOVFF  570,FEF
059C6:  MOVFF  571,FEC
059CA:  MOVFF  572,FEC
059CE:  MOVFF  573,FEC
....................  
....................    return GOODEC; 
059D2:  MOVLW  00
059D4:  MOVWF  01
059D6:  MOVLB  0
059D8:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int alloc_clusters(int16 start_cluster, int32* new_cluster_addr) 
.................... Summary: Find, allocate, and link a free cluster. 
.................... Param start_cluster: The cluster to begin looking for free clusters. This cluster will be linked to the newfound cluster in the FAT. 
.................... Param new_cluster_addr: The address of the newly allocated cluster. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int alloc_clusters(int32 start_cluster, int32* new_cluster_addr) 
.................... #else 
.................... signed int alloc_clusters(int16 start_cluster, int32* new_cluster_addr) 
.................... #endif 
.................... { 
.................... #ifdef FAT32 
....................    int32 
....................       cur_cluster, 
....................       next_cluster; 
.................... #else // FAT16 
....................    int16 
....................       cur_cluster, 
....................       next_cluster; 
.................... #endif // #ifdef FAT32 
....................  
....................    // if we're at the end of the file's allocated space, then we need to allocate some more space 
....................    //  figure out where the current character is pointing to 
....................    next_cluster = cur_cluster = start_cluster; 
*
03FCE:  MOVFF  5DA,5E0
03FD2:  MOVFF  5D9,5DF
03FD6:  MOVFF  5D8,5DE
03FDA:  MOVFF  5D7,5DD
03FDE:  MOVFF  5E0,5E4
03FE2:  MOVFF  5DF,5E3
03FE6:  MOVFF  5DE,5E2
03FEA:  MOVFF  5DD,5E1
....................  
....................    // get the next free cluster 
....................    if(get_next_free_cluster(&next_cluster) == EOF) 
03FEE:  MOVLW  05
03FF0:  MOVLB  5
03FF2:  MOVWF  xE6
03FF4:  MOVLW  E1
03FF6:  MOVWF  xE5
03FF8:  MOVLB  0
03FFA:  RCALL  3A9A
03FFC:  MOVF   01,W
03FFE:  SUBLW  FF
04000:  BNZ   4008
....................       return EOF; 
04002:  MOVLW  FF
04004:  MOVWF  01
04006:  BRA    40BE
....................  
....................    if(write_fat(cur_cluster, next_cluster) == EOF) 
04008:  MOVFF  5E0,5E8
0400C:  MOVFF  5DF,5E7
04010:  MOVFF  5DE,5E6
04014:  MOVFF  5DD,5E5
04018:  MOVFF  5E4,5EC
0401C:  MOVFF  5E3,5EB
04020:  MOVFF  5E2,5EA
04024:  MOVFF  5E1,5E9
04028:  RCALL  3906
0402A:  MOVF   01,W
0402C:  SUBLW  FF
0402E:  BNZ   4036
....................       return EOF; 
04030:  MOVLW  FF
04032:  MOVWF  01
04034:  BRA    40BE
....................  
.................... #ifdef FAT32 
....................    if(write_fat(next_cluster, 0x0FFFFFFF) == EOF) 
04036:  MOVFF  5E4,5E8
0403A:  MOVFF  5E3,5E7
0403E:  MOVFF  5E2,5E6
04042:  MOVFF  5E1,5E5
04046:  MOVLW  0F
04048:  MOVLB  5
0404A:  MOVWF  xEC
0404C:  SETF   xEB
0404E:  SETF   xEA
04050:  SETF   xE9
04052:  MOVLB  0
04054:  RCALL  3906
04056:  MOVF   01,W
04058:  SUBLW  FF
0405A:  BNZ   4062
....................       return EOF; 
0405C:  MOVLW  FF
0405E:  MOVWF  01
04060:  BRA    40BE
....................  
.................... #else // FAT16 
....................    if(write_fat(next_cluster, 0xFFFF) == EOF) 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................    // erase all of the data in the newly linked cluster 
....................    if(clear_cluster(next_cluster) == EOF) 
04062:  MOVFF  5E4,5E8
04066:  MOVFF  5E3,5E7
0406A:  MOVFF  5E2,5E6
0406E:  MOVFF  5E1,5E5
04072:  RCALL  3C1C
04074:  MOVF   01,W
04076:  SUBLW  FF
04078:  BNZ   4080
....................       return EOF; 
0407A:  MOVLW  FF
0407C:  MOVWF  01
0407E:  BRA    40BE
....................  
....................    // put the current character to this position 
....................    *new_cluster_addr = cluster_to_addr(next_cluster); 
04080:  MOVFF  5DC,03
04084:  MOVFF  5DB,5E5
04088:  MOVFF  5DC,5E6
0408C:  MOVFF  5E4,613
04090:  MOVFF  5E3,612
04094:  MOVFF  5E2,611
04098:  MOVFF  5E1,610
0409C:  MOVLB  0
0409E:  CALL   32FA
040A2:  MOVFF  5E6,FEA
040A6:  MOVFF  5E5,FE9
040AA:  MOVFF  00,FEF
040AE:  MOVFF  01,FEC
040B2:  MOVFF  02,FEC
040B6:  MOVFF  03,FEC
....................  
....................    return GOODEC; 
040BA:  MOVLW  00
040BC:  MOVWF  01
040BE:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int dealloc_clusters(int16 start_cluster) 
.................... Summary: De-allocates linked clusters from the FAT. 
.................... Param: The starting cluster to deallocate. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int dealloc_clusters(int32 start_cluster) 
.................... #else 
.................... signed int dealloc_clusters(int16 start_cluster) 
.................... #endif 
.................... { 
.................... #ifdef FAT32 
....................    int32 
....................       cur_cluster,              // the current cluster we're pointing to 
....................       next_cluster;             // the next cluster we're going to point to 
.................... #else // FAT16 
....................    int16 
....................       cur_cluster,              // the current cluster we're pointing to 
....................       next_cluster;             // the next cluster we're going to point to 
.................... #endif // #ifdef FAT32 
....................  
....................    //  figure out where the first cluster is 
....................    next_cluster = cur_cluster = start_cluster; 
*
0396E:  MOVFF  5C7,5CB
03972:  MOVFF  5C6,5CA
03976:  MOVFF  5C5,5C9
0397A:  MOVFF  5C4,5C8
0397E:  MOVFF  5CB,5CF
03982:  MOVFF  5CA,5CE
03986:  MOVFF  5C9,5CD
0398A:  MOVFF  5C8,5CC
....................    do 
....................    { 
....................       // get the next cluster 
....................       if(get_next_cluster(&next_cluster) == EOF) 
0398E:  MOVLW  05
03990:  MOVLB  5
03992:  MOVWF  xDA
03994:  MOVLW  CC
03996:  MOVWF  xD9
03998:  MOVLB  0
0399A:  RCALL  37A6
0399C:  MOVF   01,W
0399E:  SUBLW  FF
039A0:  BNZ   39A8
....................          return EOF; 
039A2:  MOVLW  FF
039A4:  MOVWF  01
039A6:  BRA    3A12
....................  
....................       // unlink the current cluster in the FAT 
....................       if(write_fat(cur_cluster, 0) == EOF) 
039A8:  MOVFF  5CB,5E8
039AC:  MOVFF  5CA,5E7
039B0:  MOVFF  5C9,5E6
039B4:  MOVFF  5C8,5E5
039B8:  MOVLB  5
039BA:  CLRF   xEC
039BC:  CLRF   xEB
039BE:  CLRF   xEA
039C0:  CLRF   xE9
039C2:  MOVLB  0
039C4:  RCALL  3906
039C6:  MOVF   01,W
039C8:  SUBLW  FF
039CA:  BNZ   39D2
....................          return EOF; 
039CC:  MOVLW  FF
039CE:  MOVWF  01
039D0:  BRA    3A12
....................  
....................       cur_cluster = next_cluster; 
039D2:  MOVFF  5CF,5CB
039D6:  MOVFF  5CE,5CA
039DA:  MOVFF  5CD,5C9
039DE:  MOVFF  5CC,5C8
....................    } 
.................... #ifdef FAT32 
....................     while(cur_cluster != 0x0FFFFFFF); 
039E2:  MOVLB  5
039E4:  INCFSZ xC8,W
039E6:  BRA    39EA
039E8:  BRA    39EE
039EA:  MOVLB  0
039EC:  BRA    398E
039EE:  INCFSZ xC9,W
039F0:  BRA    39F4
039F2:  BRA    39F8
039F4:  MOVLB  0
039F6:  BRA    398E
039F8:  INCFSZ xCA,W
039FA:  BRA    39FE
039FC:  BRA    3A02
039FE:  MOVLB  0
03A00:  BRA    398E
03A02:  MOVF   xCB,W
03A04:  SUBLW  0F
03A06:  BTFSC  FD8.2
03A08:  BRA    3A0E
03A0A:  MOVLB  0
03A0C:  BRA    398E
.................... #else // FAT16 
....................     while(cur_cluster != 0xFFFF); 
.................... #endif // #ifdef FAT32 
....................  
....................    return GOODEC; 
03A0E:  MOVLW  00
03A10:  MOVWF  01
03A12:  MOVLB  0
03A14:  GOTO   4C80 (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int clear_cluster(int16 cluster) 
.................... Summary: Clears out all of the data in a given cluster. 
.................... Param: The cluster to clear out. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int clear_cluster(int32 cluster) 
.................... #else 
.................... signed int clear_cluster(int16 cluster) 
.................... #endif 
.................... { 
....................    int 
....................       clear_entry[0x20], 
....................       j; 
....................  
....................    int16 i; 
....................  
....................    int32 start_addr; 
....................  
....................    start_addr = cluster_to_addr(cluster); 
*
03C1C:  MOVFF  5E8,613
03C20:  MOVFF  5E7,612
03C24:  MOVFF  5E6,611
03C28:  MOVFF  5E5,610
03C2C:  CALL   32FA
03C30:  MOVFF  03,60F
03C34:  MOVFF  02,60E
03C38:  MOVFF  01,60D
03C3C:  MOVFF  00,60C
....................     
....................    for(j = 0; j < 0x20; j += 1) 
03C40:  MOVLB  6
03C42:  CLRF   x09
03C44:  MOVF   x09,W
03C46:  SUBLW  1F
03C48:  BNC   3C60
....................       clear_entry[j] = 0; 
03C4A:  CLRF   03
03C4C:  MOVF   x09,W
03C4E:  ADDLW  E9
03C50:  MOVWF  FE9
03C52:  MOVLW  05
03C54:  ADDWFC 03,W
03C56:  MOVWF  FEA
03C58:  CLRF   FEF
03C5A:  MOVLW  01
03C5C:  ADDWF  x09,F
03C5E:  BRA    3C44
....................  
....................    for(i = 0; i < Bytes_Per_Cluster; i += 0x20) 
03C60:  CLRF   x0B
03C62:  CLRF   x0A
03C64:  MOVF   x0B,W
03C66:  MOVLB  3
03C68:  SUBWF  x96,W
03C6A:  BNC   3CD0
03C6C:  BNZ   3C7E
03C6E:  MOVF   x95,W
03C70:  MOVLB  6
03C72:  SUBWF  x0A,W
03C74:  BTFSS  FD8.0
03C76:  BRA    3C7C
03C78:  MOVLB  3
03C7A:  BRA    3CD0
03C7C:  MOVLB  3
....................       if(mmcsd_write_data(start_addr + i, 0x20, clear_entry) != GOODEC) 
03C7E:  MOVLB  6
03C80:  MOVF   x0A,W
03C82:  ADDWF  x0C,W
03C84:  MOVWF  x10
03C86:  MOVF   x0B,W
03C88:  ADDWFC x0D,W
03C8A:  MOVWF  x11
03C8C:  MOVLW  00
03C8E:  ADDWFC x0E,W
03C90:  MOVWF  x12
03C92:  MOVLW  00
03C94:  ADDWFC x0F,W
03C96:  MOVWF  x13
03C98:  MOVWF  x17
03C9A:  MOVFF  612,616
03C9E:  MOVFF  611,615
03CA2:  MOVFF  610,614
03CA6:  CLRF   x19
03CA8:  MOVLW  20
03CAA:  MOVWF  x18
03CAC:  MOVLW  05
03CAE:  MOVWF  x1B
03CB0:  MOVLW  E9
03CB2:  MOVWF  x1A
03CB4:  MOVLB  0
03CB6:  RCALL  3874
03CB8:  MOVF   01,F
03CBA:  BZ    3CC2
....................          return EOF; 
03CBC:  MOVLW  FF
03CBE:  MOVWF  01
03CC0:  BRA    3CD6
03CC2:  MOVLW  20
03CC4:  MOVLB  6
03CC6:  ADDWF  x0A,F
03CC8:  MOVLW  00
03CCA:  ADDWFC x0B,F
03CCC:  BRA    3C64
03CCE:  MOVLB  3
....................  
....................    return GOODEC; 
03CD0:  MOVLW  00
03CD2:  MOVWF  01
03CD4:  MOVLB  0
03CD6:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int write_fat(int32 cluster, int32 data) 
.................... Summary: Writes specified data about a cluster to the FAT. 
.................... Param cluster: The cluster to modify the in the FAT. 
.................... Param data: The data about the cluster to put into the FAT. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int write_fat(int32 cluster, int32 data) 
.................... { 
....................    if(mmcsd_write_data((cluster << 2) + FAT_Start, 4, &data) != GOODEC) 
*
03906:  MOVLB  5
03908:  RLCF   xE5,W
0390A:  MOVWF  xEE
0390C:  RLCF   xE6,W
0390E:  MOVWF  xEF
03910:  RLCF   xE7,W
03912:  MOVWF  xF0
03914:  RLCF   xE8,W
03916:  MOVWF  xF1
03918:  RLCF   xEE,F
0391A:  RLCF   xEF,F
0391C:  RLCF   xF0,F
0391E:  RLCF   xF1,F
03920:  MOVLW  FC
03922:  ANDWF  xEE,F
03924:  MOVLB  3
03926:  MOVF   x97,W
03928:  MOVLB  5
0392A:  ADDWF  xEE,F
0392C:  MOVLB  3
0392E:  MOVF   x98,W
03930:  MOVLB  5
03932:  ADDWFC xEF,F
03934:  MOVLW  00
03936:  ADDWFC xF0,F
03938:  ADDWFC xF1,F
0393A:  MOVFF  5F1,617
0393E:  MOVFF  5F0,616
03942:  MOVFF  5EF,615
03946:  MOVFF  5EE,614
0394A:  MOVLB  6
0394C:  CLRF   x19
0394E:  MOVLW  04
03950:  MOVWF  x18
03952:  MOVLW  05
03954:  MOVWF  x1B
03956:  MOVLW  E9
03958:  MOVWF  x1A
0395A:  MOVLB  0
0395C:  RCALL  3874
0395E:  MOVF   01,F
03960:  BZ    3968
....................       return EOF; 
03962:  MOVLW  FF
03964:  MOVWF  01
03966:  BRA    396C
....................  
....................    return GOODEC; 
03968:  MOVLW  00
0396A:  MOVWF  01
0396C:  RETURN 0
.................... } 
.................... #else // FAT16 
.................... signed int write_fat(int16 cluster, int16 data) 
.................... { 
....................    if(mmcsd_write_data((cluster << 1) + FAT_Start, 2, &data) != GOODEC) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
.................... #endif // #ifdef FAT32 
....................  
.................... /* 
.................... signed int read_buffer(FILE* stream, int* val) 
.................... Summary: Reads from the buffer. 
.................... Param stream: The stream whose buffer to read from. 
.................... Param val: A pointer to a varaible to put the read data into. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int read_buffer(FILE* stream, int* val) 
.................... { 
....................    int i;    // counter for loops 
....................  
....................    // check to see if we need to populate the buffer 
....................    if((stream->Cur_Char % STREAM_BUF_SIZE) == 0) 
....................    { 
....................       if(mmcsd_read_data(stream->Cur_Char, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
....................       { 
....................          stream->Flags |= Read_Error; 
....................          return EOF; 
....................       } 
....................    } 
....................  
....................    // grab the value at the top of the buffer 
....................    *val = stream->Buf[0]; 
....................  
....................    // shift everything over 1 byte to put a new value at the top of the buffer 
....................    for(i = 0; i < 8; i += 1) 
....................       rotate_right(stream->Buf, STREAM_BUF_SIZE); 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int write_buffer(FILE* stream, int val) 
.................... Summary: Writes to the buffer. 
.................... Param stream: The stream whose buffer to write to. 
.................... Param val: A variable to write to the buffer. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int write_buffer(FILE* stream, int val) 
.................... { 
....................    // check to see if we should dump the buffer to the card 
....................    if(((stream->Cur_Char % STREAM_BUF_SIZE) == 0) 
....................       && (stream->Cur_Char != stream->Start_Addr)) 
*
03CD8:  MOVLW  04
03CDA:  MOVLB  5
03CDC:  ADDWF  xD1,W
03CDE:  MOVWF  FE9
03CE0:  MOVLW  00
03CE2:  ADDWFC xD2,W
03CE4:  MOVWF  FEA
03CE6:  MOVFF  FEF,5D4
03CEA:  MOVFF  FEC,5D5
03CEE:  MOVFF  FEC,5D6
03CF2:  MOVFF  FEC,5D7
03CF6:  MOVLW  1F
03CF8:  ANDWF  xD4,F
03CFA:  CLRF   xD5
03CFC:  CLRF   xD6
03CFE:  CLRF   xD7
03D00:  MOVF   xD4,F
03D02:  BTFSS  FD8.2
03D04:  BRA    3DDE
03D06:  MOVF   xD5,F
03D08:  BNZ   3DDE
03D0A:  MOVF   xD6,F
03D0C:  BNZ   3DDE
03D0E:  MOVF   xD7,F
03D10:  BNZ   3DDE
03D12:  MOVLW  04
03D14:  ADDWF  xD1,W
03D16:  MOVWF  FE9
03D18:  MOVLW  00
03D1A:  ADDWFC xD2,W
03D1C:  MOVWF  FEA
03D1E:  MOVFF  FEF,5D4
03D22:  MOVFF  FEC,5D5
03D26:  MOVFF  FEC,5D6
03D2A:  MOVFF  FEC,5D7
03D2E:  MOVLW  14
03D30:  ADDWF  xD1,W
03D32:  MOVWF  FE9
03D34:  MOVLW  00
03D36:  ADDWFC xD2,W
03D38:  MOVWF  FEA
03D3A:  MOVFF  FEF,00
03D3E:  MOVFF  FEC,01
03D42:  MOVFF  FEC,02
03D46:  MOVFF  FEC,03
03D4A:  MOVF   00,W
03D4C:  SUBWF  xD4,W
03D4E:  BNZ   3D62
03D50:  MOVF   01,W
03D52:  SUBWF  xD5,W
03D54:  BNZ   3D62
03D56:  MOVF   02,W
03D58:  SUBWF  xD6,W
03D5A:  BNZ   3D62
03D5C:  MOVF   03,W
03D5E:  SUBWF  xD7,W
03D60:  BZ    3DDE
....................    { 
....................       // dump the buffer to the card 
....................       if(mmcsd_write_data(stream->Cur_Char - STREAM_BUF_SIZE, STREAM_BUF_SIZE, stream->Buf) != GOODEC) 
03D62:  MOVLW  04
03D64:  ADDWF  xD1,W
03D66:  MOVWF  FE9
03D68:  MOVLW  00
03D6A:  ADDWFC xD2,W
03D6C:  MOVWF  FEA
03D6E:  MOVFF  FEF,5D4
03D72:  MOVFF  FEC,5D5
03D76:  MOVFF  FEC,5D6
03D7A:  MOVFF  FEC,5D7
03D7E:  MOVLW  20
03D80:  SUBWF  xD4,F
03D82:  MOVLW  00
03D84:  SUBWFB xD5,F
03D86:  SUBWFB xD6,F
03D88:  SUBWFB xD7,F
03D8A:  MOVLW  1A
03D8C:  ADDWF  xD1,W
03D8E:  MOVWF  01
03D90:  MOVLW  00
03D92:  ADDWFC xD2,W
03D94:  MOVWF  03
03D96:  MOVFF  01,5D8
03D9A:  MOVWF  xD9
03D9C:  MOVFF  5D7,617
03DA0:  MOVFF  5D6,616
03DA4:  MOVFF  5D5,615
03DA8:  MOVFF  5D4,614
03DAC:  MOVLB  6
03DAE:  CLRF   x19
03DB0:  MOVLW  20
03DB2:  MOVWF  x18
03DB4:  MOVFF  03,61B
03DB8:  MOVFF  01,61A
03DBC:  MOVLB  0
03DBE:  RCALL  3874
03DC0:  MOVF   01,F
03DC2:  BZ    3DE0
....................       { 
....................          stream->Flags |= Write_Error; 
03DC4:  MOVLW  19
03DC6:  MOVLB  5
03DC8:  ADDWF  xD1,W
03DCA:  MOVWF  FE9
03DCC:  MOVLW  00
03DCE:  ADDWFC xD2,W
03DD0:  MOVWF  FEA
03DD2:  MOVF   FEF,W
03DD4:  IORLW  40
03DD6:  MOVWF  FEF
....................          return EOF; 
03DD8:  MOVLW  FF
03DDA:  MOVWF  01
03DDC:  BRA    3E28
03DDE:  MOVLB  0
....................       } 
....................    } 
....................  
....................    // fill up a byte on the buffer 
....................    stream->Buf[stream->Cur_Char % STREAM_BUF_SIZE] = val; 
03DE0:  MOVLW  04
03DE2:  MOVLB  5
03DE4:  ADDWF  xD1,W
03DE6:  MOVWF  FE9
03DE8:  MOVLW  00
03DEA:  ADDWFC xD2,W
03DEC:  MOVWF  FEA
03DEE:  MOVFF  FEF,5D4
03DF2:  MOVFF  FEC,5D5
03DF6:  MOVFF  FEC,5D6
03DFA:  MOVFF  FEC,5D7
03DFE:  MOVLW  1F
03E00:  ANDWF  xD4,F
03E02:  CLRF   xD5
03E04:  CLRF   xD6
03E06:  CLRF   xD7
03E08:  MOVLW  1A
03E0A:  ADDWF  xD4,W
03E0C:  MOVWF  01
03E0E:  MOVLW  00
03E10:  ADDWFC xD5,W
03E12:  MOVWF  03
03E14:  MOVF   01,W
03E16:  ADDWF  xD1,W
03E18:  MOVWF  FE9
03E1A:  MOVF   xD2,W
03E1C:  ADDWFC 03,W
03E1E:  MOVWF  FEA
03E20:  MOVFF  5D3,FEF
....................  
....................    return GOODEC; 
03E24:  MOVLW  00
03E26:  MOVWF  01
03E28:  MOVLB  0
03E2A:  GOTO   422C (RETURN)
.................... } 
....................  
.................... /* 
.................... void fill_entry(char the_entry[], char val, int8 start_ind) 
.................... Summary: This will fill up the unused spots in a standard FAT entry with a value. 
.................... Param the_entry[]: The entry that will be modified. 
.................... Param val: The value to fill the entry with. 
.................... Param start_ind: The beginning index to start filling the_entry. 
.................... Returns: Nothing. 
.................... */ 
.................... void fill_entry(char the_entry[], char val, int8 start_ind) 
.................... { 
....................    int8 i; 
....................  
....................    for(i = start_ind; i < 13; i += 1) 
*
05A26:  MOVFF  570,571
05A2A:  MOVLB  5
05A2C:  MOVF   x71,W
05A2E:  SUBLW  0C
05A30:  BNC   5ACC
....................    { 
....................       if(i < 5) 
05A32:  MOVF   x71,W
05A34:  SUBLW  04
05A36:  BNC   5A66
....................       { 
....................          the_entry[(i << 1) + 1] = val; 
05A38:  BCF    FD8.0
05A3A:  RLCF   x71,W
05A3C:  ADDLW  01
05A3E:  CLRF   03
05A40:  ADDWF  x6D,W
05A42:  MOVWF  FE9
05A44:  MOVF   x6E,W
05A46:  ADDWFC 03,W
05A48:  MOVWF  FEA
05A4A:  MOVFF  56F,FEF
....................          the_entry[(i << 1) + 2] = val; 
05A4E:  BCF    FD8.0
05A50:  RLCF   x71,W
05A52:  ADDLW  02
05A54:  CLRF   03
05A56:  ADDWF  x6D,W
05A58:  MOVWF  FE9
05A5A:  MOVF   x6E,W
05A5C:  ADDWFC 03,W
05A5E:  MOVWF  FEA
05A60:  MOVFF  56F,FEF
....................       } 
05A64:  BRA    5AC6
....................  
....................       else if(i < 11) 
05A66:  MOVF   x71,W
05A68:  SUBLW  0A
05A6A:  BNC   5A9A
....................       { 
....................          the_entry[(i << 1) + 4] = val; 
05A6C:  BCF    FD8.0
05A6E:  RLCF   x71,W
05A70:  ADDLW  04
05A72:  CLRF   03
05A74:  ADDWF  x6D,W
05A76:  MOVWF  FE9
05A78:  MOVF   x6E,W
05A7A:  ADDWFC 03,W
05A7C:  MOVWF  FEA
05A7E:  MOVFF  56F,FEF
....................          the_entry[(i << 1) + 5] = val; 
05A82:  BCF    FD8.0
05A84:  RLCF   x71,W
05A86:  ADDLW  05
05A88:  CLRF   03
05A8A:  ADDWF  x6D,W
05A8C:  MOVWF  FE9
05A8E:  MOVF   x6E,W
05A90:  ADDWFC 03,W
05A92:  MOVWF  FEA
05A94:  MOVFF  56F,FEF
....................       } 
05A98:  BRA    5AC6
....................  
....................       else 
....................       { 
....................          the_entry[(i << 1) + 6] = val; 
05A9A:  BCF    FD8.0
05A9C:  RLCF   x71,W
05A9E:  ADDLW  06
05AA0:  CLRF   03
05AA2:  ADDWF  x6D,W
05AA4:  MOVWF  FE9
05AA6:  MOVF   x6E,W
05AA8:  ADDWFC 03,W
05AAA:  MOVWF  FEA
05AAC:  MOVFF  56F,FEF
....................          the_entry[(i << 1) + 7] = val; 
05AB0:  BCF    FD8.0
05AB2:  RLCF   x71,W
05AB4:  ADDLW  07
05AB6:  CLRF   03
05AB8:  ADDWF  x6D,W
05ABA:  MOVWF  FE9
05ABC:  MOVF   x6E,W
05ABE:  ADDWFC 03,W
05AC0:  MOVWF  FEA
05AC2:  MOVFF  56F,FEF
....................       } 
05AC6:  MOVLW  01
05AC8:  ADDWF  x71,F
05ACA:  BRA    5A2C
....................    } 
05ACC:  MOVLB  0
05ACE:  RETURN 0
.................... } 
....................  
.................... /* 
.................... void disp_timestamp(int16 timestamp) 
.................... Summary: Parses an timestamp from a file entry and displays it to the console 
.................... Param: The 16-bit timestamp code from a file entry 
.................... Returns: Nothing. 
.................... */ 
.................... void disp_timestamp(int16 timestamp) 
.................... { 
....................    // Hours:Minutes:Seconds 
....................    printf("%lu:%lu:%lu", 
....................       timestamp >> 11, 
....................       (timestamp & 0x07E0) >> 5, 
....................       (timestamp & 0x001F) << 1); 
.................... } 
....................  
.................... /* 
.................... void disp_datestamp(int16 datestamp) 
.................... Summary: Parses an datestamp from a file entry and displays it to the console 
.................... Param: The 16-bit datestamp code from a file entry 
.................... Returns: Nothing. 
.................... */ 
.................... void disp_datestamp(int16 datestamp) 
.................... { 
....................    // Month/Day/Year 
....................    printf("%lu/%lu/%lu", 
....................       (datestamp & 0x01F0) >> 5, 
....................       datestamp & 0x001F, 
....................       (1980 + (datestamp >> 9))); 
.................... } 
....................  
.................... /// Data Utility Functions /// 
....................  
.................... /* 
.................... signed int fat_init() 
.................... Summary: Initializes global variables that are essential for this library working 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... Note: This must be called before any other function calls in this library. 
.................... */ 
.................... signed int fat_init() 
*
02C44:  MOVLB  4
02C46:  CLRF   xAA
.................... { 
....................    int ec = 0; 
....................  
....................    int 
....................       FATs, 
....................       Sectors_Per_Cluster; 
....................  
....................    int16 
....................       Bytes_Per_Sector, 
....................       Reserved_Sectors, 
....................       Small_Sectors; 
....................  
....................    int32 
....................       Hidden_Sectors, 
....................       Large_Sectors; 
....................  
.................... #ifdef FAT32 
....................    int32 Sectors_Per_FAT; 
.................... #else // FAT16 
....................    int16 
....................       Root_Entries, 
....................       Sectors_Per_FAT; 
.................... #endif // #ifdef FAT32 
....................  
....................    // initialize the media 
....................    ec += mmcsd_init(); 
02C48:  MOVLB  0
02C4A:  BRA    27F2
02C4C:  MOVF   01,W
02C4E:  MOVLB  4
02C50:  ADDWF  xAA,F
....................  
....................    // start filling up variables 
....................    ec += mmcsd_read_data(11, 2, &Bytes_Per_Sector); 
02C52:  MOVLB  5
02C54:  CLRF   xFE
02C56:  CLRF   xFD
02C58:  CLRF   xFC
02C5A:  MOVLW  0B
02C5C:  MOVWF  xFB
02C5E:  MOVLB  6
02C60:  CLRF   x00
02C62:  MOVLW  02
02C64:  MOVLB  5
02C66:  MOVWF  xFF
02C68:  MOVLW  04
02C6A:  MOVLB  6
02C6C:  MOVWF  x02
02C6E:  MOVLW  AD
02C70:  MOVWF  x01
02C72:  MOVLB  0
02C74:  RCALL  2B2E
02C76:  MOVF   01,W
02C78:  MOVLB  4
02C7A:  ADDWF  xAA,F
....................    ec += mmcsd_read_data(13, 1, &Sectors_Per_Cluster); 
02C7C:  MOVLB  5
02C7E:  CLRF   xFE
02C80:  CLRF   xFD
02C82:  CLRF   xFC
02C84:  MOVLW  0D
02C86:  MOVWF  xFB
02C88:  MOVLB  6
02C8A:  CLRF   x00
02C8C:  MOVLW  01
02C8E:  MOVLB  5
02C90:  MOVWF  xFF
02C92:  MOVLW  04
02C94:  MOVLB  6
02C96:  MOVWF  x02
02C98:  MOVLW  AC
02C9A:  MOVWF  x01
02C9C:  MOVLB  0
02C9E:  RCALL  2B2E
02CA0:  MOVF   01,W
02CA2:  MOVLB  4
02CA4:  ADDWF  xAA,F
....................    ec += mmcsd_read_data(14, 2, &Reserved_Sectors); 
02CA6:  MOVLB  5
02CA8:  CLRF   xFE
02CAA:  CLRF   xFD
02CAC:  CLRF   xFC
02CAE:  MOVLW  0E
02CB0:  MOVWF  xFB
02CB2:  MOVLB  6
02CB4:  CLRF   x00
02CB6:  MOVLW  02
02CB8:  MOVLB  5
02CBA:  MOVWF  xFF
02CBC:  MOVLW  04
02CBE:  MOVLB  6
02CC0:  MOVWF  x02
02CC2:  MOVLW  AF
02CC4:  MOVWF  x01
02CC6:  MOVLB  0
02CC8:  RCALL  2B2E
02CCA:  MOVF   01,W
02CCC:  MOVLB  4
02CCE:  ADDWF  xAA,F
....................    ec += mmcsd_read_data(16, 1, &FATs); 
02CD0:  MOVLB  5
02CD2:  CLRF   xFE
02CD4:  CLRF   xFD
02CD6:  CLRF   xFC
02CD8:  MOVLW  10
02CDA:  MOVWF  xFB
02CDC:  MOVLB  6
02CDE:  CLRF   x00
02CE0:  MOVLW  01
02CE2:  MOVLB  5
02CE4:  MOVWF  xFF
02CE6:  MOVLW  04
02CE8:  MOVLB  6
02CEA:  MOVWF  x02
02CEC:  MOVLW  AB
02CEE:  MOVWF  x01
02CF0:  MOVLB  0
02CF2:  RCALL  2B2E
02CF4:  MOVF   01,W
02CF6:  MOVLB  4
02CF8:  ADDWF  xAA,F
.................... #ifdef FAT16 
....................    ec += mmcsd_read_data(17, 2, &Root_Entries); 
.................... #endif // #ifdef FAT16 
....................    ec += mmcsd_read_data(19, 2, &Small_Sectors); 
02CFA:  MOVLB  5
02CFC:  CLRF   xFE
02CFE:  CLRF   xFD
02D00:  CLRF   xFC
02D02:  MOVLW  13
02D04:  MOVWF  xFB
02D06:  MOVLB  6
02D08:  CLRF   x00
02D0A:  MOVLW  02
02D0C:  MOVLB  5
02D0E:  MOVWF  xFF
02D10:  MOVLW  04
02D12:  MOVLB  6
02D14:  MOVWF  x02
02D16:  MOVLW  B1
02D18:  MOVWF  x01
02D1A:  MOVLB  0
02D1C:  RCALL  2B2E
02D1E:  MOVF   01,W
02D20:  MOVLB  4
02D22:  ADDWF  xAA,F
.................... #ifdef FAT32 
....................    ec += mmcsd_read_data(36, 4, &Sectors_Per_FAT); 
02D24:  MOVLB  5
02D26:  CLRF   xFE
02D28:  CLRF   xFD
02D2A:  CLRF   xFC
02D2C:  MOVLW  24
02D2E:  MOVWF  xFB
02D30:  MOVLB  6
02D32:  CLRF   x00
02D34:  MOVLW  04
02D36:  MOVLB  5
02D38:  MOVWF  xFF
02D3A:  MOVLB  6
02D3C:  MOVWF  x02
02D3E:  MOVLW  BB
02D40:  MOVWF  x01
02D42:  MOVLB  0
02D44:  RCALL  2B2E
02D46:  MOVF   01,W
02D48:  MOVLB  4
02D4A:  ADDWF  xAA,F
.................... #else // FAT16 
....................    ec += mmcsd_read_data(22, 2, &Sectors_Per_FAT); 
.................... #endif // #ifdef FAT32 
....................    ec += mmcsd_read_data(28, 4, &Hidden_Sectors); 
02D4C:  MOVLB  5
02D4E:  CLRF   xFE
02D50:  CLRF   xFD
02D52:  CLRF   xFC
02D54:  MOVLW  1C
02D56:  MOVWF  xFB
02D58:  MOVLB  6
02D5A:  CLRF   x00
02D5C:  MOVLW  04
02D5E:  MOVLB  5
02D60:  MOVWF  xFF
02D62:  MOVLB  6
02D64:  MOVWF  x02
02D66:  MOVLW  B3
02D68:  MOVWF  x01
02D6A:  MOVLB  0
02D6C:  RCALL  2B2E
02D6E:  MOVF   01,W
02D70:  MOVLB  4
02D72:  ADDWF  xAA,F
....................    ec += mmcsd_read_data(32, 4, &Large_Sectors); 
02D74:  MOVLB  5
02D76:  CLRF   xFE
02D78:  CLRF   xFD
02D7A:  CLRF   xFC
02D7C:  MOVLW  20
02D7E:  MOVWF  xFB
02D80:  MOVLB  6
02D82:  CLRF   x00
02D84:  MOVLW  04
02D86:  MOVLB  5
02D88:  MOVWF  xFF
02D8A:  MOVLB  6
02D8C:  MOVWF  x02
02D8E:  MOVLW  B7
02D90:  MOVWF  x01
02D92:  MOVLB  0
02D94:  RCALL  2B2E
02D96:  MOVF   01,W
02D98:  MOVLB  4
02D9A:  ADDWF  xAA,F
.................... #ifdef FAT16 
....................    Next_Free_Clust = 2; 
.................... #else 
....................    ec += mmcsd_read_data(0x3EC, 4, &Next_Free_Clust); 
02D9C:  MOVLB  5
02D9E:  CLRF   xFE
02DA0:  CLRF   xFD
02DA2:  MOVLW  03
02DA4:  MOVWF  xFC
02DA6:  MOVLW  EC
02DA8:  MOVWF  xFB
02DAA:  MOVLB  6
02DAC:  CLRF   x00
02DAE:  MOVLW  04
02DB0:  MOVLB  5
02DB2:  MOVWF  xFF
02DB4:  MOVLW  03
02DB6:  MOVLB  6
02DB8:  MOVWF  x02
02DBA:  MOVLW  A1
02DBC:  MOVWF  x01
02DBE:  MOVLB  0
02DC0:  RCALL  2B2E
02DC2:  MOVF   01,W
02DC4:  MOVLB  4
02DC6:  ADDWF  xAA,F
.................... #endif 
....................    if(ec != GOODEC) 
02DC8:  MOVF   xAA,F
02DCA:  BZ    2DD2
....................       return EOF; 
02DCC:  MOVLW  FF
02DCE:  MOVWF  01
02DD0:  BRA    2EAC
....................  
....................    // figure out the size of a cluster 
....................    Bytes_Per_Cluster = Sectors_Per_Cluster * Bytes_Per_Sector; 
02DD2:  CLRF   xC0
02DD4:  MOVFF  4AC,4BF
02DD8:  MOVFF  4AE,4C2
02DDC:  MOVFF  4AD,4C1
02DE0:  MOVLB  0
02DE2:  RCALL  2BC6
02DE4:  MOVFF  02,396
02DE8:  MOVFF  01,395
....................  
....................    // figure out how long one FAT is 
....................    FAT_Length = Sectors_Per_FAT * (int32)Bytes_Per_Sector; 
02DEC:  MOVFF  4AD,00
02DF0:  MOVFF  4AE,01
02DF4:  CLRF   02
02DF6:  CLRF   03
02DF8:  MOVFF  03,4C2
02DFC:  MOVFF  02,4C1
02E00:  MOVFF  4AE,4C0
02E04:  MOVFF  4AD,4BF
02E08:  MOVFF  4BE,61B
02E0C:  MOVFF  4BD,61A
02E10:  MOVFF  4BC,619
02E14:  MOVFF  4BB,618
02E18:  MOVFF  03,61F
02E1C:  MOVFF  02,61E
02E20:  MOVFF  4AE,61D
02E24:  MOVFF  4AD,61C
02E28:  RCALL  2BE8
02E2A:  MOVFF  03,3A0
02E2E:  MOVFF  02,39F
02E32:  MOVFF  01,39E
02E36:  MOVFF  00,39D
....................  
....................    // figure out where the FAT starts 
....................    FAT_Start = Reserved_Sectors * Bytes_Per_Sector; 
02E3A:  MOVFF  4B0,4C0
02E3E:  MOVFF  4AF,4BF
02E42:  MOVFF  4AE,4C2
02E46:  MOVFF  4AD,4C1
02E4A:  RCALL  2BC6
02E4C:  MOVFF  02,398
02E50:  MOVFF  01,397
....................  
....................    // figure out where the root directory starts 
....................    Root_Dir = FAT_Start + (FATs * FAT_Length); 
02E54:  MOVLB  6
02E56:  CLRF   x1B
02E58:  CLRF   x1A
02E5A:  CLRF   x19
02E5C:  MOVFF  4AB,618
02E60:  MOVFF  3A0,61F
02E64:  MOVFF  39F,61E
02E68:  MOVFF  39E,61D
02E6C:  MOVFF  39D,61C
02E70:  MOVLB  0
02E72:  RCALL  2BE8
02E74:  MOVF   00,W
02E76:  MOVLB  3
02E78:  ADDWF  x97,W
02E7A:  MOVWF  xA5
02E7C:  MOVF   01,W
02E7E:  ADDWFC x98,W
02E80:  MOVWF  xA6
02E82:  MOVLW  00
02E84:  ADDWFC 02,W
02E86:  MOVWF  xA7
02E88:  MOVLW  00
02E8A:  ADDWFC 03,W
02E8C:  MOVWF  xA8
....................  
....................    // figure out where data for files in the root directory starts 
.................... #ifdef FAT32 
....................    Data_Start = Bytes_Per_Cluster + Root_Dir; 
02E8E:  MOVF   x95,W
02E90:  ADDWF  xA5,W
02E92:  MOVWF  x99
02E94:  MOVF   x96,W
02E96:  ADDWFC xA6,W
02E98:  MOVWF  x9A
02E9A:  MOVLW  00
02E9C:  ADDWFC xA7,W
02E9E:  MOVWF  x9B
02EA0:  MOVLW  00
02EA2:  ADDWFC xA8,W
02EA4:  MOVWF  x9C
.................... #else // FAT16 
....................    Data_Start = (Root_Entries * 0x20) + (Bytes_Per_Sector - 1); 
....................    Data_Start /= Bytes_Per_Sector; 
....................    Data_Start += Reserved_Sectors + (FATs * Sectors_Per_FAT); 
....................    Data_Start *= Bytes_Per_Sector; 
.................... #endif // #ifdef FAT32 
....................  
....................    return GOODEC; 
02EA6:  MOVLW  00
02EA8:  MOVWF  01
02EAA:  MOVLB  4
02EAC:  MOVLB  0
02EAE:  GOTO   60AC (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_next_cluster(int16* my_cluster) 
.................... Summary: Gets the next linked cluster from the FAT. 
.................... Param: A pointer to a variable that holds a cluster. 
....................         This variable will then have the next linked cluster when the function returns. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int get_next_cluster(int32* my_cluster) 
.................... #else 
.................... signed int get_next_cluster(int16* my_cluster) 
.................... #endif 
.................... { 
....................    // convert the current cluster into the address of where information about 
....................    //  the cluster is stored in the FAT, and put this value into the current cluster 
.................... #ifdef FAT32 
....................    if(mmcsd_read_data((*my_cluster << 2) + FAT_Start, 4, my_cluster) != GOODEC) 
*
037A6:  MOVFF  5DA,03
037AA:  MOVLB  5
037AC:  MOVFF  5D9,FE9
037B0:  MOVFF  5DA,FEA
037B4:  MOVFF  FEF,5DB
037B8:  MOVFF  FEC,5DC
037BC:  MOVFF  FEC,5DD
037C0:  MOVFF  FEC,5DE
037C4:  RLCF   xDB,F
037C6:  RLCF   xDC,F
037C8:  RLCF   xDD,F
037CA:  RLCF   xDE,F
037CC:  RLCF   xDB,F
037CE:  RLCF   xDC,F
037D0:  RLCF   xDD,F
037D2:  RLCF   xDE,F
037D4:  MOVLW  FC
037D6:  ANDWF  xDB,F
037D8:  MOVLB  3
037DA:  MOVF   x97,W
037DC:  MOVLB  5
037DE:  ADDWF  xDB,F
037E0:  MOVLB  3
037E2:  MOVF   x98,W
037E4:  MOVLB  5
037E6:  ADDWFC xDC,F
037E8:  MOVLW  00
037EA:  ADDWFC xDD,F
037EC:  ADDWFC xDE,F
037EE:  MOVFF  5DE,5FE
037F2:  MOVFF  5DD,5FD
037F6:  MOVFF  5DC,5FC
037FA:  MOVFF  5DB,5FB
037FE:  MOVLB  6
03800:  CLRF   x00
03802:  MOVLW  04
03804:  MOVLB  5
03806:  MOVWF  xFF
03808:  MOVFF  5DA,602
0380C:  MOVFF  5D9,601
03810:  MOVLB  0
03812:  CALL   2B2E
03816:  MOVF   01,F
03818:  BZ    3820
....................       return EOF; 
0381A:  MOVLW  FF
0381C:  MOVWF  01
0381E:  BRA    3824
.................... #else // FAT16 
....................    if(mmcsd_read_data((*my_cluster << 1) + FAT_Start, 2, my_cluster) != GOODEC) 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................    return GOODEC; 
03820:  MOVLW  00
03822:  MOVWF  01
03824:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_prev_cluster(int32* my_cluster) 
.................... Summary: Gets the previously linked cluster in the FAT. 
.................... Param: A pointer to a variable that holds a cluster. 
....................         This variable will then have the previous linked cluster when the function returns. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... #ifdef FAT32 
.................... signed int get_prev_cluster(int32* my_cluster) 
.................... #else 
*
03220:  MOVLB  5
03222:  CLRF   xDF
03224:  CLRF   xDE
03226:  CLRF   xDD
03228:  MOVLW  01
0322A:  MOVWF  xDC
0322C:  CLRF   xE3
0322E:  CLRF   xE2
03230:  CLRF   xE1
03232:  CLRF   xE0
.................... signed int get_prev_cluster(int16* my_cluster) 
.................... #endif // #ifdef FAT32 
.................... { 
.................... #ifdef FAT32 
....................    int32 
....................       cur_cluster = 1, 
....................       target_cluster = 0; 
.................... #else 
....................    int16 
....................       cur_cluster = 1, 
....................       target_cluster = 0; 
.................... #endif // #ifdef FAT32 
....................     
....................    while(target_cluster != *my_cluster) 
03234:  MOVFF  5DA,FE9
03238:  MOVFF  5DB,FEA
0323C:  MOVFF  FEF,00
03240:  MOVFF  FEC,01
03244:  MOVFF  FEC,02
03248:  MOVFF  FEC,03
0324C:  MOVF   00,W
0324E:  SUBWF  xE0,W
03250:  BNZ   3264
03252:  MOVF   01,W
03254:  SUBWF  xE1,W
03256:  BNZ   3264
03258:  MOVF   02,W
0325A:  SUBWF  xE2,W
0325C:  BNZ   3264
0325E:  MOVF   03,W
03260:  SUBWF  xE3,W
03262:  BZ    32D8
....................    {    
....................       cur_cluster += 1; 
03264:  MOVLW  01
03266:  ADDWF  xDC,F
03268:  MOVLW  00
0326A:  ADDWFC xDD,F
0326C:  ADDWFC xDE,F
0326E:  ADDWFC xDF,F
.................... #ifdef FAT32 
....................       if(mmcsd_read_data((cur_cluster << 2) + FAT_Start, 4, &target_cluster) != GOODEC) 
03270:  RLCF   xDC,W
03272:  MOVWF  xE5
03274:  RLCF   xDD,W
03276:  MOVWF  xE6
03278:  RLCF   xDE,W
0327A:  MOVWF  xE7
0327C:  RLCF   xDF,W
0327E:  MOVWF  xE8
03280:  RLCF   xE5,F
03282:  RLCF   xE6,F
03284:  RLCF   xE7,F
03286:  RLCF   xE8,F
03288:  MOVLW  FC
0328A:  ANDWF  xE5,F
0328C:  MOVLB  3
0328E:  MOVF   x97,W
03290:  MOVLB  5
03292:  ADDWF  xE5,F
03294:  MOVLB  3
03296:  MOVF   x98,W
03298:  MOVLB  5
0329A:  ADDWFC xE6,F
0329C:  MOVLW  00
0329E:  ADDWFC xE7,F
032A0:  ADDWFC xE8,F
032A2:  MOVFF  5E8,5FE
032A6:  MOVFF  5E7,5FD
032AA:  MOVFF  5E6,5FC
032AE:  MOVFF  5E5,5FB
032B2:  MOVLB  6
032B4:  CLRF   x00
032B6:  MOVLW  04
032B8:  MOVLB  5
032BA:  MOVWF  xFF
032BC:  MOVLW  05
032BE:  MOVLB  6
032C0:  MOVWF  x02
032C2:  MOVLW  E0
032C4:  MOVWF  x01
032C6:  MOVLB  0
032C8:  RCALL  2B2E
032CA:  MOVF   01,F
032CC:  BZ    32D4
....................          return EOF; 
032CE:  MOVLW  FF
032D0:  MOVWF  01
032D2:  BRA    32F4
.................... #else // FAT16 
032D4:  MOVLB  5
032D6:  BRA    3234
....................       if(mmcsd_read_data((cur_cluster << 1) + FAT_Start, 2, &target_cluster) != GOODEC) 
....................          return EOF; 
.................... #endif // #ifdef FAT32 
....................    } 
....................     
.................... #ifdef FAT32 
....................    *my_cluster = cur_cluster;                         
032D8:  MOVFF  5DA,FE9
032DC:  MOVFF  5DB,FEA
032E0:  MOVFF  5DC,FEF
032E4:  MOVFF  5DD,FEC
032E8:  MOVFF  5DE,FEC
032EC:  MOVFF  5DF,FEC
.................... #else // FAT16 
....................    *my_cluster = cur_cluster; 
.................... #endif // #ifdef FAT32    
....................     
....................    return GOODEC; 
032F0:  MOVLW  00
032F2:  MOVWF  01
032F4:  MOVLB  0
032F6:  GOTO   347E (RETURN)
.................... } 
....................  
.................... /* 
.................... signed int get_next_addr(int32* my_addr) 
.................... Summary: Get the next linked address. 
.................... Param: A pointer to a variable that holds an address. 
....................         This variable will then have the next linked address when the function returns. 
.................... Returns: EOF if there was a problem with the media or we've reached the last linked cluster in the FAT, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_next_addr(int32* my_addr) 
.................... { 
.................... #ifdef FAT32 
....................    int32 temp; 
.................... #else // FAT16 
....................    int16 temp; 
.................... #endif // #ifdef FAT32 
....................  
....................    // check to make sure that the next iteration will give us a contiguous address 
.................... #ifdef FAT32 
....................    if((*my_addr + 1) % Bytes_Per_Cluster == 0) 
*
03E2E:  MOVFF  5D4,03
03E32:  MOVLB  5
03E34:  MOVFF  5D3,FE9
03E38:  MOVFF  5D4,FEA
03E3C:  MOVFF  FEF,5D9
03E40:  MOVFF  FEC,5DA
03E44:  MOVFF  FEC,5DB
03E48:  MOVFF  FEC,5DC
03E4C:  MOVLW  01
03E4E:  ADDWF  xD9,F
03E50:  MOVLW  00
03E52:  ADDWFC xDA,F
03E54:  ADDWFC xDB,F
03E56:  ADDWFC xDC,F
03E58:  MOVFF  FEA,5DE
03E5C:  MOVFF  FE9,5DD
03E60:  BSF    FD8.1
03E62:  MOVLW  05
03E64:  MOVWF  FEA
03E66:  MOVLW  DF
03E68:  MOVWF  FE9
03E6A:  MOVFF  5DC,5E9
03E6E:  MOVFF  5DB,5E8
03E72:  MOVFF  5DA,5E7
03E76:  MOVFF  5D9,5E6
03E7A:  CLRF   xED
03E7C:  CLRF   xEC
03E7E:  MOVFF  396,5EB
03E82:  MOVFF  395,5EA
03E86:  MOVLB  0
03E88:  CALL   3116
03E8C:  MOVFF  5DF,00
03E90:  MOVFF  5E0,01
03E94:  MOVFF  5E1,02
03E98:  MOVFF  5E2,03
03E9C:  MOVFF  5DE,FEA
03EA0:  MOVFF  5DD,FE9
03EA4:  MOVFF  5E2,5DC
03EA8:  MOVFF  5E1,5DB
03EAC:  MOVFF  5E0,5DA
03EB0:  MOVFF  5DF,5D9
03EB4:  MOVLB  5
03EB6:  MOVF   xD9,F
03EB8:  BTFSS  FD8.2
03EBA:  BRA    3F92
03EBC:  MOVF   xDA,F
03EBE:  BNZ   3F92
03EC0:  MOVF   xDB,F
03EC2:  BNZ   3F92
03EC4:  MOVF   xDC,F
03EC6:  BNZ   3F92
.................... #else // FAT16 
....................    // we have to handle this differently because of the way FAT16 handles the root directory 
....................    if(((*my_addr + 1) % Bytes_Per_Cluster == 0) 
....................       && (*my_addr >= Data_Start)) 
.................... #endif // #ifdef FAT32 
....................    { 
....................       // convert the current address into the address of where information about 
....................       //  the address is stored in the FAT, and put this value into the current address 
....................       temp = addr_to_cluster(*my_addr); 
03EC8:  MOVFF  5D4,03
03ECC:  MOVFF  5D3,FE9
03ED0:  MOVFF  5D4,FEA
03ED4:  MOVFF  FEF,5D9
03ED8:  MOVFF  FEC,5DA
03EDC:  MOVFF  FEC,5DB
03EE0:  MOVFF  FEC,5DC
03EE4:  MOVFF  5DC,5E1
03EE8:  MOVFF  5DB,5E0
03EEC:  MOVFF  5DA,5DF
03EF0:  MOVFF  5D9,5DE
03EF4:  MOVLB  0
03EF6:  CALL   31AA
03EFA:  MOVFF  03,5D8
03EFE:  MOVFF  02,5D7
03F02:  MOVFF  01,5D6
03F06:  MOVFF  00,5D5
....................       if(get_next_cluster(&temp) == EOF) 
03F0A:  MOVLW  05
03F0C:  MOVLB  5
03F0E:  MOVWF  xDA
03F10:  MOVLW  D5
03F12:  MOVWF  xD9
03F14:  MOVLB  0
03F16:  RCALL  37A6
03F18:  MOVF   01,W
03F1A:  SUBLW  FF
03F1C:  BNZ   3F24
....................          return EOF; 
03F1E:  MOVLW  FF
03F20:  MOVWF  01
03F22:  BRA    3FCC
.................... #ifdef FAT32 
....................       if((temp == 0xFFFFFFFF) 
....................          || (temp == 0x0FFFFFFF)) // WinXP will format the root directory's FAT entry to 0x0FFFFFFF. 
03F24:  MOVLB  5
03F26:  INCFSZ xD5,W
03F28:  BRA    3F38
03F2A:  INCFSZ xD6,W
03F2C:  BRA    3F38
03F2E:  INCFSZ xD7,W
03F30:  BRA    3F38
03F32:  INCFSZ xD8,W
03F34:  BRA    3F38
03F36:  BRA    3F4A
03F38:  INCFSZ xD5,W
03F3A:  BRA    3F54
03F3C:  INCFSZ xD6,W
03F3E:  BRA    3F54
03F40:  INCFSZ xD7,W
03F42:  BRA    3F54
03F44:  MOVF   xD8,W
03F46:  SUBLW  0F
03F48:  BNZ   3F54
....................          return EOF; 
03F4A:  MOVLW  FF
03F4C:  MOVWF  01
03F4E:  MOVLB  0
03F50:  BRA    3FCC
03F52:  MOVLB  5
.................... #else // FAT16 
....................       if(temp == 0xFFFF) 
....................          return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................       *my_addr = cluster_to_addr(temp); 
03F54:  MOVFF  5D4,03
03F58:  MOVFF  5D3,5D9
03F5C:  MOVFF  5D4,5DA
03F60:  MOVFF  5D8,613
03F64:  MOVFF  5D7,612
03F68:  MOVFF  5D6,611
03F6C:  MOVFF  5D5,610
03F70:  MOVLB  0
03F72:  CALL   32FA
03F76:  MOVFF  5DA,FEA
03F7A:  MOVFF  5D9,FE9
03F7E:  MOVFF  00,FEF
03F82:  MOVFF  01,FEC
03F86:  MOVFF  02,FEC
03F8A:  MOVFF  03,FEC
....................    } 
03F8E:  BRA    3FC8
03F90:  MOVLB  5
....................    else 
....................       *my_addr += 1; 
03F92:  MOVFF  5D3,FE9
03F96:  MOVFF  5D4,FEA
03F9A:  MOVLW  01
03F9C:  ADDWF  FEF,W
03F9E:  MOVWF  00
03FA0:  MOVLW  00
03FA2:  ADDWFC FEC,W
03FA4:  MOVWF  01
03FA6:  MOVLW  00
03FA8:  ADDWFC FEC,W
03FAA:  MOVWF  02
03FAC:  MOVLW  00
03FAE:  ADDWFC FEC,W
03FB0:  MOVWF  03
03FB2:  MOVF   FED,F
03FB4:  MOVF   FED,F
03FB6:  MOVF   FED,F
03FB8:  MOVFF  00,FEF
03FBC:  MOVFF  01,FEC
03FC0:  MOVFF  02,FEC
03FC4:  MOVWF  FEC
03FC6:  MOVLB  0
....................  
....................    return GOODEC; 
03FC8:  MOVLW  00
03FCA:  MOVWF  01
03FCC:  RETURN 0
.................... } 
....................  
.................... /* 
.................... signed int get_prev_addr(int32* my_addr) 
.................... Summary: Get the next linked address. 
.................... Param: A pointer to a variable that holds an address. 
....................         This variable will then have the next linked address when the function returns. 
.................... Returns: EOF if there was a problem with the media or we've reached the last linked cluster in the FAT, GOODEC if everything went okay. 
.................... */ 
.................... signed int get_prev_addr(int32* my_addr) 
.................... { 
.................... #ifdef FAT32 
....................    int32 temp; 
.................... #else // FAT16 
....................    int16 temp; 
.................... #endif // #ifdef FAT32 
....................  
....................    // if we're trying to go backwards one entry from the beginning of the root, 
....................    //  we won't be able to... 
....................    if(*my_addr <= Root_Dir) 
*
03356:  MOVFF  5D5,03
0335A:  MOVLB  5
0335C:  MOVFF  5D4,FE9
03360:  MOVFF  5D5,FEA
03364:  MOVFF  FEF,5DA
03368:  MOVFF  FEC,5DB
0336C:  MOVFF  FEC,5DC
03370:  MOVFF  FEC,5DD
03374:  MOVF   xDD,W
03376:  MOVLB  3
03378:  SUBWF  xA8,W
0337A:  BNC   33A6
0337C:  BNZ   33A0
0337E:  MOVLB  5
03380:  MOVF   xDC,W
03382:  MOVLB  3
03384:  SUBWF  xA7,W
03386:  BNC   33A6
03388:  BNZ   33A0
0338A:  MOVLB  5
0338C:  MOVF   xDB,W
0338E:  MOVLB  3
03390:  SUBWF  xA6,W
03392:  BNC   33A6
03394:  BNZ   33A0
03396:  MOVLB  5
03398:  MOVF   xDA,W
0339A:  MOVLB  3
0339C:  SUBWF  xA5,W
0339E:  BNC   33A6
....................       return GOODEC; 
033A0:  MOVLW  00
033A2:  MOVWF  01
033A4:  BRA    3534
....................  
....................    // check to make sure that the next iteration will give us a contiguous address 
.................... #ifdef FAT32 
....................    if(*my_addr % Bytes_Per_Cluster == 0) 
033A6:  MOVFF  5D5,03
033AA:  MOVLB  5
033AC:  MOVFF  5D4,FE9
033B0:  MOVFF  5D5,FEA
033B4:  MOVFF  FEF,5DA
033B8:  MOVFF  FEC,5DB
033BC:  MOVFF  FEC,5DC
033C0:  MOVFF  FEC,5DD
033C4:  MOVFF  FEA,5DF
033C8:  MOVFF  FE9,5DE
033CC:  BSF    FD8.1
033CE:  MOVLW  05
033D0:  MOVWF  FEA
033D2:  MOVLW  E0
033D4:  MOVWF  FE9
033D6:  MOVFF  5DD,5E9
033DA:  MOVFF  5DC,5E8
033DE:  MOVFF  5DB,5E7
033E2:  MOVFF  5DA,5E6
033E6:  CLRF   xED
033E8:  CLRF   xEC
033EA:  MOVFF  396,5EB
033EE:  MOVFF  395,5EA
033F2:  MOVLB  0
033F4:  RCALL  3116
033F6:  MOVFF  5E0,00
033FA:  MOVFF  5E1,01
033FE:  MOVFF  5E2,02
03402:  MOVFF  5E3,03
03406:  MOVFF  5DF,FEA
0340A:  MOVFF  5DE,FE9
0340E:  MOVFF  5E3,5DD
03412:  MOVFF  5E2,5DC
03416:  MOVFF  5E1,5DB
0341A:  MOVFF  5E0,5DA
0341E:  MOVLB  5
03420:  MOVF   xDA,F
03422:  BNZ   34FC
03424:  MOVF   xDB,F
03426:  BNZ   34FC
03428:  MOVF   xDC,F
0342A:  BNZ   34FC
0342C:  MOVF   xDD,F
0342E:  BNZ   34FC
.................... #else // FAT16 
....................    // we have to handle this differently because of the way FAT16 handles the root directory 
....................    if((*my_addr % Bytes_Per_Cluster == 0) 
....................       && (*my_addr >= Data_Start)) 
.................... #endif // #ifdef FAT32 
....................    { 
....................       temp = addr_to_cluster(*my_addr); 
03430:  MOVFF  5D5,03
03434:  MOVFF  5D4,FE9
03438:  MOVFF  5D5,FEA
0343C:  MOVFF  FEF,5DA
03440:  MOVFF  FEC,5DB
03444:  MOVFF  FEC,5DC
03448:  MOVFF  FEC,5DD
0344C:  MOVFF  5DD,5E1
03450:  MOVFF  5DC,5E0
03454:  MOVFF  5DB,5DF
03458:  MOVFF  5DA,5DE
0345C:  MOVLB  0
0345E:  RCALL  31AA
03460:  MOVFF  03,5D9
03464:  MOVFF  02,5D8
03468:  MOVFF  01,5D7
0346C:  MOVFF  00,5D6
....................       if(get_prev_cluster(&temp) == EOF) 
03470:  MOVLW  05
03472:  MOVLB  5
03474:  MOVWF  xDB
03476:  MOVLW  D6
03478:  MOVWF  xDA
0347A:  MOVLB  0
0347C:  BRA    3220
0347E:  MOVF   01,W
03480:  SUBLW  FF
03482:  BNZ   348E
....................          return EOF; 
03484:  MOVLW  FF
03486:  MOVWF  01
03488:  MOVLB  3
0348A:  BRA    3534
0348C:  MOVLB  0
....................  
....................       *my_addr = cluster_to_addr(temp) + (Bytes_Per_Cluster - 1); 
0348E:  MOVFF  5D5,03
03492:  MOVFF  5D4,5DA
03496:  MOVFF  5D5,5DB
0349A:  MOVFF  5D9,613
0349E:  MOVFF  5D8,612
034A2:  MOVFF  5D7,611
034A6:  MOVFF  5D6,610
034AA:  MOVLB  0
034AC:  RCALL  32FA
034AE:  MOVFF  03,5DF
034B2:  MOVFF  02,5DE
034B6:  MOVFF  01,5DD
034BA:  MOVFF  00,5DC
034BE:  MOVLW  01
034C0:  MOVLB  3
034C2:  SUBWF  x95,W
034C4:  MOVWF  00
034C6:  MOVLW  00
034C8:  SUBWFB x96,W
034CA:  MOVWF  03
034CC:  MOVF   00,W
034CE:  MOVLB  5
034D0:  ADDWF  xDC,W
034D2:  MOVWF  00
034D4:  MOVF   03,W
034D6:  ADDWFC 01,W
034D8:  MOVWF  01
034DA:  MOVLW  00
034DC:  ADDWFC 02,W
034DE:  MOVWF  02
034E0:  MOVLW  00
034E2:  ADDWFC xDF,W
034E4:  MOVFF  5DB,FEA
034E8:  MOVFF  5DA,FE9
034EC:  MOVFF  00,FEF
034F0:  MOVFF  01,FEC
034F4:  MOVFF  02,FEC
034F8:  MOVWF  FEC
....................    } 
034FA:  BRA    352E
....................    else 
....................       *my_addr -= 1; 
034FC:  MOVFF  5D4,FE9
03500:  MOVFF  5D5,FEA
03504:  MOVLW  01
03506:  SUBWF  FEF,W
03508:  MOVWF  00
0350A:  MOVLW  00
0350C:  SUBWFB FEC,W
0350E:  MOVWF  01
03510:  MOVLW  00
03512:  SUBWFB FEC,W
03514:  MOVWF  02
03516:  MOVLW  00
03518:  SUBWFB FEC,W
0351A:  MOVF   FED,F
0351C:  MOVF   FED,F
0351E:  MOVF   FED,F
03520:  MOVFF  00,FEF
03524:  MOVFF  01,FEC
03528:  MOVFF  02,FEC
0352C:  MOVWF  FEC
....................  
....................    return GOODEC; 
0352E:  MOVLW  00
03530:  MOVWF  01
03532:  MOVLB  3
03534:  MOVLB  0
03536:  GOTO   356C (RETURN)
.................... } 
....................  
.................... /* 
.................... int32 cluster_to_addr(int32 cluster) 
.................... Summary: Converts a cluster number to an address. 
.................... Param: The cluster to convert. 
.................... Returns: The cluster's address. 
.................... */ 
.................... #ifdef FAT32 
.................... int32 cluster_to_addr(int32 cluster) 
.................... { 
....................    // in unit math: 
....................    //  return  Bytes+(Bytes  /  Cluster * (Clusters - Clusters)) 
....................    return Root_Dir + (Bytes_Per_Cluster * (cluster - 2)); 
*
032FA:  MOVLW  02
032FC:  MOVLB  6
032FE:  SUBWF  x10,W
03300:  MOVWF  00
03302:  MOVLW  00
03304:  SUBWFB x11,W
03306:  MOVWF  01
03308:  MOVLW  00
0330A:  SUBWFB x12,W
0330C:  MOVWF  02
0330E:  MOVLW  00
03310:  SUBWFB x13,W
03312:  MOVWF  03
03314:  MOVWF  x17
03316:  MOVFF  02,616
0331A:  MOVFF  01,615
0331E:  MOVFF  00,614
03322:  CLRF   x1B
03324:  CLRF   x1A
03326:  MOVFF  396,619
0332A:  MOVFF  395,618
0332E:  MOVWF  x1F
03330:  MOVFF  02,61E
03334:  MOVFF  01,61D
03338:  MOVFF  00,61C
0333C:  MOVLB  0
0333E:  RCALL  2BE8
03340:  MOVLB  3
03342:  MOVF   xA5,W
03344:  ADDWF  00,F
03346:  MOVF   xA6,W
03348:  ADDWFC 01,F
0334A:  MOVF   xA7,W
0334C:  ADDWFC 02,F
0334E:  MOVF   xA8,W
03350:  ADDWFC 03,F
03352:  MOVLB  0
03354:  RETURN 0
.................... } 
.................... #else 
.................... int32 cluster_to_addr(int16 cluster) 
.................... { 
....................    if(cluster < 2) 
....................       return 0; 
....................    // in unit math: 
....................    //  return  Bytes + (       Bytes  /  Cluster * (Clusters- Clusters)) 
....................    return Data_Start + ((int32)Bytes_Per_Cluster * (cluster - 2)); 
.................... } 
.................... #endif 
....................  
.................... /* 
.................... int32 addr_to_cluster(int32 addr) 
.................... Summary: Converts an address to a cluster number. 
.................... Param: The address to convert. 
.................... Returns: The address's cluster. 
.................... */ 
.................... #ifdef FAT32 
.................... int32 addr_to_cluster(int32 addr) 
.................... { 
....................    // in unit math: 
....................    //  return (Bytes -Bytes) / Bytes  /  Cluster) + Clusters 
....................    return ((addr - Root_Dir) / Bytes_Per_Cluster) + 2; 
*
031AA:  MOVLB  3
031AC:  MOVF   xA5,W
031AE:  MOVLB  5
031B0:  SUBWF  xDE,W
031B2:  MOVWF  xE2
031B4:  MOVLB  3
031B6:  MOVF   xA6,W
031B8:  MOVLB  5
031BA:  SUBWFB xDF,W
031BC:  MOVWF  xE3
031BE:  MOVLB  3
031C0:  MOVF   xA7,W
031C2:  MOVLB  5
031C4:  SUBWFB xE0,W
031C6:  MOVWF  xE4
031C8:  MOVLB  3
031CA:  MOVF   xA8,W
031CC:  MOVLB  5
031CE:  SUBWFB xE1,W
031D0:  MOVWF  xE5
031D2:  BCF    FD8.1
031D4:  MOVWF  xE9
031D6:  MOVFF  5E4,5E8
031DA:  MOVFF  5E3,5E7
031DE:  MOVFF  5E2,5E6
031E2:  CLRF   xED
031E4:  CLRF   xEC
031E6:  MOVFF  396,5EB
031EA:  MOVFF  395,5EA
031EE:  MOVLB  0
031F0:  RCALL  3116
031F2:  MOVFF  03,5E5
031F6:  MOVFF  02,5E4
031FA:  MOVFF  01,5E3
031FE:  MOVFF  00,5E2
03202:  MOVLW  02
03204:  MOVLB  5
03206:  ADDWF  00,W
03208:  MOVWF  00
0320A:  MOVLW  00
0320C:  ADDWFC 01,W
0320E:  MOVWF  01
03210:  MOVLW  00
03212:  ADDWFC 02,W
03214:  MOVWF  02
03216:  MOVLW  00
03218:  ADDWFC 03,W
0321A:  MOVWF  03
0321C:  MOVLB  0
0321E:  RETURN 0
.................... } 
.................... #else 
.................... int16 addr_to_cluster(int32 addr) 
.................... { 
....................    if(addr < Data_Start) 
....................       return 0; 
....................    // in unit math: 
....................    //  return (Bytes -Bytes)   /(Bytes  /  Cluster) + Clusters 
....................    return ((addr - Data_Start) / Bytes_Per_Cluster) + 2; 
.................... } 
.................... #endif 
.................... /* 
.................... signed int format(int32 DskSize) 
.................... Summary: Formats media with a FAT filesystem. 
.................... Param: The size of the filesystem to create in kB. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... Note: There are certain minimum and maximum size restrictions on the card and type of file system. The restrictions are as follows: 
....................        FAT16: DskSize < 2GB 
....................        FAT32: 33MB < DskSize < 32GB 
....................        In order to change the way that the drive is formatted, select the proper #define(FAT16 or FAT32) way up at the top of this file. 
.................... Note: In this context, 1kB = 1024B = 2^10B. Please don't confuse this with 10^3B, we don't want to be wasting thousands of bytes of information now, do we? 
.................... Note: DskSize has a lower limit of 64, anything lower becomes highly inefficient and runs the risk of very quick corruption. 
.................... Note: If this is called on an MMC/SD card, Windows will recognize it as a RAW filesystem. 
.................... */ 
.................... signed int format(int32 DskSize) 
.................... { 
....................    int 
....................       BPB_Media = 0xF8, 
....................       BPB_NumFATs = 1, 
....................       BPB_NumHeads = 2, 
....................       BPB_SecPerClus, 
....................       BPB_SecPerTrk = 0x20; 
....................  
....................    int16 
....................       BPB_BytsPerSec = 0x200, 
....................       i; 
....................  
....................    int32 
....................       BPB_TotSec, 
....................       BS_VolID = 0, 
....................       RootDirSectors, 
....................       TmpVal1, 
....................       TmpVal2; 
....................  
....................    char                
....................       BS_OEMName[] = "MSDOS5.0", 
....................       BS_VolLab[] = "NO NAME    "; 
....................  
.................... #ifdef FAT32 
....................    int 
....................       BPB_BkBootSec = 6, 
....................       BPB_FSInfo = 1, 
....................       BPB_RootClus = 2, 
....................       BS_BootSig = 0x29, 
....................       BS_jmpBoot = 0x58, 
....................       data[0x5A]; 
....................  
....................    int16 
....................       BPB_RootEntCnt = 0, 
....................       BPB_RsvdSecCnt = 32; 
....................     
....................    int32 BPB_FATSz; 
....................     
....................    char BS_FilSysType[] = "FAT32   "; 
.................... #else 
....................    int 
....................       BS_BootSig = 0x29, 
....................       BS_jmpBoot = 0x3C, 
....................       data[0x3E]; 
....................        
....................    int16 
....................       BPB_FATSz, 
....................       BPB_RootEntCnt = 512, 
....................       BPB_RsvdSecCnt = 1; 
....................        
....................    char BS_FilSysType[] = "FAT12   "; 
.................... #endif // #ifdef FAT32 
....................  
....................    // initialize variables 
....................    // figure out total sectors 
....................    BPB_TotSec = (DskSize * 0x400) / BPB_BytsPerSec; 
....................     
....................    // use the magical table on page 20 of fatgen103.pdf to determine sectors per cluster 
.................... #ifdef FAT32 
....................    if(DskSize < 0x8400) // < 33 MB; this is too small 
....................       return EOF; 
....................    else if(DskSize < 0x41000) // 260 MB 
....................       BPB_SecPerClus = 1; 
....................    else if(DskSize < 0X800000) // 8 GB 
....................       BPB_SecPerClus = 8; 
....................    else if(DskSize < 0x1000000) // 16 GB 
....................       BPB_SecPerClus = 16; 
....................    else if(DskSize < 0x2000000) // 32 GB 
....................       BPB_SecPerClus = 32; 
....................    else // > 32 GB; this is too big 
....................       return EOF; 
.................... #else 
....................    if(DskSize < 0x1400) // < 5 MB 
....................       BPB_SecPerClus = 1; 
....................    else if(DskSize < 0x4000) // 16 MB 
....................       BPB_SecPerClus = 2; 
....................    else if(DskSize < 0X20000) // 128 MB 
....................       BPB_SecPerClus = 4; 
....................    else if(DskSize < 0x40000) // 256 MB 
....................       BPB_SecPerClus = 8; 
....................    else if(DskSize < 0x80000) // 512 MB 
....................       BPB_SecPerClus = 16; 
....................    else if(DskSize < 0x100000) // 1 GB 
....................       BPB_SecPerClus = 32; 
....................    else if(DskSize < 0x200000) // 2 GB 
....................       BPB_SecPerClus = 64; 
....................    else // > 2 GB; this is too big 
....................       return EOF; 
.................... #endif // #ifdef FAT32 
....................  
....................    // figure out how many sectors one FAT takes up 
....................    RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec - 1)) / BPB_BytsPerSec;  
....................    TmpVal1 = DskSize - (BPB_RsvdSecCnt + RootDirSectors);  
....................    TmpVal2 = (256 * BPB_SecPerClus) + BPB_NumFATs;  
.................... #ifdef FAT32 
....................    TmpVal2 = TmpVal2 / 2; 
.................... #endif // #ifdef FAT32  
....................    BPB_FATSz = (TmpVal1 + (TmpVal2 - 1)) / TmpVal2; 
....................  
....................    // zero data 
....................    for(i = 0; i < sizeof(data); i += 1) 
....................       data[i] = 0; 
....................  
....................    // start filling up data 
....................    data[0] = 0xEB; 
....................    data[1] = BS_jmpBoot; 
....................    data[2] = 0x90;    
....................    sprintf(data + 3, "%s", BS_OEMName); 
....................    data[11] = make8(BPB_BytsPerSec, 0); 
....................    data[12] = make8(BPB_BytsPerSec, 1); 
....................    data[13] = BPB_SecPerClus; 
....................    data[14] = BPB_RsvdSecCnt; 
....................    data[16] = BPB_NumFATs; 
....................    data[21] = BPB_Media; 
....................    data[24] = BPB_SecPerTrk;  
....................    data[26] = BPB_NumHeads; 
.................... #ifdef FAT32 
....................    data[32] = make8(BPB_TotSec, 0); 
....................    data[33] = make8(BPB_TotSec, 1); 
....................    data[34] = make8(BPB_TotSec, 2); 
....................    data[35] = make8(BPB_TotSec, 3); 
....................    data[36] = make8(BPB_FATSz, 0); 
....................    data[37] = make8(BPB_FATSz, 1); 
....................    data[38] = make8(BPB_FATSz, 2); 
....................    data[39] = make8(BPB_FATSz, 3); 
....................    data[44] = BPB_RootClus; 
....................    data[48] = BPB_FSInfo; 
....................    data[50] = BPB_BkBootSec; 
....................    data[66] = BS_BootSig; 
....................    data[67] = make8(BS_VolID, 0); 
....................    data[68] = make8(BS_VolID, 1); 
....................    data[69] = make8(BS_VolID, 2); 
....................    data[70] = make8(BS_VolID, 3); 
....................    sprintf(data + 71, "%s", BS_VolLab); 
....................    sprintf(data + 82, "%s", BS_FilSysType); 
....................  
....................    // put data onto the card 
....................    // first, all the partition parameters 
....................    if(mmcsd_write_data(0, sizeof(data), data) != GOODEC) 
....................       return EOF; 
....................  
....................    // figure out where the first FAT starts 
....................    TmpVal1 = BPB_BytsPerSec * BPB_RsvdSecCnt; 
....................  
....................    // figure out where the root directory starts 
....................    TmpVal2 = TmpVal1 + (BPB_NumFATs * BPB_FATSz); 
....................  
....................    // clear out some values in data 
....................    for(i = 0; i < 0x20; i += 1) 
....................       data[i] = 0; 
....................  
....................    // get rid of everything in the root directory 
....................    clear_cluster(2); 
....................     
....................    // clear out the FAT 
....................    for(i = 0; i < BPB_FATSz; i += 0x20) 
....................       if(mmcsd_write_data(TmpVal1 + i, 0x20, data) != GOODEC) 
....................          return EOF; 
....................  
....................    // insert the first 12 entries into the FAT(s) 
....................    data[0] = 0xF8; 
....................    data[1] = 0xFF; 
....................    data[2] = 0xFF; 
....................    data[3] = 0x0F; 
....................    data[4] = 0xFF; 
....................    data[5] = 0xFF; 
....................    data[6] = 0xFF; 
....................    data[7] = 0x0F; 
....................    data[8] = 0xFF; 
....................    data[9] = 0xFF; 
....................    data[10] = 0xFF; 
....................    data[11] = 0x0F; 
....................    if(mmcsd_write_data(TmpVal1, 0x20, data) != GOODEC) 
....................       return EOF; 
....................        
....................    // reset the last cluster 
....................    i = 2; 
....................    if(mmcsd_write_data(0x3EC, 4, &i) != GOODEC) 
....................       return EOF; 
.................... #else 
....................    data[17] = make8(BPB_RootEntCnt, 0); 
....................    data[18] = make8(BPB_RootEntCnt, 1); 
....................    data[19] = make8(BPB_TotSec, 0); 
....................    data[20] = make8(BPB_TotSec, 1); 
....................    data[22] = make8(BPB_FATSz, 0); 
....................    data[23] = make8(BPB_FATSz, 1); 
....................    data[38] = BS_BootSig; 
....................    data[39] = make8(BS_VolID, 0); 
....................    data[40] = make8(BS_VolID, 1); 
....................    data[41] = make8(BS_VolID, 2); 
....................    data[42] = make8(BS_VolID, 3); 
....................    sprintf(data + 43, "%s", BS_VolLab); 
....................    sprintf(data + 54, "%s", BS_FilSysType); 
....................  
....................    // put data onto the card 
....................    // first, all the partition parameters 
....................    if(mmcsd_write_data(0, sizeof(data), data) != GOODEC) 
....................       return EOF; 
....................  
....................    // figure out where the first FAT starts 
....................    TmpVal1 = BPB_BytsPerSec * BPB_RsvdSecCnt; 
....................  
....................    // figure out where the root directory starts 
....................    TmpVal2 = TmpVal1 + (BPB_NumFATs * BPB_FATSz); 
....................  
....................    // clear out some values in data 
....................    for(i = 0; i < 0x20; i += 1) 
....................       data[i] = 0; 
....................  
....................    // get rid of everything in the root directory 
....................    for(i = 0; i < (0x20 * BPB_RootEntCnt); i += 0x20) 
....................       if(mmcsd_write_data(TmpVal2 + i, 0x20, data) != GOODEC) 
....................          return EOF; 
....................     
....................    // clear out the FAT 
....................    for(i = 0; i < BPB_FATSz; i += 0x20) 
....................       if(mmcsd_write_data(TmpVal1 + i, 0x20, data) != GOODEC) 
....................          return EOF; 
....................  
....................    // insert the first 3 entries into the FAT(s) 
....................    data[0] = 0xF8; 
....................    data[1] = 0xFF; 
....................    data[2] = 0xFF; 
....................    if(mmcsd_write_data(TmpVal1, 0x20, data) != GOODEC) 
....................       return EOF; 
....................        
.................... #endif // #ifdef FAT32 
....................  
....................    i = 0xAA55; 
....................  
....................    if(mmcsd_write_data(0x1FE, 2, &i) != GOODEC) 
....................       return EOF;    
....................  
....................    // we're going to have to re-initialize the FAT, a bunch of parameters probably just changed 
....................    fat_init(); 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /// Debugging Utility Functions /// 
....................  
.................... /* 
.................... signed int disp_folder_contents(char foldername[]) 
.................... Summary: Displays the contents of a folder. 
.................... Param: The folder to display the contents of. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int disp_folder_contents(char foldername[]) 
.................... { 
....................    char filename[MAX_FILE_NAME_LENGTH]; // a place to hold a file name 
....................     
....................    FILE stream; // the stream that we're going to be working with 
....................     
....................    char mode[] = "r"; 
....................     
....................    if(fatopen(foldername, mode, &stream) != GOODEC) 
....................       return EOF; 
....................  
....................    // printf off a header 
....................    printf("\r\n--%s--", foldername); 
....................  
....................    // start off at the root directory 
....................    stream.Entry_Addr = stream.Start_Addr; 
....................  
....................    while(get_next_file(&stream) != EOF) 
....................    { 
....................       // get the name of the file that we are at 
....................       if(get_file_name(stream.Entry_Addr, filename) != GOODEC) 
....................          return EOF; 
....................       
....................       // make cool little "tree" branches 
....................       printf("\r\n%s", filename); 
....................       if (stream.File_Type == Directory) 
....................          putc('/'); 
....................    } 
....................  
....................    fatclose(&stream); 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int dump_addr(int32 from, int32 to) 
.................... Summary: Display a series of addresses in a hex editor type fashion. 
.................... Param from: The beginning address to display. 
.................... Param to: The end address to display. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int dump_addr(int32 from, int32 to) 
.................... { 
....................    int 
....................       j,          // counter for loops 
....................       val[0x10];  // buffer to hold values 
....................  
....................    int32 i;       // pointer to memory 
....................  
....................    // print off header 
....................    printf("\r\n\r\n         "); 
....................    for(i = 0; i < 0x10; i += 1) 
....................       printf("%2X ", i); 
....................  
....................    // note that the to and from values are being rounded up and down 
....................    //  this makes a nice "block" map in case someone inputs a number that 
....................    //  isn't evenly divisible by 0x10 
....................    for(i = (from - (from % 0x10)); i <= (to + (to % 0x10)); i += 0x10) 
....................    { 
....................       // printf memory block 
....................       printf("\r\n%lX ", i); 
....................  
....................       // fill up buffer 
....................       if(mmcsd_read_data(i, 0x10, val) != GOODEC)   
....................          return EOF; 
....................  
....................       // printf RAM in hex 
....................       for(j = 0; j < 0X10; j += 1) 
....................          printf("%X ", val[j]); 
....................  
....................       // printf spacer 
....................       printf("; "); 
....................  
....................       // printf RAM in char 
....................       for(j = 0; j < 0X10; j += 1) 
....................       { 
....................          // check for characters that will mess up the nice-looking map 
....................          if(val[j] < ' ') 
....................             val[j] = '.'; 
....................  
....................          printf("%c", val[j]); 
....................       } 
....................    } 
....................    return GOODEC; 
.................... } 
....................  
.................... /* 
.................... signed int dump_clusters(int32 from, int32 to) 
.................... Summary: Display a series of clusters in a memory map. 
.................... Param from: The beginning clusters to display. 
.................... Param to: The end clusters to display. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int dump_clusters(int32 from, int32 to) 
.................... { 
....................    // convert the clusters to addresses and dump 
....................    if(dump_addr(cluster_to_addr(from), cluster_to_addr(to)) != GOODEC) 
....................       return EOF; 
.................... } 
....................  
.................... /* 
.................... void disp_fat_stats() 
.................... Summary: Display essential statistics about the FAT to the console. 
.................... Returns: Nothing. 
.................... */ 
.................... void disp_fat_stats() 
.................... { 
....................    printf("\r\n\r\n--FAT Stats--\r\n"); 
....................    printf("First FAT starts at: 0x%lX\r\n", FAT_Start); 
....................    printf("Data Starts At: 0x%lX\r\n", Data_Start); 
....................    printf("Root Directory Is At: 0x%lX\r\n", Root_Dir); 
....................    printf("Bytes Per Cluster: 0x%lX\r\n", Bytes_Per_Cluster); 
.................... } 
....................  
.................... /* 
.................... signed int fatprintfinfo(FILE* stream) 
.................... Summary: Display essential statistics about the file that a stream is pointing to. 
.................... Param: The stream to print off information about. 
.................... Returns: EOF if there was a problem with the media, GOODEC if everything went okay. 
.................... */ 
.................... signed int fatprintfinfo(FILE* stream) 
.................... { 
....................    int ec = 0; 
....................  
....................    int32 val = 0; // buffer to hold values 
....................  
....................    char name[MAX_FILE_NAME_LENGTH]; 
....................  
....................    // get name 
....................    if(get_file_name(stream->Entry_Addr, name) != GOODEC) 
....................       return EOF; 
....................  
....................    // printf header 
....................    printf("\r\n\r\n--"); 
....................    printf(name); 
....................    printf(" Info--"); 
....................  
....................    // printf attributes 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x0B, 1, &val); 
....................    printf("\r\nAttributes: 0x%X", val); 
....................  
....................    // printf creation date 
....................    printf("\r\nCreated: "); 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x10, 2, &val); 
....................    disp_datestamp(val); 
....................    printf(" "); 
....................  
....................    // printf creation time 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x0E, 2, &val); 
....................    disp_timestamp(val); 
....................  
....................    // printf modification date 
....................    printf("\r\nModified: "); 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x18, 2, &val); 
....................    disp_datestamp(val); 
....................    printf(" "); 
....................  
....................    // printf modification time 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x16, 2, &val); 
....................    disp_timestamp(val); 
....................  
....................    // printf starting cluster 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x14, 2, (int16*)&val + 1); 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x1A, 2, &val); 
....................  
....................    printf("\r\nStarting cluster: %lX", val); 
....................  
....................    // printf starting address 
....................    printf("\r\nStarting address: %lX", cluster_to_addr(val)); 
....................  
....................    // printf size 
....................    ec += mmcsd_read_data(stream->Entry_Addr + 0x1C, 4, &val); 
....................    printf("\r\nSize: %lu Bytes\r\n", val); 
....................  
....................    if(ec != GOODEC) 
....................       return EOF; 
....................  
....................    return GOODEC; 
.................... } 
....................  
.................... #endif // #ifndef FAT_PIC_C 
....................  
....................  
.................... void MakeFile(char *fileName) 
.................... { 
....................    printf(usb_cdc_putc,"\r\nMaking file '%s': ", fileName); 
*
05F54:  MOVLW  9E
05F56:  MOVWF  FF6
05F58:  MOVLW  22
05F5A:  MOVWF  FF7
05F5C:  MOVLW  00
05F5E:  MOVWF  FF8
05F60:  MOVLW  0F
05F62:  MOVLB  4
05F64:  MOVWF  xAC
05F66:  MOVLB  0
05F68:  CALL   2F46
05F6C:  MOVFF  4AB,FEA
05F70:  MOVFF  4AA,FE9
05F74:  GOTO   2F76
05F78:  MOVLW  AF
05F7A:  MOVWF  FF6
05F7C:  MOVLW  22
05F7E:  MOVWF  FF7
05F80:  MOVLW  00
05F82:  MOVWF  FF8
05F84:  MOVLW  03
05F86:  MOVLB  4
05F88:  MOVWF  xAC
05F8A:  MOVLB  0
05F8C:  CALL   2F46
....................    if(mk_file(fileName) != GOODEC) 
05F90:  MOVFF  4AB,4AD
05F94:  MOVFF  4AA,4AC
05F98:  BRA    5DB6
05F9A:  MOVF   01,F
05F9C:  BZ    5FB0
....................    { 
....................       printf(usb_cdc_putc,"Error creating file"); 
05F9E:  MOVLW  B4
05FA0:  MOVWF  FF6
05FA2:  MOVLW  22
05FA4:  MOVWF  FF7
05FA6:  MOVLW  00
05FA8:  MOVWF  FF8
05FAA:  CALL   2F1E
....................       return; 
05FAE:  BRA    5FC0
....................    } 
....................    printf("OK"); 
05FB0:  MOVLW  4F
05FB2:  BTFSS  F9E.4
05FB4:  BRA    5FB2
05FB6:  MOVWF  FAE
05FB8:  MOVLW  4B
05FBA:  BTFSS  F9E.4
05FBC:  BRA    5FBA
05FBE:  MOVWF  FAE
05FC0:  GOTO   60D2 (RETURN)
.................... } 
....................  
.................... /******************************************************************************/ 
.................... /******************************************************************************/ 
.................... /*--------------------- Espacio de codigo principal --------------------------*/ 
.................... /******************************************************************************/  
.................... char buffer[255] = "Log.txt"; 
.................... #zero_ram 
.................... void main(){ 
05FC4:  CLRF   FF8
05FC6:  BCF    FD0.7
05FC8:  BSF    07.7
05FCA:  MOVLB  E
05FCC:  MOVLW  55
05FCE:  MOVWF  FA7
05FD0:  MOVLW  AA
05FD2:  MOVWF  FA7
05FD4:  BCF    xBF.0
05FD6:  MOVLW  14
05FD8:  MOVWF  xF7
05FDA:  MOVLW  06
05FDC:  MOVWF  xD3
05FDE:  MOVLW  55
05FE0:  MOVWF  FA7
05FE2:  MOVLW  AA
05FE4:  MOVWF  FA7
05FE6:  BSF    xBF.0
05FE8:  MOVLW  FE
05FEA:  MOVWF  00
05FEC:  MOVLW  0D
05FEE:  MOVWF  01
05FF0:  MOVLW  02
05FF2:  MOVWF  FE9
05FF4:  MOVLW  00
05FF6:  MOVWF  FEA
05FF8:  CLRF   FEE
05FFA:  DECFSZ 00,F
05FFC:  BRA    5FF8
05FFE:  DECFSZ 01,F
06000:  BRA    5FF8
06002:  MOVLW  98
06004:  MOVWF  00
06006:  MOVLW  02
06008:  MOVWF  01
0600A:  MOVLW  18
0600C:  MOVWF  FE9
0600E:  MOVLW  0D
06010:  MOVWF  FEA
06012:  CLRF   FEE
06014:  DECFSZ 00,F
06016:  BRA    6012
06018:  DECFSZ 01,F
0601A:  BRA    6012
0601C:  BSF    F7E.3
0601E:  MOVLW  E1
06020:  MOVWF  FB0
06022:  MOVLW  04
06024:  MOVWF  F7F
06026:  MOVLW  A6
06028:  MOVWF  FAD
0602A:  MOVLW  90
0602C:  MOVWF  FAC
0602E:  BCF    F8A.6
06030:  MOVLB  3
06032:  CLRF   xAA
06034:  CLRF   xA9
06036:  MOVLW  FF
06038:  MOVLB  F
0603A:  MOVWF  x48
0603C:  BCF    FC2.6
0603E:  BCF    FC2.7
06040:  MOVF   x49,W
06042:  ANDLW  E0
06044:  IORLW  1F
06046:  MOVWF  x49
06048:  MOVLB  1
0604A:  CLRF   x88
0604C:  MOVLB  F
0604E:  CLRF   x25
06050:  CLRF   FD1
06052:  CLRF   FD2
06054:  CLRF   1C
06056:  MOVLW  04
06058:  MOVWF  1D
0605A:  MOVLW  0C
0605C:  MOVWF  1E
0605E:  MOVLB  1
06060:  CLRF   x8B
06062:  CLRF   x8C
06064:  MOVLW  4C
06066:  MOVLB  3
06068:  MOVWF  xAB
0606A:  MOVLW  6F
0606C:  MOVWF  xAC
0606E:  MOVLW  67
06070:  MOVWF  xAD
06072:  MOVLW  2E
06074:  MOVWF  xAE
06076:  MOVLW  74
06078:  MOVWF  xAF
0607A:  MOVLW  78
0607C:  MOVWF  xB0
0607E:  MOVLW  74
06080:  MOVWF  xB1
06082:  CLRF   xB2
.................... mcu_init();                                // Inicializa microcontrolador 
06084:  BSF    F9B.6
06086:  CLRF   17
06088:  BTFSC  FF2.7
0608A:  BSF    17.7
0608C:  BCF    FF2.7
.................... usb_cdc_init();                            // Inicializa servicios USB clase CDC 
0608E:  MOVLB  0
06090:  CALL   137E
06094:  BTFSC  17.7
06096:  BSF    FF2.7
.................... usb_init();    // Inicializa modulo USB 
06098:  GOTO   238A
.................... for(;;){ 
.................... if (usb_enumerated()) {              // Espera que PUERTO COM sea abierto 
0609C:  GOTO   23A2
060A0:  MOVF   01,F
060A2:  BZ    60D2
....................         usb_task();                       // Actualiza FSM USB-CDC 
060A4:  CALL   2360
....................     
....................     
....................    if (fat_init()) 
060A8:  GOTO   2C44
060AC:  MOVF   01,F
060AE:  BZ    60C4
....................    { 
....................       printf(usb_cdc_putc,"Could not init the MMC/SD!!!!"); 
060B0:  MOVLW  C8
060B2:  MOVWF  FF6
060B4:  MOVLW  22
060B6:  MOVWF  FF7
060B8:  MOVLW  00
060BA:  MOVWF  FF8
060BC:  CALL   2F1E
....................       while(TRUE); 
060C0:  BRA    60C0
....................    }else{ 
060C2:  BRA    60D2
....................    MakeFile(buffer); 
060C4:  MOVLW  03
060C6:  MOVLB  4
060C8:  MOVWF  xAB
060CA:  MOVLW  AB
060CC:  MOVWF  xAA
060CE:  MOVLB  0
060D0:  BRA    5F54
....................    //printf(usb_cdc_putc,"\r\n\nDirectory created successful\r\n"); 
....................    } 
....................  
....................      } 
060D2:  BRA    609C
.................... } 
....................               
.................... } 
....................  
060D4:  SLEEP 
.................... void println(int32 x,unsigned int8 system=0){ 
.................... if(!system){ 
....................  printf(usb_cdc_putc," %ld \n\r", x);} 
.................... else{ 
.................... if(x<=255){ 
....................  printf(usb_cdc_putc," %X \n\r", x);}else if(x<=65536){ 
....................   printf(usb_cdc_putc," %4X \n\r", x); 
....................  }else{ 
....................  printf(usb_cdc_putc," %lX \n\r", x); 
....................  } 
.................... } 
.................... } 
....................  
....................  

Configuration Fuses:
   Word  1: F79A   NOWDT PLL3 NOPLLEN NOSTVREN NOXINST NODEBUG NOCPUDIV NOPROTECT
   Word  2: FF3D   HSPLL SOSC_HIGH CLOCKOUT NOFCMEN NOIESO WDT32768
   Word  3: F861   DSWDTOSC_INT RTCOSC_INT NODSBOR NODSWDT DSWDT8192 NOIOL1WAY ADC12 MSSPMSK7
   Word  4: FB80   NOWPFP NOWPCFG WPDIS WPEND LS48MHZ
