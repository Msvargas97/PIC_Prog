CCS PCH C Compiler, Version 4.120, 26417               08-Abr.-16 18:22

               Filename: C:\Users\Michael Vargas\Documents\PIC\CodigoMicrosII\Proyecto.lst

               ROM used: 6152 bytes (5%)
                         Largest free fragment is 65528
               RAM used: 118 (3%) at main() level
                         165 (4%) worst case
               Stack:    9 worst case (6 in main + 3 for interrupts)

*
01000:  GOTO   1F48
*
01008:  MOVWF  04
0100A:  MOVFF  FD8,05
0100E:  MOVFF  FE0,06
01012:  MOVLB  0
01014:  MOVFF  FE9,0C
01018:  MOVFF  FEA,07
0101C:  MOVFF  FE1,08
01020:  MOVFF  FE2,09
01024:  MOVFF  FD9,0A
01028:  MOVFF  FDA,0B
0102C:  MOVFF  FF3,12
01030:  MOVFF  FF4,13
01034:  MOVFF  FFA,14
01038:  MOVFF  FF5,15
0103C:  MOVFF  FF6,16
01040:  MOVFF  FF7,17
01044:  MOVFF  FF8,18
01048:  MOVFF  FFB,19
0104C:  MOVFF  00,0E
01050:  MOVFF  01,0F
01054:  MOVFF  02,10
01058:  MOVFF  03,11
0105C:  BTFSS  FF2.4
0105E:  GOTO   1068
01062:  BTFSC  FF2.1
01064:  GOTO   146C
01068:  MOVFF  0E,00
0106C:  MOVFF  0F,01
01070:  MOVFF  10,02
01074:  MOVFF  11,03
01078:  MOVFF  0C,FE9
0107C:  MOVFF  07,FEA
01080:  BSF    07.7
01082:  MOVFF  08,FE1
01086:  MOVFF  09,FE2
0108A:  MOVFF  0A,FD9
0108E:  MOVFF  0B,FDA
01092:  MOVFF  12,FF3
01096:  MOVFF  13,FF4
0109A:  MOVFF  14,FFA
0109E:  MOVFF  15,FF5
010A2:  MOVFF  16,FF6
010A6:  MOVFF  17,FF7
010AA:  MOVFF  18,FF8
010AE:  MOVFF  19,FFB
010B2:  MOVF   04,W
010B4:  MOVFF  06,FE0
010B8:  MOVFF  05,FD8
010BC:  RETFIE 0
.................... #include "PLANTILLA_18F47J53.h" 
.................... #ifndef _PLANTILLA_18F47J53_H 
.................... #define _PLANTILLA_18F47J53_H 
.................... #include <18F47J53.h> 
.................... //////// Standard Header file for the PIC18F47J53 device //////////////// 
.................... #device PIC18F47J53 
.................... #list 
....................  
....................  
....................  
.................... // Plantilla modificada por Michael Vargas 
.................... // Derechos de autor a Octoplus y PIC CCS 
.................... #device ADC=12 
....................  
.................... #FUSES NOWDT         //WDT disabled (enabled by SWDTEN bit) 
.................... #FUSES PLL3          //Divide by 3 (12 MHz oscillator input)             
.................... #FUSES NOPLLEN       //PLL Disabled 
.................... #FUSES NOSTVREN      //stack overflow/underflow reset enabled                 
.................... #FUSES NOXINST       //Extended instruction set disabled             
.................... #FUSES NOCPUDIV      //No CPU system clock divide          
.................... #FUSES NOPROTECT     //Program memory is not code-protected           
.................... #FUSES HSPLL         //HS oscillator, PLL enabled, HSPLL used by USB            
.................... #FUSES SOSC_HIGH     //High Power T1OSC/SOSC circuit selected 
.................... #FUSES CLOCKOUT      //CLKO output enabled on the RA6 pin  
.................... #FUSES NOFCMEN       //Fail-Safe Clock Monitor disabled 
.................... #FUSES NOIESO        //Two-Speed Start-up disabled 
.................... #FUSES WDT32768      //Watchdog Postscaler 1:32768 
.................... #FUSES DSWDTOSC_INT  //DSWDT uses INTOSC/INTRC as clock 
.................... #FUSES RTCOSC_INT    //RTCC uses INTRC as clock 
.................... #FUSES NODSBOR       //Zero-Power BOR disabled in Deep Sleep 
.................... #FUSES NODSWDT       //Deep Sleep Watchdog Timer Disabled 
.................... #FUSES DSWDT8192     //Deep Sleep Watchdog Postscaler: 1:8,192 (8.5 seconds)    
.................... #FUSES NOIOL1WAY     //IOLOCK bit can be set and cleared 
.................... #FUSES ADC12         //ADC 10 or 12 Bit Select:12 - Bit ADC Enabed  
.................... #FUSES MSSPMSK7      //MSSP 7 Bit address masking 
.................... #FUSES NOWPFP        //Write Protect Program Flash Page 0 
.................... #FUSES NOWPCFG       //Write/Erase last page protect Disabled 
.................... #FUSES WPDIS         //WPFP[5:0], WPEND, and WPCFG bits ignored  
.................... #FUSES WPEND         //Start protection at page 0 
.................... #FUSES LS48MHZ       //Low Speed USB mode with 48 MHz System clock at 48 MHz USB CLKEN divide-by is set to 8  
.................... #use delay(clock=48000000) 
*
016D4:  CLRF   FEA
016D6:  MOVLW  83
016D8:  MOVWF  FE9
016DA:  MOVF   FEF,W
016DC:  BZ    16FA
016DE:  MOVLW  0F
016E0:  MOVWF  01
016E2:  CLRF   00
016E4:  DECFSZ 00,F
016E6:  BRA    16E4
016E8:  DECFSZ 01,F
016EA:  BRA    16E2
016EC:  MOVLW  8F
016EE:  MOVWF  00
016F0:  DECFSZ 00,F
016F2:  BRA    16F0
016F4:  NOP   
016F6:  DECFSZ FEF,F
016F8:  BRA    16DE
016FA:  RETURN 0
*
01BF6:  MOVLW  01
01BF8:  SUBWF  x74,F
01BFA:  BNC   1C14
01BFC:  CLRF   FEA
01BFE:  MOVLW  74
01C00:  MOVWF  FE9
01C02:  MOVF   FEF,W
01C04:  BZ    1C14
01C06:  MOVLW  02
01C08:  MOVWF  00
01C0A:  DECFSZ 00,F
01C0C:  BRA    1C0A
01C0E:  BRA    1C10
01C10:  DECFSZ FEF,F
01C12:  BRA    1C06
01C14:  RETURN 0
....................  
.................... #pin_select U2TX=PIN_D2 //Selecciona hardware UART2 
.................... #pin_select U2RX=PIN_D3 //Selecciona hardware UART2 
....................  
....................  
.................... #define LOADER_END   0xFFF                         
.................... #build(reset=LOADER_END+1, interrupt=LOADER_END+9)   //Protege posiciones de memoria desde la 0x0000 hasta la 0x1000    
.................... #org 0, LOADER_END {} 
....................  
.................... #bit PLLEN = 0xf9b.6 
.................... #bit PULL_UP = 0xff1.7 //Bit para activar la resistencia pull-up del puerto b 
....................  
.................... #define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt))) 
....................  
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0190E:  CLRF   x7A
....................    sign = 0; 
01910:  CLRF   x78
....................    base = 10; 
01912:  MOVLW  0A
01914:  MOVWF  x79
....................    result = 0; 
01916:  CLRF   x77
01918:  CLRF   x76
....................  
....................    if (!s) 
0191A:  MOVF   x74,W
0191C:  IORWF  x75,W
0191E:  BNZ   1928
....................       return 0; 
01920:  MOVLW  00
01922:  MOVWF  01
01924:  MOVWF  02
01926:  BRA    1AF4
....................    c = s[index++]; 
01928:  MOVF   x7A,W
0192A:  INCF   x7A,F
0192C:  CLRF   03
0192E:  ADDWF  x74,W
01930:  MOVWF  FE9
01932:  MOVF   x75,W
01934:  ADDWFC 03,W
01936:  MOVWF  FEA
01938:  MOVFF  FEF,7B
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0193C:  MOVF   x7B,W
0193E:  SUBLW  2D
01940:  BNZ   195C
....................    { 
....................       sign = 1;         // Set the sign to negative 
01942:  MOVLW  01
01944:  MOVWF  x78
....................       c = s[index++]; 
01946:  MOVF   x7A,W
01948:  INCF   x7A,F
0194A:  CLRF   03
0194C:  ADDWF  x74,W
0194E:  MOVWF  FE9
01950:  MOVF   x75,W
01952:  ADDWFC 03,W
01954:  MOVWF  FEA
01956:  MOVFF  FEF,7B
....................    } 
....................    else if (c == '+') 
0195A:  BRA    1976
0195C:  MOVF   x7B,W
0195E:  SUBLW  2B
01960:  BNZ   1976
....................    { 
....................       c = s[index++]; 
01962:  MOVF   x7A,W
01964:  INCF   x7A,F
01966:  CLRF   03
01968:  ADDWF  x74,W
0196A:  MOVWF  FE9
0196C:  MOVF   x75,W
0196E:  ADDWFC 03,W
01970:  MOVWF  FEA
01972:  MOVFF  FEF,7B
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
01976:  MOVF   x7B,W
01978:  SUBLW  2F
0197A:  BTFSC  FD8.0
0197C:  BRA    1AD8
0197E:  MOVF   x7B,W
01980:  SUBLW  39
01982:  BTFSS  FD8.0
01984:  BRA    1AD8
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
01986:  MOVF   x7B,W
01988:  SUBLW  30
0198A:  BNZ   19CE
0198C:  CLRF   03
0198E:  MOVF   x7A,W
01990:  ADDWF  x74,W
01992:  MOVWF  FE9
01994:  MOVF   x75,W
01996:  ADDWFC 03,W
01998:  MOVWF  FEA
0199A:  MOVF   FEF,W
0199C:  SUBLW  78
0199E:  BZ    19B4
019A0:  CLRF   03
019A2:  MOVF   x7A,W
019A4:  ADDWF  x74,W
019A6:  MOVWF  FE9
019A8:  MOVF   x75,W
019AA:  ADDWFC 03,W
019AC:  MOVWF  FEA
019AE:  MOVF   FEF,W
019B0:  SUBLW  58
019B2:  BNZ   19CE
....................       { 
....................          base = 16; 
019B4:  MOVLW  10
019B6:  MOVWF  x79
....................          index++; 
019B8:  INCF   x7A,F
....................          c = s[index++]; 
019BA:  MOVF   x7A,W
019BC:  INCF   x7A,F
019BE:  CLRF   03
019C0:  ADDWF  x74,W
019C2:  MOVWF  FE9
019C4:  MOVF   x75,W
019C6:  ADDWFC 03,W
019C8:  MOVWF  FEA
019CA:  MOVFF  FEF,7B
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
019CE:  MOVF   x79,W
019D0:  SUBLW  0A
019D2:  BNZ   1A16
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
019D4:  MOVF   x7B,W
019D6:  SUBLW  2F
019D8:  BC    1A14
019DA:  MOVF   x7B,W
019DC:  SUBLW  39
019DE:  BNC   1A14
....................             result = 10*result + (c - '0'); 
019E0:  CLRF   x7D
019E2:  MOVLW  0A
019E4:  MOVWF  x7C
019E6:  MOVFF  77,7F
019EA:  MOVFF  76,7E
019EE:  BRA    18BC
019F0:  MOVLW  30
019F2:  SUBWF  x7B,W
019F4:  ADDWF  01,W
019F6:  MOVWF  x76
019F8:  MOVLW  00
019FA:  ADDWFC 02,W
019FC:  MOVWF  x77
....................             c = s[index++]; 
019FE:  MOVF   x7A,W
01A00:  INCF   x7A,F
01A02:  CLRF   03
01A04:  ADDWF  x74,W
01A06:  MOVWF  FE9
01A08:  MOVF   x75,W
01A0A:  ADDWFC 03,W
01A0C:  MOVWF  FEA
01A0E:  MOVFF  FEF,7B
....................          } 
01A12:  BRA    19D4
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
01A14:  BRA    1AD8
01A16:  MOVF   x79,W
01A18:  SUBLW  10
01A1A:  BNZ   1AD8
....................       { 
....................          c = toupper(c); 
01A1C:  MOVF   x7B,W
01A1E:  SUBLW  60
01A20:  BC    1A2E
01A22:  MOVF   x7B,W
01A24:  SUBLW  7A
01A26:  BNC   1A2E
01A28:  MOVF   x7B,W
01A2A:  ANDLW  DF
01A2C:  BRA    1A30
01A2E:  MOVF   x7B,W
01A30:  MOVWF  x7B
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
01A32:  MOVF   x7B,W
01A34:  SUBLW  2F
01A36:  BC    1A3E
01A38:  MOVF   x7B,W
01A3A:  SUBLW  39
01A3C:  BC    1A4A
01A3E:  MOVF   x7B,W
01A40:  SUBLW  40
01A42:  BC    1AD8
01A44:  MOVF   x7B,W
01A46:  SUBLW  46
01A48:  BNC   1AD8
....................             if (c >= '0' && c <= '9') 
01A4A:  MOVF   x7B,W
01A4C:  SUBLW  2F
01A4E:  BC    1A82
01A50:  MOVF   x7B,W
01A52:  SUBLW  39
01A54:  BNC   1A82
....................                result = (result << 4) + (c - '0'); 
01A56:  RLCF   x76,W
01A58:  MOVWF  x7C
01A5A:  RLCF   x77,W
01A5C:  MOVWF  x7D
01A5E:  RLCF   x7C,F
01A60:  RLCF   x7D,F
01A62:  RLCF   x7C,F
01A64:  RLCF   x7D,F
01A66:  RLCF   x7C,F
01A68:  RLCF   x7D,F
01A6A:  MOVLW  F0
01A6C:  ANDWF  x7C,F
01A6E:  MOVLW  30
01A70:  SUBWF  x7B,W
01A72:  ADDWF  x7C,W
01A74:  MOVWF  01
01A76:  MOVLW  00
01A78:  ADDWFC x7D,W
01A7A:  MOVFF  01,76
01A7E:  MOVWF  x77
....................             else 
01A80:  BRA    1AAE
....................                result = (result << 4) + (c - 'A' + 10); 
01A82:  RLCF   x76,W
01A84:  MOVWF  x7C
01A86:  RLCF   x77,W
01A88:  MOVWF  x7D
01A8A:  RLCF   x7C,F
01A8C:  RLCF   x7D,F
01A8E:  RLCF   x7C,F
01A90:  RLCF   x7D,F
01A92:  RLCF   x7C,F
01A94:  RLCF   x7D,F
01A96:  MOVLW  F0
01A98:  ANDWF  x7C,F
01A9A:  MOVLW  41
01A9C:  SUBWF  x7B,W
01A9E:  ADDLW  0A
01AA0:  ADDWF  x7C,W
01AA2:  MOVWF  01
01AA4:  MOVLW  00
01AA6:  ADDWFC x7D,W
01AA8:  MOVFF  01,76
01AAC:  MOVWF  x77
....................  
....................             c = s[index++];c = toupper(c); 
01AAE:  MOVF   x7A,W
01AB0:  INCF   x7A,F
01AB2:  CLRF   03
01AB4:  ADDWF  x74,W
01AB6:  MOVWF  FE9
01AB8:  MOVF   x75,W
01ABA:  ADDWFC 03,W
01ABC:  MOVWF  FEA
01ABE:  MOVF   FEF,W
01AC0:  MOVWF  x7B
01AC2:  SUBLW  60
01AC4:  BC    1AD2
01AC6:  MOVF   x7B,W
01AC8:  SUBLW  7A
01ACA:  BNC   1AD2
01ACC:  MOVF   x7B,W
01ACE:  ANDLW  DF
01AD0:  BRA    1AD4
01AD2:  MOVF   x7B,W
01AD4:  MOVWF  x7B
....................          } 
01AD6:  BRA    1A32
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
01AD8:  MOVF   x79,W
01ADA:  SUBLW  0A
01ADC:  BNZ   1AEC
01ADE:  DECFSZ x78,W
01AE0:  BRA    1AEC
....................       result = -result; 
01AE2:  COMF   x76,F
01AE4:  COMF   x77,F
01AE6:  INCF   x76,F
01AE8:  BTFSC  FD8.2
01AEA:  INCF   x77,F
....................  
....................    return(result); 
01AEC:  MOVFF  76,01
01AF0:  MOVFF  77,02
.................... } 
01AF4:  RETURN 0
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define mcu_init()\ 
.................... do{\ 
....................   PLLEN = 1;        /*Habilita PLL para generar 48MHz de oscilador*/\ 
....................   set_tris_a(0); \  
....................   set_tris_b(0); \ 
....................   set_tris_d(0); \ 
....................   set_tris_e(0); \ 
....................   set_tris_c(0); \ 
.................... }while(0) \ 
....................  
....................  
....................  
.................... #endif /*_PLANTILLA18F47J53_H  */ 
....................  
.................... #include "Configura_LCD_4-8_bits.c" 
.................... //Definicion de instruccion de la LCD 
.................... short bits_8_4; 
....................  
.................... #define LCD_LINEA2 0xC0    // Direccin de memoria para la segunda lnea 
.................... #define clear_display            1 
.................... #define home                     0b10 
.................... #define entry_mode_set           0b100 
.................... #define display_on_off_control   0b1100 
.................... #define cursorON                 0b1110 
.................... #define cursorOFF                0b1100 
.................... #define cursor_or_display_shift  0b1100 
.................... #define function_set             0b101000 
.................... //Sebastian 
.................... /*#define RS_LCD        PIN_D0 
.................... #define E_LCD         PIN_D2 
.................... #define LCD_D4        PIN_D4 
.................... #define LCD_D5        PIN_D5 
.................... #define LCD_D6        PIN_D6 
.................... #define LCD_D7        PIN_D7*/ 
....................  
.................... #define RS_LCD        PIN_D0 
.................... #define E_LCD         PIN_D1 
.................... #define LCD_D4        PIN_D2 
.................... #define LCD_D5        PIN_D3 
.................... #define LCD_D6        PIN_D4 
.................... #define LCD_D7        PIN_D5 
.................... #define DATOS        PORTD 
....................  
.................... //-------------- Funcion que envia byte a pantalla lcd -------------------- 
.................... void lcd_envia_byte_4bits(int1 operacion, char dato ) { 
.................... output_low(E_LCD); 
*
016FC:  BCF    F95.1
016FE:  BCF    F8C.1
.................... output_bit(RS_LCD,operacion); 
01700:  MOVF   x81,F
01702:  BNZ   1708
01704:  BCF    F8C.0
01706:  BRA    170A
01708:  BSF    F8C.0
0170A:  BCF    F95.0
....................  
.................... if(bit_test(dato,4)==1)output_high (LCD_D4);else output_low (LCD_D4); 
0170C:  BTFSS  x82.4
0170E:  BRA    1716
01710:  BCF    F95.2
01712:  BSF    F8C.2
01714:  BRA    171A
01716:  BCF    F95.2
01718:  BCF    F8C.2
.................... if(bit_test(dato,5)==1)output_high (LCD_D5);else output_low (LCD_D5); 
0171A:  BTFSS  x82.5
0171C:  BRA    1724
0171E:  BCF    F95.3
01720:  BSF    F8C.3
01722:  BRA    1728
01724:  BCF    F95.3
01726:  BCF    F8C.3
.................... if(bit_test(dato,6)==1)output_high (LCD_D6);else output_low (LCD_D6); 
01728:  BTFSS  x82.6
0172A:  BRA    1732
0172C:  BCF    F95.4
0172E:  BSF    F8C.4
01730:  BRA    1736
01732:  BCF    F95.4
01734:  BCF    F8C.4
.................... if(bit_test(dato,7)==1)output_high (LCD_D7);else output_low (LCD_D7); 
01736:  BTFSS  x82.7
01738:  BRA    1740
0173A:  BCF    F95.5
0173C:  BSF    F8C.5
0173E:  BRA    1744
01740:  BCF    F95.5
01742:  BCF    F8C.5
.................... delay_us(10); 
01744:  MOVLW  27
01746:  MOVWF  00
01748:  DECFSZ 00,F
0174A:  BRA    1748
0174C:  BRA    174E
....................  
.................... output_high(E_LCD); 
0174E:  BCF    F95.1
01750:  BSF    F8C.1
.................... delay_ms(1); 
01752:  MOVLW  01
01754:  MOVWF  x83
01756:  RCALL  16D4
.................... output_low(E_LCD); 
01758:  BCF    F95.1
0175A:  BCF    F8C.1
.................... delay_ms(1); 
0175C:  MOVLW  01
0175E:  MOVWF  x83
01760:  RCALL  16D4
....................  
.................... if(bit_test(dato,0)==1)output_high (LCD_D4);else output_low (LCD_D4); 
01762:  BTFSS  x82.0
01764:  BRA    176C
01766:  BCF    F95.2
01768:  BSF    F8C.2
0176A:  BRA    1770
0176C:  BCF    F95.2
0176E:  BCF    F8C.2
.................... if(bit_test(dato,1)==1)output_high (LCD_D5);else output_low (LCD_D5); 
01770:  BTFSS  x82.1
01772:  BRA    177A
01774:  BCF    F95.3
01776:  BSF    F8C.3
01778:  BRA    177E
0177A:  BCF    F95.3
0177C:  BCF    F8C.3
.................... if(bit_test(dato,2)==1)output_high (LCD_D6);else output_low (LCD_D6); 
0177E:  BTFSS  x82.2
01780:  BRA    1788
01782:  BCF    F95.4
01784:  BSF    F8C.4
01786:  BRA    178C
01788:  BCF    F95.4
0178A:  BCF    F8C.4
.................... if(bit_test(dato,3)==1)output_high (LCD_D7);else output_low (LCD_D7); 
0178C:  BTFSS  x82.3
0178E:  BRA    1796
01790:  BCF    F95.5
01792:  BSF    F8C.5
01794:  BRA    179A
01796:  BCF    F95.5
01798:  BCF    F8C.5
.................... delay_us(10); 
0179A:  MOVLW  27
0179C:  MOVWF  00
0179E:  DECFSZ 00,F
017A0:  BRA    179E
017A2:  BRA    17A4
....................  
.................... output_high(E_LCD); 
017A4:  BCF    F95.1
017A6:  BSF    F8C.1
.................... delay_ms(1); 
017A8:  MOVLW  01
017AA:  MOVWF  x83
017AC:  RCALL  16D4
.................... output_low(E_LCD); 
017AE:  BCF    F95.1
017B0:  BCF    F8C.1
.................... delay_ms(1); 
017B2:  MOVLW  01
017B4:  MOVWF  x83
017B6:  RCALL  16D4
.................... } 
017B8:  RETURN 0
.................... //--------- Funcion que establece la posicion del cursor en la lcd ------------ 
.................... void lcd_ubicaxy_4bits(char columna,char fila) { 
.................... char posicion; 
....................      switch (fila) { 
017BA:  MOVLW  01
017BC:  SUBWF  x7F,W
017BE:  ADDLW  FC
017C0:  BC    17E8
017C2:  ADDLW  04
017C4:  GOTO   17F2
....................      case 1   : posicion=(0x7F+columna); 
017C8:  MOVLW  7F
017CA:  ADDWF  x7E,W
017CC:  MOVWF  x80
....................      break; 
017CE:  BRA    17E8
....................      case 2   : posicion=(0xBF+columna); 
017D0:  MOVLW  BF
017D2:  ADDWF  x7E,W
017D4:  MOVWF  x80
....................      break; 
017D6:  BRA    17E8
....................      case 3   : posicion=(0x8F+columna); 
017D8:  MOVLW  8F
017DA:  ADDWF  x7E,W
017DC:  MOVWF  x80
....................      break; 
017DE:  BRA    17E8
....................      case 4   : posicion=(0xCF+columna); 
017E0:  MOVLW  CF
017E2:  ADDWF  x7E,W
017E4:  MOVWF  x80
....................      break; 
017E6:  BRA    17E8
....................    } 
....................    lcd_envia_byte_4bits( 0,posicion); 
017E8:  CLRF   x81
017EA:  MOVFF  80,82
017EE:  RCALL  16FC
.................... } 
017F0:  RETURN 0
.................... //----------- Funcion que envia secuencia de inicializaciona lcd -------------- 
.................... void lcd_init_4bits() { 
....................     delay_ms(50); 
*
0181A:  MOVLW  32
0181C:  MOVWF  x83
0181E:  RCALL  16D4
....................     lcd_envia_byte_4bits(0,0B00110011); 
01820:  CLRF   x81
01822:  MOVLW  33
01824:  MOVWF  x82
01826:  RCALL  16FC
....................     lcd_envia_byte_4bits(0,0B00110010); 
01828:  CLRF   x81
0182A:  MOVLW  32
0182C:  MOVWF  x82
0182E:  RCALL  16FC
....................     lcd_envia_byte_4bits(0,function_set); 
01830:  CLRF   x81
01832:  MOVLW  28
01834:  MOVWF  x82
01836:  RCALL  16FC
....................     lcd_envia_byte_4bits(0,display_on_off_control); 
01838:  CLRF   x81
0183A:  MOVLW  0C
0183C:  MOVWF  x82
0183E:  RCALL  16FC
....................     lcd_envia_byte_4bits(0,clear_display); 
01840:  CLRF   x81
01842:  MOVLW  01
01844:  MOVWF  x82
01846:  RCALL  16FC
....................     lcd_ubicaxy_4bits(1,1); 
01848:  MOVLW  01
0184A:  MOVWF  x7E
0184C:  MOVWF  x7F
0184E:  RCALL  17BA
.................... } 
01850:  GOTO   1FE4 (RETURN)
.................... void lcdCursorOn(){ 
.................... lcd_envia_byte_4bits(0,cursorON); 
*
01BEA:  CLRF   x81
01BEC:  MOVLW  0E
01BEE:  MOVWF  x82
01BF0:  RCALL  16FC
.................... } 
01BF2:  GOTO   232C (RETURN)
.................... void lcdCursorOff(){ 
.................... lcd_envia_byte_4bits(0,cursorOFF); 
*
018B2:  CLRF   x81
018B4:  MOVLW  0C
018B6:  MOVWF  x82
018B8:  RCALL  16FC
.................... } 
018BA:  RETURN 0
.................... //---------------------- Escribe en la lcd la letra dada ---------------------- 
.................... void lcd_putc_4bits( char letra) { 
....................      switch (letra) { 
*
01854:  MOVF   x7D,W
01856:  XORLW  0C
01858:  BZ    1860
0185A:  XORLW  06
0185C:  BZ    1872
0185E:  BRA    187C
....................      case '\f'   : lcd_envia_byte_4bits(0,1);       //Borra la pantalla LCD 
01860:  CLRF   x81
01862:  MOVLW  01
01864:  MOVWF  x82
01866:  RCALL  16FC
....................                    lcd_ubicaxy_4bits(1,1);         //Ubica cursor en fila 1 
01868:  MOVLW  01
0186A:  MOVWF  x7E
0186C:  MOVWF  x7F
0186E:  RCALL  17BA
....................      break; 
01870:  BRA    1888
....................  
....................      case '\n'   : lcd_ubicaxy_4bits(0,2);          //Busca la fila 2 
01872:  CLRF   x7E
01874:  MOVLW  02
01876:  MOVWF  x7F
01878:  RCALL  17BA
....................      break; 
0187A:  BRA    1888
....................  
....................      default     : lcd_envia_byte_4bits(1,letra); 
0187C:  MOVLW  01
0187E:  MOVWF  x81
01880:  MOVFF  7D,82
01884:  RCALL  16FC
....................      break; 
01886:  BRA    1888
....................    } 
....................  
.................... } 
01888:  RETURN 0
.................... //************************************************************************************** 
.................... //************************************************************************************** 
.................... //************************************************************************************** 
.................... //************************************************************************************** 
.................... //************************************************************************************** 
.................... // Comandos para el funcionamiento a 8 bits 
.................... #define LCD_DATO    1 
.................... #define LCD_COMANDO 0 
....................  
.................... // instruccion de inicializacion 
.................... #define LCD_CLEAR          0x01 
.................... #define LCD_HOME          0x02 
....................  
.................... // Opciones para el display 
.................... #define LCD_DISPLAY_OFF  0x08 
.................... #define LCD_DISPLAY_ON   0x0C 
.................... #define LCD_CURSOR_ON    0x0E 
.................... #define LCD_CURSOR_BLINK 0x0F 
....................  
.................... // opciones epeciales del cursor 
.................... #define LCD_CURSOR_SHIFT_RIGHT  0x10 
.................... #define LCD_CURSOR_SHIFT_LEFT   0x14 
.................... #define LCD_DISPLAY_SHIFT_RIGHT 0x18 
.................... #define LCD_DISPLAY_SHIFT_LEFT  0x1C 
....................  
.................... // Configurar el hardware 
.................... #define LCD_DISPLAY_8_BITS   0x38  //0b00111000 
.................... #define LCD_DISPLAY_4_BITS   0x28  //0b00111000 
....................  
....................  
....................  
.................... void lcd_envia_8bits(int dir, int valor) 
.................... { 
....................     
....................      
....................     output_bit(RS_LCD,dir); 
....................     output_high(E_LCD); 
....................     output_d(valor);  // !!!!!Cambiar al puerto donde esten conectados los datos!!!!!! 
....................     delay_us(350); 
....................     output_low(E_LCD); 
....................     delay_us(350); 
....................     
....................       
.................... } 
....................  
....................  
.................... void lcd_init_8bits() 
.................... { 
....................   int dir,valor; 
....................   dir=LCD_COMANDO; 
....................   
....................   valor=LCD_DISPLAY_8_BITS;   //0x38 Inicia el modulo a 8 bits 
....................   bits_8_4=1; 
....................   
....................   lcd_envia_8bits(dir,valor); 
....................   delay_ms(1);    
....................   lcd_envia_8bits(dir,valor); 
....................  
....................   valor=LCD_DISPLAY_ON;    //0x0c activa display 
....................   lcd_envia_8bits(dir,valor); 
....................   valor=LCD_CLEAR;         //0x01 borra display 
....................   lcd_envia_8bits(dir,valor);  
....................   valor=0x06;               //selecciona mensaje fijo 
....................   lcd_envia_8bits(dir,valor); 
....................  
.................... } 
....................  
....................  
.................... void lcd_ubicaxy_8bits( char x, char y) { 
....................    char dir; 
....................  
....................    if(y!=1) 
....................      dir=LCD_LINEA2; 
....................    else 
....................      dir=0; 
....................    dir+=x-1; 
....................    lcd_envia_8bits(LCD_COMANDO,0x80|dir); 
.................... } 
....................  
....................  
.................... void lcd_putc_8bits( char c) 
.................... { 
....................    switch (c) 
....................    { 
....................      case '\f': 
....................          lcd_envia_8bits(LCD_COMANDO,0x01); 
....................          delay_ms(2); 
....................      break; 
....................      case '\n': 
....................          lcd_ubicaxy_8bits(1,2); 
....................      break; 
....................      case '\b': 
....................         lcd_envia_8bits(LCD_COMANDO,0x10); 
....................      break; 
....................      default : 
....................         lcd_envia_8bits(LCD_DATO,c); 
....................      break; 
....................    } 
.................... } 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #use rs232(baud=19200, xmit=PIN_B2, rcv=PIN_B1) 
*
011F6:  BCF    F93.2
011F8:  BCF    F8A.2
011FA:  MOVLW  08
011FC:  MOVWF  01
011FE:  BRA    1200
01200:  NOP   
01202:  BSF    01.7
01204:  BRA    1222
01206:  BCF    01.7
01208:  RRCF   xA2,F
0120A:  BTFSC  FD8.0
0120C:  BSF    F8A.2
0120E:  BTFSS  FD8.0
01210:  BCF    F8A.2
01212:  BSF    01.6
01214:  BRA    1222
01216:  BCF    01.6
01218:  DECFSZ 01,F
0121A:  BRA    1208
0121C:  BRA    121E
0121E:  NOP   
01220:  BSF    F8A.2
01222:  MOVLW  CA
01224:  MOVWF  FE9
01226:  DECFSZ FE9,F
01228:  BRA    1226
0122A:  NOP   
0122C:  BTFSC  01.7
0122E:  BRA    1206
01230:  BTFSC  01.6
01232:  BRA    1216
01234:  RETURN 0
....................  
.................... #define MAX_LUMENS   1280 //Valor offset del adc para sensor de Luz 
....................  
.................... //################Espacio para variables globales########## 
.................... volatile char tecla; //Variable para almacenar la tecla presionada 
.................... unsigned char inputTeclado[4]; //Vector para guardar los datos ingresados  
.................... unsigned int16 i,j; 
.................... unsigned int16 sensorValues[3]; 
.................... unsigned int16 lastValueLuz; 
.................... unsigned int16 outMax[3] = {150,1000,100}; 
.................... int16 outLimitMax[3]; 
.................... unsigned int8 duty1,duty2,duty3; 
.................... int1 writeLCD=0; //Variable booleana para habilitar o deshabilitar el cursor 
.................... char menu; 
.................... int1 EnterFlag,Bandera1; 
.................... //*** ADD *** 
.................... //######### Variables para teclado PS2 ######### 
.................... unsigned char edge, bitcount,y=1,x=1,z=1,d=1,c=1; 
.................... unsigned mensaje[17]; 
.................... unsigned mensaje2[18]; 
.................... unsigned char dato_rs232; 
.................... char got_interrupt; 
.................... char interrupt_count; 
.................... char status_b3; 
....................  
.................... #bit INTF_BIT = 0xFF2.1 // INTCON BIT 1 = INTF RB0/INT External Interrupt Flag Bit 
.................... //-------- Tabla de caracteres correspondientes a la pulsacin de la tecla 
.................... //-------- en modalidad normal (sin pulsar SHIFT) 
....................  
.................... unsigned char const unshifted[68][2] = { 
.................... 0x0d,9, 
.................... 0x0e,'', 0x15,'q', 0x16,'1', 0x1a,'z', 0x1b,'s', 0x1c,'a', 0x1d,'w', 
.................... 0x1e,'2', 0x21,'c', 0x22,'x', 0x23,'d', 0x24,'e', 0x25,'4', 0x26,'3', 
.................... 0x29,' ', 0x2a,'v', 0x2b,'f', 0x2c,'t', 0x2d,'r', 0x2e,'5', 0x31,'n', 
.................... 0x32,'b', 0x33,'h', 0x34,'g', 0x35,'y', 0x36,'6', 0x39,',', 0x3a,'m', 
.................... 0x3b,'j', 0x3c,'u', 0x3d,'7', 0x3e,'8', 0x41,',', 0x42,'k', 0x43,'i', 
.................... 0x44,'o', 0x45,'0', 0x46,'9', 0x49,'.', 0x4a,'-', 0x4b,'l', 0x4c,'', 
.................... 0x4d,'p', 0x4e,' ', 0x52,'', 0x54,'`', 0x55,'', 0x5a,13,  0x5b,'\n', 
.................... 0x5d,'', 0x61,'<', 0x66,' ',   0x69,'1', 0x6b,'4', 0x6c,'7', 0x70,'0', 
.................... 0x71,'.', 0x72,'2', 0x73,'5', 0x74,'6', 0x75,'8', 0x79,'+', 0x7a,'3', 
.................... 0x7b,'-', 0x7c,'*', 0x7d,'9', 
.................... 0,0 
.................... }; 
....................  
.................... //-------- Tabla de caracteres correspondientes a la pulsacin de la tecla 
.................... //-------- en modalidad desplazamiento (pulsando SHIFT) 
....................  
.................... unsigned char const shifted[68][2] = { 
.................... 0x0d,9, 
.................... 0x0e,'', 0x15,'Q', 0x16,'!', 0x1a,'Z', 0x1b,'S', 0x1c,'A', 0x1d,'W', 
.................... 0x1e,'"', 0x21,'C', 0x22,'X', 0x23,'D', 0x24,'E', 0x25,'$', 0x26,'', 
.................... 0x29,' ', 0x2a,'V', 0x2b,'F', 0x2c,'T', 0x2d,'R', 0x2e,'%', 0x31,'N', 
.................... 0x32,'B', 0x33,'H', 0x34,'G', 0x35,'Y', 0x36,'&', 0x39,'L', 0x3a,'M', 
.................... 0x3b,'J', 0x3c,'U', 0x3d,'/', 0x3e,'(', 0x41,';', 0x42,'K', 0x43,'I', 
.................... 0x44,'O', 0x45,'=', 0x46,')', 0x49,':', 0x4a,'_', 0x4b,'L', 0x4c,'', 
.................... 0x4d,'P', 0x4e,'?', 0x52,'', 0x54,'^', 0x55,'', 0x5a,13,  0x5b,'*', 
.................... 0x5d,'', 0x61,'>', 0x66,' ',   0x69,'1', 0x6b,'4', 0x6c,'7', 0x70,'0', 
.................... 0x71,'.', 0x72,'2', 0x73,'5', 0x74,'6', 0x75,'8', 0x79,'+', 0x7a,'3', 
.................... 0x7b,'-', 0x7c,'*', 0x7d,'9', 
.................... 0,0 
.................... }; 
....................  
.................... //################Espacio para declaracion de funciones########## 
....................  
.................... int32 rule3(int32  x, int32  in_min, int32  in_max, int32  out_min, int32  out_max); //Regla de tres 
.................... void imprimir_sensores(); //Funcion para imprimir datos de los sensores 
.................... void decode(unsigned char sc); 
.................... //----------------------------------------------------------------------------- 
.................... // Rutina de gestin de interrupciones 
.................... //----------------------------------------------------------------------------- 
....................  
.................... #int_ext 
.................... void int_ext_isr(void){ 
....................  
.................... unsigned char data; 
....................    //-------- Los bit 3 a 10 se considerran datos. Paridad, start y stop 
....................    //-------- son ignorados 
....................    if(bitcount < 11 && bitcount > 2){ 
*
0146C:  MOVF   44,W
0146E:  SUBLW  0A
01470:  BNC   148A
01472:  MOVF   44,W
01474:  SUBLW  02
01476:  BC    148A
....................       data = (data >> 1); //desplaza el dato ? 
01478:  BCF    FD8.0
0147A:  RRCF   x9E,F
....................       status_b3 = input(PIN_B3); 
0147C:  BSF    F93.3
0147E:  CLRF   x70
01480:  BTFSC  F81.3
01482:  INCF   x70,F
....................       if((status_b3) == 1){ 
01484:  DECFSZ x70,W
01486:  BRA    148A
....................           data = data | 0x80; 
01488:  BSF    x9E.7
....................       } 
....................    } 
....................    //-------- Todos los bits se han recibido 
....................    if(--bitcount == 0){ 
0148A:  DECFSZ 44,F
0148C:  BRA    149E
....................    
....................       decode(data); 
0148E:  MOVFF  9E,9F
01492:  BRA    1236
....................       data = 0; 
01494:  CLRF   x9E
....................       bitcount = 11; 
01496:  MOVLW  0B
01498:  MOVWF  44
....................       got_interrupt = TRUE; 
0149A:  MOVLW  01
0149C:  MOVWF  x6E
....................    } 
....................    got_interrupt = TRUE; 
0149E:  MOVLW  01
014A0:  MOVWF  x6E
....................    interrupt_count++; 
014A2:  INCF   x6F,F
....................    disable_interrupts(INT_EXT); 
014A4:  BCF    FF2.4
.................... } 
....................  
.................... //################################################################ 
014A6:  BCF    FF2.1
014A8:  GOTO   1068
.................... void main(void) 
.................... { 
*
01F48:  CLRF   FF8
01F4A:  BCF    FD0.7
01F4C:  BSF    07.7
01F4E:  MOVLB  E
01F50:  MOVLW  55
01F52:  MOVWF  FA7
01F54:  MOVLW  AA
01F56:  MOVWF  FA7
01F58:  BCF    xBF.0
01F5A:  MOVLW  14
01F5C:  MOVWF  xF7
01F5E:  MOVLW  06
01F60:  MOVWF  xD3
01F62:  MOVLW  55
01F64:  MOVWF  FA7
01F66:  MOVLW  AA
01F68:  MOVWF  FA7
01F6A:  BSF    xBF.0
01F6C:  CLRF   FEA
01F6E:  CLRF   FE9
01F70:  BCF    F93.2
01F72:  BSF    F8A.2
01F74:  BCF    21.1
01F76:  MOVLW  01
01F78:  MOVWF  45
01F7A:  MOVWF  46
01F7C:  MOVWF  47
01F7E:  MOVWF  48
01F80:  MOVWF  49
01F82:  MOVLB  0
01F84:  CLRF   x71
01F86:  CLRF   x72
01F88:  CLRF   x73
01F8A:  MOVLB  1
01F8C:  CLRF   x88
01F8E:  MOVLW  FF
01F90:  MOVLB  F
01F92:  MOVWF  x48
01F94:  BCF    FC2.6
01F96:  BCF    FC2.7
01F98:  MOVF   x49,W
01F9A:  ANDLW  E0
01F9C:  IORLW  1F
01F9E:  MOVWF  x49
01FA0:  CLRF   x25
01FA2:  CLRF   FD1
01FA4:  CLRF   FD2
01FA6:  CLRF   1B
01FA8:  CLRF   1C
01FAA:  MOVLW  96
01FAC:  MOVWF  33
01FAE:  CLRF   34
01FB0:  MOVLW  E8
01FB2:  MOVWF  35
01FB4:  MOVLW  03
01FB6:  MOVWF  36
01FB8:  MOVLW  64
01FBA:  MOVWF  37
01FBC:  CLRF   38
....................    mcu_init();//Inicializa el microcontrolador 
01FBE:  BSF    F9B.6
01FC0:  MOVLW  00
01FC2:  MOVWF  F92
01FC4:  MOVWF  F93
01FC6:  MOVWF  F95
01FC8:  BCF    F96.0
01FCA:  BCF    F96.1
01FCC:  BCF    F96.2
01FCE:  MOVWF  F94
....................    //PULL_UP=0;//Con un 0 se habilita la resistencia pull-up del puerto b. con 1 se deshabilita 
....................  //  set_tris_b(0b00011011);//Define cuales pines van a usar la resistencia pull-up y cuales van a ser pines de salida del puerto B 
....................    set_tris_a (0b00100000); 
01FD0:  MOVLW  20
01FD2:  MOVWF  F92
....................    set_tris_b (0b00001111); 
01FD4:  MOVLW  0F
01FD6:  MOVWF  F93
....................    set_tris_d (0x00); 
01FD8:  MOVLW  00
01FDA:  MOVWF  F95
....................    bitcount = 11; 
01FDC:  MOVLW  0B
01FDE:  MOVWF  44
....................    lcd_init_4bits();//Inicializa la LCD 
01FE0:  MOVLB  0
01FE2:  BRA    181A
....................      //-------- Los pins indicados (B0 y B3) son configurados como entradas. 
....................    output_float(PIN_B0); 
01FE4:  BSF    F93.0
....................    output_float(PIN_B3); 
01FE6:  BSF    F93.3
....................  
....................     
....................     
....................    //-------- 
....................  
....................    output_low(PIN_B5); 
01FE8:  BCF    F93.5
01FEA:  BCF    F8A.5
....................  
....................    //-------- Inicializa las variables usadas por la rutina de interrupcin 
....................    //-------- antes de activar las interrupciones 
....................    interrupt_count = 0; 
01FEC:  CLRF   x6F
....................    got_interrupt = FALSE; 
01FEE:  CLRF   x6E
....................    status_b3 = 0; 
01FF0:  CLRF   x70
....................  
....................    //-------- Desde que se activ el modo PULLUPS del puerto B, el estado 
....................    //-------- normal del pin B0 es ALTO. La gestin de la interrupcin externa 
....................    //-------- se gestiona cuando se produce un cambio de nivel ALTO a BAJO. 
....................    ext_int_edge(H_TO_L); 
01FF2:  BCF    FF1.6
....................  
....................    //-------- Asegurarse de que el el bit de flag de la interrupcin externa 
....................    //-------- es borrado antes de activar la gestin de dicha interrupcin 
....................    //-------- externa. 
....................    INTF_BIT = 0; 
01FF4:  BCF    FF2.1
....................  
....................    enable_interrupts(INT_EXT); 
01FF6:  BSF    FF2.4
....................    enable_interrupts(GLOBAL); 
01FF8:  MOVLW  C0
01FFA:  IORWF  FF2,F
....................    setup_adc(ADC_CLOCK_INTERNAL);   //Inicializamos el ADC 
01FFC:  MOVF   FC1,W
01FFE:  ANDLW  C0
02000:  IORLW  03
02002:  MOVWF  FC1
02004:  BSF    FC1.7
02006:  BSF    FC2.0
02008:  BSF    FC2.7
0200A:  BSF    FC2.1
0200C:  BTFSC  FC2.1
0200E:  BRA    200C
02010:  BCF    FC2.7
....................    setup_adc_ports(sAN2|sAN3|sAN11,VSS_VDD);  
02012:  MOVLW  F3
02014:  MOVLB  F
02016:  MOVWF  x48
02018:  BCF    FC2.6
0201A:  BCF    FC2.7
0201C:  MOVF   x49,W
0201E:  ANDLW  E0
02020:  IORLW  17
02022:  MOVWF  x49
....................    printf(lcd_putc_4bits,"\f   Bienvenido \nMenu[ESC]");   
02024:  MOVLW  AC
02026:  MOVWF  FF6
02028:  MOVLW  14
0202A:  MOVWF  FF7
0202C:  MOVLW  00
0202E:  MOVWF  FF8
02030:  MOVLB  0
02032:  RCALL  188A
....................    delay_ms(1000); 
02034:  MOVLW  04
02036:  MOVWF  x74
02038:  MOVLW  FA
0203A:  MOVWF  x83
0203C:  CALL   16D4
02040:  DECFSZ x74,F
02042:  BRA    2038
....................  
....................   // printf(lcd_putc_4bits,"\f"); 
....................   while(true){ 
....................  // if(tecla){ 
....................   //lcd_putc_4bits(tecla); 
....................   //tecla=0; 
....................  // } 
....................    if(tecla=='*' || tecla=='#'){ 
02044:  MOVF   22,W
02046:  SUBLW  2A
02048:  BZ    2050
0204A:  MOVF   22,W
0204C:  SUBLW  23
0204E:  BNZ   205C
....................    tecla=0; 
02050:  CLRF   22
....................    delay_ms(50); 
02052:  MOVLW  32
02054:  MOVWF  x83
02056:  CALL   16D4
....................    break; 
0205A:  BRA    2068
....................    } 
....................   /*  if(EnterFlag){ 
....................      printf(lcd_putc_4bits,"\n"); 
....................     EnterFlag=false; 
....................     }*/ 
....................     //-------- Chequear si se produce alguna interrupcin (got_interrupt). 
....................       if(got_interrupt == TRUE){ 
0205C:  DECFSZ x6E,W
0205E:  BRA    2066
....................       //-------- Borrar el flag global que se inicio en la rutina de servicio 
....................       //-------- de interrupciones externas. 
....................        got_interrupt = FALSE; 
02060:  CLRF   x6E
....................        //-------- Esperar 50 ms para evitar rebotes en los contactos de las teclas. 
....................             //-------- Borrar cualquier interrupcin producida durante el periodo de espera. 
....................             INTF_BIT = 0; 
02062:  BCF    FF2.1
....................             //-------- Reactivar interrupciones 
....................             enable_interrupts(INT_EXT); 
02064:  BSF    FF2.4
....................  
....................          } // --- End If --- 
....................   } 
02066:  BRA    2044
....................    printf(lcd_putc_4bits,"\f[<-]Delete\n[ENTER]Set"); 
02068:  MOVLW  C6
0206A:  MOVWF  FF6
0206C:  MOVLW  14
0206E:  MOVWF  FF7
02070:  MOVLW  00
02072:  MOVWF  FF8
02074:  RCALL  188A
....................    delay_ms(2500);    
02076:  MOVLW  0A
02078:  MOVWF  x74
0207A:  MOVLW  FA
0207C:  MOVWF  x83
0207E:  CALL   16D4
02082:  DECFSZ x74,F
02084:  BRA    207A
....................    printf(lcd_putc_4bits,"\fAsigne los sig.\n Limites->"); 
02086:  MOVLW  DE
02088:  MOVWF  FF6
0208A:  MOVLW  14
0208C:  MOVWF  FF7
0208E:  MOVLW  00
02090:  MOVWF  FF8
02092:  CALL   188A
....................    delay_ms(2500); 
02096:  MOVLW  0A
02098:  MOVWF  x74
0209A:  MOVLW  FA
0209C:  MOVWF  x83
0209E:  CALL   16D4
020A2:  DECFSZ x74,F
020A4:  BRA    209A
....................    printf(lcd_putc_4bits,"\f[A]Temp. [C]Luz\n[B]Humedad [ESC]"); 
020A6:  MOVLW  FA
020A8:  MOVWF  FF6
020AA:  MOVLW  14
020AC:  MOVWF  FF7
020AE:  MOVLW  00
020B0:  MOVWF  FF8
020B2:  CALL   188A
....................    tecla=0; 
020B6:  CLRF   22
....................  
....................    while(tecla!='*') //Hasta que se presione la tecla '*' lee los valores limites 
....................    { 
020B8:  MOVF   22,W
020BA:  SUBLW  2A
020BC:  BTFSC  FD8.2
020BE:  BRA    23BA
....................    if(tecla){ 
020C0:  MOVF   22,F
020C2:  BTFSC  FD8.2
020C4:  BRA    23AE
....................     
....................    if(tecla >= 97 && tecla <= 99) tecla-=32; 
020C6:  MOVF   22,W
020C8:  SUBLW  60
020CA:  BC    20D6
020CC:  MOVF   22,W
020CE:  SUBLW  63
020D0:  BNC   20D6
020D2:  MOVLW  20
020D4:  SUBWF  22,F
....................     
....................       switch(tecla) //Menu 
....................       { 
020D6:  MOVF   22,W
020D8:  XORLW  41
020DA:  BZ    20EA
020DC:  XORLW  03
020DE:  BZ    20FC
020E0:  XORLW  01
020E2:  BZ    210E
020E4:  XORLW  60
020E6:  BZ    2120
020E8:  BRA    22EE
....................          case 'A': printf(lcd_putc_4bits,"\fTemperatura Max: \n         [Enter]");break; 
020EA:  MOVLW  1C
020EC:  MOVWF  FF6
020EE:  MOVLW  15
020F0:  MOVWF  FF7
020F2:  MOVLW  00
020F4:  MOVWF  FF8
020F6:  CALL   188A
020FA:  BRA    22EE
....................          case 'B': printf(lcd_putc_4bits,"\fHumedad Max: \n         [Enter]");break; 
020FC:  MOVLW  40
020FE:  MOVWF  FF6
02100:  MOVLW  15
02102:  MOVWF  FF7
02104:  MOVLW  00
02106:  MOVWF  FF8
02108:  CALL   188A
0210C:  BRA    22EE
....................          case 'C': printf(lcd_putc_4bits,"\fLuz Max: \n         [Enter]");break; 
0210E:  MOVLW  60
02110:  MOVWF  FF6
02112:  MOVLW  15
02114:  MOVWF  FF7
02116:  MOVLW  00
02118:  MOVWF  FF8
0211A:  CALL   188A
0211E:  BRA    22EE
....................          case '#': lcdCursorOff(); printf(lcd_putc_4bits,"\f       OK!       \n");//Asigna el valor ingresado 
02120:  CALL   18B2
02124:  MOVLW  7C
02126:  MOVWF  FF6
02128:  MOVLW  15
0212A:  MOVWF  FF7
0212C:  MOVLW  00
0212E:  MOVWF  FF8
02130:  CALL   188A
....................          switch(menu) 
....................          { //Guardar limites ingresados 
02134:  MOVF   42,W
02136:  XORLW  41
02138:  BZ    2146
0213A:  XORLW  03
0213C:  BZ    21C6
0213E:  XORLW  01
02140:  BTFSC  FD8.2
02142:  BRA    223A
02144:  BRA    22CA
....................             case 'A': //Temperatura 
....................             outLimitMax[0] =  atol(inputTeclado);//Convierte los caracteres almacenados en el vector buffer y los guarda en el vector outlimitMax 
02146:  CLRF   x75
02148:  MOVLW  23
0214A:  MOVWF  x74
0214C:  CALL   190E
02150:  MOVFF  02,3A
02154:  MOVFF  01,39
....................             if(outLimitMax[0]>outMax[0]){printf(lcd_putc_4bits,"\fEl limite maximo \n  es->%Lu C",outMax[0]);outLimitMax[0]=0;break;} 
02158:  MOVF   34,W
0215A:  SUBWF  3A,W
0215C:  BNC   219C
0215E:  BNZ   2166
02160:  MOVF   39,W
02162:  SUBWF  33,W
02164:  BC    219C
02166:  MOVLW  90
02168:  MOVWF  FF6
0216A:  MOVLW  15
0216C:  MOVWF  FF7
0216E:  MOVLW  00
02170:  MOVWF  FF8
02172:  MOVLW  19
02174:  MOVWF  x74
02176:  RCALL  1AF6
02178:  MOVLW  10
0217A:  MOVWF  FE9
0217C:  MOVFF  34,75
02180:  MOVFF  33,74
02184:  RCALL  1B1C
02186:  MOVLW  20
02188:  MOVWF  x7D
0218A:  CALL   1854
0218E:  MOVLW  43
02190:  MOVWF  x7D
02192:  CALL   1854
02196:  CLRF   3A
02198:  CLRF   39
0219A:  BRA    22CA
....................             printf(lcd_putc_4bits,"Temp. Max->%LuC",outLimitMax[0]); 
0219C:  MOVLW  B0
0219E:  MOVWF  FF6
021A0:  MOVLW  15
021A2:  MOVWF  FF7
021A4:  MOVLW  00
021A6:  MOVWF  FF8
021A8:  MOVLW  0B
021AA:  MOVWF  x74
021AC:  RCALL  1AF6
021AE:  MOVLW  10
021B0:  MOVWF  FE9
021B2:  MOVFF  3A,75
021B6:  MOVFF  39,74
021BA:  RCALL  1B1C
021BC:  MOVLW  43
021BE:  MOVWF  x7D
021C0:  CALL   1854
....................             break; 
021C4:  BRA    22CA
....................             case 'B': //Humedad 
....................             outLimitMax[2]=atol(inputTeclado); 
021C6:  CLRF   x75
021C8:  MOVLW  23
021CA:  MOVWF  x74
021CC:  CALL   190E
021D0:  MOVFF  02,3E
021D4:  MOVFF  01,3D
....................             if(outLimitMax[2]>outMax[2]){printf(lcd_putc_4bits,"\fEl limite maximo \n  es->%Lu",outMax[2]);lcd_putc_4bits('%');break;} 
021D8:  MOVF   38,W
021DA:  SUBWF  3E,W
021DC:  BNC   2210
021DE:  BNZ   21E6
021E0:  MOVF   3D,W
021E2:  SUBWF  37,W
021E4:  BC    2210
021E6:  MOVLW  C0
021E8:  MOVWF  FF6
021EA:  MOVLW  15
021EC:  MOVWF  FF7
021EE:  MOVLW  00
021F0:  MOVWF  FF8
021F2:  MOVLW  19
021F4:  MOVWF  x74
021F6:  RCALL  1AF6
021F8:  MOVLW  10
021FA:  MOVWF  FE9
021FC:  MOVFF  38,75
02200:  MOVFF  37,74
02204:  RCALL  1B1C
02206:  MOVLW  25
02208:  MOVWF  x7D
0220A:  CALL   1854
0220E:  BRA    22CA
....................             printf(lcd_putc_4bits,"Hum. Max->%Lu",outLimitMax[2]); 
02210:  MOVLW  DE
02212:  MOVWF  FF6
02214:  MOVLW  15
02216:  MOVWF  FF7
02218:  MOVLW  00
0221A:  MOVWF  FF8
0221C:  MOVLW  0A
0221E:  MOVWF  x74
02220:  RCALL  1AF6
02222:  MOVLW  10
02224:  MOVWF  FE9
02226:  MOVFF  3E,75
0222A:  MOVFF  3D,74
0222E:  RCALL  1B1C
....................             lcd_putc_4bits('%'); 
02230:  MOVLW  25
02232:  MOVWF  x7D
02234:  CALL   1854
....................             break; 
02238:  BRA    22CA
....................             case 'C': //Luz 
....................             outLimitMax[1]=atol(inputTeclado); 
0223A:  CLRF   x75
0223C:  MOVLW  23
0223E:  MOVWF  x74
02240:  CALL   190E
02244:  MOVFF  02,3C
02248:  MOVFF  01,3B
....................             if(outLimitMax[1]>outMax[1]){printf(lcd_putc_4bits,"\fEl limite maximo \n  es->%Lu lm",outMax[1]);outLimitMax[1]=0;break;} 
0224C:  MOVF   36,W
0224E:  SUBWF  3C,W
02250:  BNC   2298
02252:  BNZ   225A
02254:  MOVF   3B,W
02256:  SUBWF  35,W
02258:  BC    2298
0225A:  MOVLW  EC
0225C:  MOVWF  FF6
0225E:  MOVLW  15
02260:  MOVWF  FF7
02262:  MOVLW  00
02264:  MOVWF  FF8
02266:  MOVLW  19
02268:  MOVWF  x74
0226A:  RCALL  1AF6
0226C:  MOVLW  10
0226E:  MOVWF  FE9
02270:  MOVFF  36,75
02274:  MOVFF  35,74
02278:  RCALL  1B1C
0227A:  MOVLW  20
0227C:  MOVWF  x7D
0227E:  CALL   1854
02282:  MOVLW  6C
02284:  MOVWF  x7D
02286:  CALL   1854
0228A:  MOVLW  6D
0228C:  MOVWF  x7D
0228E:  CALL   1854
02292:  CLRF   3C
02294:  CLRF   3B
02296:  BRA    22CA
....................             printf(lcd_putc_4bits,"Luz .Max->%Lulm",outLimitMax[1]); 
02298:  MOVLW  0C
0229A:  MOVWF  FF6
0229C:  MOVLW  16
0229E:  MOVWF  FF7
022A0:  MOVLW  00
022A2:  MOVWF  FF8
022A4:  MOVLW  0A
022A6:  MOVWF  x74
022A8:  RCALL  1AF6
022AA:  MOVLW  10
022AC:  MOVWF  FE9
022AE:  MOVFF  3C,75
022B2:  MOVFF  3B,74
022B6:  RCALL  1B1C
022B8:  MOVLW  6C
022BA:  MOVWF  x7D
022BC:  CALL   1854
022C0:  MOVLW  6D
022C2:  MOVWF  x7D
022C4:  CALL   1854
....................             break; 
022C8:  BRA    22CA
....................          } 
....................          delay_ms(3000); 
022CA:  MOVLW  0C
022CC:  MOVWF  x74
022CE:  MOVLW  FA
022D0:  MOVWF  x83
022D2:  CALL   16D4
022D6:  DECFSZ x74,F
022D8:  BRA    22CE
....................          printf(lcd_putc_4bits,"\f[A]Temp. [C]Luz\n[B]Humedad [ESC]");  writeLCD=0; 
022DA:  MOVLW  1C
022DC:  MOVWF  FF6
022DE:  MOVLW  16
022E0:  MOVWF  FF7
022E2:  MOVLW  00
022E4:  MOVWF  FF8
022E6:  CALL   188A
022EA:  BCF    21.1
....................          break; 
022EC:  BRA    22EE
....................       } 
....................       if(tecla=='A'||tecla=='B'||tecla=='C') //Si la tecla presionada hace parte del menu, la guarda 
022EE:  MOVF   22,W
022F0:  SUBLW  41
022F2:  BZ    2300
022F4:  MOVF   22,W
022F6:  SUBLW  42
022F8:  BZ    2300
022FA:  MOVF   22,W
022FC:  SUBLW  43
022FE:  BNZ   2326
....................       { 
....................          menu=tecla; 
02300:  MOVFF  22,42
....................          memset(inputTeclado,0,4); //Borra los valores ingresados anteriormente 
02304:  CLRF   FEA
02306:  MOVLW  23
02308:  MOVWF  FE9
0230A:  CLRF   x74
0230C:  CLRF   x76
0230E:  MOVLW  04
02310:  MOVWF  x75
02312:  BRA    1BCE
....................          lcd_ubicaxy_4bits(1,2);  
02314:  MOVLW  01
02316:  MOVWF  x7E
02318:  MOVLW  02
0231A:  MOVWF  x7F
0231C:  CALL   17BA
....................          j=0; 
02320:  CLRF   2A
02322:  CLRF   29
....................          writeLCD=1; 
02324:  BSF    21.1
....................       } 
....................        
....................       if(writeLCD==1) //Para habilitar la entrada de numeros cuando se entra a un submenu 
02326:  BTFSS  21.1
02328:  BRA    23AC
....................       { 
....................          lcdCursorOn(); //Habilitar Cursor 
0232A:  BRA    1BEA
....................          if(tecla>='0' && tecla <= '9' && j < 4 ) //Cuatro digitos maximos 
0232C:  MOVF   22,W
0232E:  SUBLW  2F
02330:  BC    2360
02332:  MOVF   22,W
02334:  SUBLW  39
02336:  BNC   2360
02338:  MOVF   2A,F
0233A:  BNZ   2360
0233C:  MOVF   29,W
0233E:  SUBLW  03
02340:  BNC   2360
....................          {  lcd_putc_4bits(tecla);//Muestra el numero presionado 
02342:  MOVFF  22,7D
02346:  CALL   1854
....................             inputTeclado[j]=tecla;//Almacena el numero presionado 
0234A:  MOVLW  23
0234C:  ADDWF  29,W
0234E:  MOVWF  FE9
02350:  MOVLW  00
02352:  ADDWFC 2A,W
02354:  MOVWF  FEA
02356:  MOVFF  22,FEF
....................             j++;//Aumenta el contador para almacenar el siguiente numero presionado 
0235A:  INCF   29,F
0235C:  BTFSC  FD8.2
0235E:  INCF   2A,F
....................          } 
....................          if(tecla=='D' && j>0 ) //Borrar numero ingresado entre 0 y 4 digitos 
02360:  MOVF   22,W
02362:  SUBLW  44
02364:  BNZ   23AC
02366:  MOVF   29,F
02368:  BNZ   236E
0236A:  MOVF   2A,F
0236C:  BZ    23AC
....................          { 
....................             lcd_ubicaxy_4bits(j,2); 
0236E:  MOVFF  29,7E
02372:  MOVLW  02
02374:  MOVWF  x7F
02376:  CALL   17BA
....................             lcd_putc_4bits(" "); 
0237A:  MOVLW  3E
0237C:  MOVWF  FF6
0237E:  MOVLW  16
02380:  MOVWF  FF7
02382:  MOVLW  00
02384:  MOVWF  FF8
02386:  CALL   188A
....................             lcd_ubicaxy_4bits(j,2); 
0238A:  MOVFF  29,7E
0238E:  MOVLW  02
02390:  MOVWF  x7F
02392:  CALL   17BA
....................             j--; 
02396:  MOVF   29,W
02398:  BTFSC  FD8.2
0239A:  DECF   2A,F
0239C:  DECF   29,F
....................             inputTeclado[j]=0x00; 
0239E:  MOVLW  23
023A0:  ADDWF  29,W
023A2:  MOVWF  FE9
023A4:  MOVLW  00
023A6:  ADDWFC 2A,W
023A8:  MOVWF  FEA
023AA:  CLRF   FEF
....................          } 
....................      
....................       } 
....................       tecla=0; 
023AC:  CLRF   22
....................    //   delay_ms(10); 
....................    } 
....................          
....................     //-------- Chequear si se produce alguna interrupcin (got_interrupt). 
....................       if(got_interrupt == TRUE){ 
023AE:  DECFSZ x6E,W
023B0:  BRA    23B8
....................       //-------- Borrar el flag global que se inicio en la rutina de servicio 
....................       //-------- de interrupciones externas. 
....................        got_interrupt = FALSE; 
023B2:  CLRF   x6E
....................        //-------- Esperar 50 ms para evitar rebotes en los contactos de las teclas. 
....................             //-------- Borrar cualquier interrupcin producida durante el periodo de espera. 
....................             INTF_BIT = 0; 
023B4:  BCF    FF2.1
....................             //-------- Reactivar interrupciones 
....................             enable_interrupts(INT_EXT); 
023B6:  BSF    FF2.4
....................  
....................          } // --- End If --- 
....................    } //Fin de asignacion de limites 
023B8:  BRA    20B8
....................    lcdCursorOff(); //Deshabilita el cursor 
023BA:  CALL   18B2
....................    printf(lcd_putc_4bits,"\fTmp:   C Hm:   %c\nLuz:      ",'%'); 
023BE:  MOVLW  40
023C0:  MOVWF  FF6
023C2:  MOVLW  16
023C4:  MOVWF  FF7
023C6:  MOVLW  00
023C8:  MOVWF  FF8
023CA:  MOVLW  10
023CC:  MOVWF  x74
023CE:  CALL   1AF6
023D2:  MOVLW  25
023D4:  MOVWF  x7D
023D6:  CALL   1854
023DA:  MOVLW  52
023DC:  MOVWF  FF6
023DE:  MOVLW  16
023E0:  MOVWF  FF7
023E2:  MOVLW  00
023E4:  MOVWF  FF8
023E6:  MOVLW  0B
023E8:  MOVWF  x74
023EA:  CALL   1AF6
....................    //Configuracion de PWM 
....................    setup_timer_2(T2_DIV_BY_16,74,1);   // 10KHz 
023EE:  MOVLW  00
023F0:  IORLW  06
023F2:  MOVWF  FCA
023F4:  MOVLW  4A
023F6:  MOVWF  FCB
....................    setup_ccp5(CCP_PWM); //Captura o compara o PWM  PIN B5     
023F8:  BCF    F93.5
023FA:  BCF    F8A.5
023FC:  MOVLW  0C
023FE:  MOVLB  F
02400:  MOVWF  x0F
02402:  BCF    x51.2
....................    setup_ccp6(CCP_PWM); // PIN B6 
02404:  BCF    F93.6
02406:  BCF    F8A.6
02408:  MOVWF  x0C
0240A:  BCF    x51.4
....................    setup_ccp7(CCP_PWM); // PIN B7 
0240C:  BCF    F93.7
0240E:  BCF    F8A.7
02410:  MOVWF  x09
02412:  MOVLW  3F
02414:  ANDWF  x51,F
02416:  MOVLW  00
02418:  IORWF  x51,F
....................    set_pwm5_duty(0);  //Inicia PWM en 0 , PWM 8 bits ( 0 - 255) 
0241A:  CLRF   x10
....................    set_pwm6_duty(0);  //Inicializar PWM 
0241C:  CLRF   x0D
....................    set_pwm7_duty(0);  //Inicializar PWM 
0241E:  CLRF   x0A
....................  while(true) 
....................    { 
....................       //Borrar valores anteriores 
....................       sensorValues[0]=0; 
02420:  CLRF   2C
02422:  CLRF   2B
....................       sensorValues[1]=0; 
02424:  CLRF   2E
02426:  CLRF   2D
....................       sensorValues[2]=0; 
02428:  CLRF   30
0242A:  CLRF   2F
....................      //Lectura de sensores 
....................       set_adc_channel(3); //Selecciona el canal del ADC para leer la temperatura 
0242C:  MOVLW  0C
0242E:  MOVWF  01
02430:  MOVF   FC2,W
02432:  ANDLW  C3
02434:  IORWF  01,W
02436:  MOVWF  FC2
....................       delay_us(100); 
02438:  MOVLW  64
0243A:  MOVLB  0
0243C:  MOVWF  x74
0243E:  CALL   1BF6
....................       for(i=0;i<10;i++) //Toma 10 muestras del adc para posteriormente realizar un promedio 
02442:  CLRF   28
02444:  CLRF   27
02446:  MOVF   28,F
02448:  BNZ   246E
0244A:  MOVF   27,W
0244C:  SUBLW  09
0244E:  BNC   246E
....................       { 
....................          sensorValues[0]= sensorValues[0] + read_adc(); //Temperatura 
02450:  BSF    FC2.1
02452:  BTFSC  FC2.1
02454:  BRA    2452
02456:  MOVF   FC3,W
02458:  ADDWF  2B,F
0245A:  MOVF   FC4,W
0245C:  ADDWFC 2C,F
....................          delay_ms(1); 
0245E:  MOVLW  01
02460:  MOVWF  x83
02462:  CALL   16D4
....................       } 
02466:  INCF   27,F
02468:  BTFSC  FD8.2
0246A:  INCF   28,F
0246C:  BRA    2446
....................        
....................       set_adc_channel(2); // Lee el sensor de Luz 
0246E:  MOVLW  08
02470:  MOVWF  01
02472:  MOVF   FC2,W
02474:  ANDLW  C3
02476:  IORWF  01,W
02478:  MOVWF  FC2
....................       delay_us(100); 
0247A:  MOVLW  64
0247C:  MOVWF  x74
0247E:  CALL   1BF6
....................       for(i=0;i<20;i++) 
02482:  CLRF   28
02484:  CLRF   27
02486:  MOVF   28,F
02488:  BNZ   24AE
0248A:  MOVF   27,W
0248C:  SUBLW  13
0248E:  BNC   24AE
....................       { 
....................          //Toma 20 muestras del adc 
....................          sensorValues[1]+=read_adc(); //LUZ 
02490:  BSF    FC2.1
02492:  BTFSC  FC2.1
02494:  BRA    2492
02496:  MOVF   FC3,W
02498:  ADDWF  2D,F
0249A:  MOVF   FC4,W
0249C:  ADDWFC 2E,F
....................          delay_ms(1); 
0249E:  MOVLW  01
024A0:  MOVWF  x83
024A2:  CALL   16D4
....................       } 
024A6:  INCF   27,F
024A8:  BTFSC  FD8.2
024AA:  INCF   28,F
024AC:  BRA    2486
....................        
....................       set_adc_channel(11); // Lee la humedad 
024AE:  MOVLW  2C
024B0:  MOVWF  01
024B2:  MOVF   FC2,W
024B4:  ANDLW  C3
024B6:  IORWF  01,W
024B8:  MOVWF  FC2
....................       delay_us(100); 
024BA:  MOVLW  64
024BC:  MOVWF  x74
024BE:  CALL   1BF6
....................       for(i=0;i<10;i++) 
024C2:  CLRF   28
024C4:  CLRF   27
024C6:  MOVF   28,F
024C8:  BNZ   24EE
024CA:  MOVF   27,W
024CC:  SUBLW  09
024CE:  BNC   24EE
....................       { 
....................          //Toma 10 muestras del adc 
....................          sensorValues[2]+=read_adc(); //Humedad 
024D0:  BSF    FC2.1
024D2:  BTFSC  FC2.1
024D4:  BRA    24D2
024D6:  MOVF   FC3,W
024D8:  ADDWF  2F,F
024DA:  MOVF   FC4,W
024DC:  ADDWFC 30,F
....................          delay_ms(1); 
024DE:  MOVLW  01
024E0:  MOVWF  x83
024E2:  CALL   16D4
....................       } 
024E6:  INCF   27,F
024E8:  BTFSC  FD8.2
024EA:  INCF   28,F
024EC:  BRA    24C6
....................        
....................       sensorValues[0]/=10;//Realiza el promedio para el sensor de temperatura 
024EE:  MOVFF  2C,75
024F2:  MOVFF  2B,74
024F6:  CLRF   x77
024F8:  MOVLW  0A
024FA:  MOVWF  x76
024FC:  CALL   1C16
02500:  MOVFF  02,2C
02504:  MOVFF  01,2B
....................       sensorValues[1]/=20;//Realiza el promedio para el sensor de Luz 
02508:  MOVFF  2E,75
0250C:  MOVFF  2D,74
02510:  CLRF   x77
02512:  MOVLW  14
02514:  MOVWF  x76
02516:  CALL   1C16
0251A:  MOVFF  02,2E
0251E:  MOVFF  01,2D
....................       sensorValues[2]/=10;//Realiza el promedio para el sensor de Humedad 
02522:  MOVFF  30,75
02526:  MOVFF  2F,74
0252A:  CLRF   x77
0252C:  MOVLW  0A
0252E:  MOVWF  x76
02530:  CALL   1C16
02534:  MOVFF  02,30
02538:  MOVFF  01,2F
....................  
....................                         
....................      sensorValues[0]= rule3(sensorValues[0],12,1862,0,150);//Realiza regla de tres para determinar la temperatura,sabiendo que un valor adc de 12=1C y 1861=150C 
0253C:  CLRF   x77
0253E:  CLRF   x76
02540:  MOVFF  2C,75
02544:  MOVFF  2B,74
02548:  CLRF   x7B
0254A:  CLRF   x7A
0254C:  CLRF   x79
0254E:  MOVLW  0C
02550:  MOVWF  x78
02552:  CLRF   x7F
02554:  CLRF   x7E
02556:  MOVLW  07
02558:  MOVWF  x7D
0255A:  MOVLW  46
0255C:  MOVWF  x7C
0255E:  CLRF   x83
02560:  CLRF   x82
02562:  CLRF   x81
02564:  CLRF   x80
02566:  CLRF   x87
02568:  CLRF   x86
0256A:  CLRF   x85
0256C:  MOVLW  96
0256E:  MOVWF  x84
02570:  CALL   1D3E
02574:  MOVFF  01,2C
02578:  MOVFF  00,2B
....................                          // 1C = (10mV * 4095 ) / 3.3V ,  150C =  (150 * 10mV * 4095 ) / 3.3V 
....................     
....................       if(sensorValues[1] < 600) sensorValues[1]=0; 
0257C:  MOVF   2E,W
0257E:  SUBLW  02
02580:  BNC   2590
02582:  BNZ   258A
02584:  MOVF   2D,W
02586:  SUBLW  57
02588:  BNC   2590
0258A:  CLRF   2E
0258C:  CLRF   2D
....................       else sensorValues[1] = (unsigned int16) rule3(sensorValues[1],0,MAX_LUMENS,0,1000); //Regla de 3 sensor de Luz 
0258E:  BRA    25CE
02590:  CLRF   x77
02592:  CLRF   x76
02594:  MOVFF  2E,75
02598:  MOVFF  2D,74
0259C:  CLRF   x7B
0259E:  CLRF   x7A
025A0:  CLRF   x79
025A2:  CLRF   x78
025A4:  CLRF   x7F
025A6:  CLRF   x7E
025A8:  MOVLW  05
025AA:  MOVWF  x7D
025AC:  CLRF   x7C
025AE:  CLRF   x83
025B0:  CLRF   x82
025B2:  CLRF   x81
025B4:  CLRF   x80
025B6:  CLRF   x87
025B8:  CLRF   x86
025BA:  MOVLW  03
025BC:  MOVWF  x85
025BE:  MOVLW  E8
025C0:  MOVWF  x84
025C2:  CALL   1D3E
025C6:  MOVFF  01,2E
025CA:  MOVFF  00,2D
....................        
....................       if(sensorValues[1] > 1000) sensorValues[1] = 1000; 
025CE:  MOVF   2E,W
025D0:  SUBLW  02
025D2:  BC    25E6
025D4:  XORLW  FF
025D6:  BNZ   25DE
025D8:  MOVF   2D,W
025DA:  SUBLW  E8
025DC:  BC    25E6
025DE:  MOVLW  03
025E0:  MOVWF  2E
025E2:  MOVLW  E8
025E4:  MOVWF  2D
....................        
....................       sensorValues[1] = 1000 - sensorValues[1]; 
025E6:  MOVLW  E8
025E8:  BSF    FD8.0
025EA:  SUBFWB 2D,F
025EC:  MOVLW  03
025EE:  SUBFWB 2E,F
....................        
....................       sensorValues[2]= rule3(sensorValues[2],0,4095,0,105); //Humedad 
025F0:  CLRF   x77
025F2:  CLRF   x76
025F4:  MOVFF  30,75
025F8:  MOVFF  2F,74
025FC:  CLRF   x7B
025FE:  CLRF   x7A
02600:  CLRF   x79
02602:  CLRF   x78
02604:  CLRF   x7F
02606:  CLRF   x7E
02608:  MOVLW  0F
0260A:  MOVWF  x7D
0260C:  SETF   x7C
0260E:  CLRF   x83
02610:  CLRF   x82
02612:  CLRF   x81
02614:  CLRF   x80
02616:  CLRF   x87
02618:  CLRF   x86
0261A:  CLRF   x85
0261C:  MOVLW  69
0261E:  MOVWF  x84
02620:  CALL   1D3E
02624:  MOVFF  01,30
02628:  MOVFF  00,2F
....................  
....................       if(sensorValues[2] > 100 ) sensorValues[2] = 100; 
0262C:  MOVF   30,F
0262E:  BNZ   2636
02630:  MOVF   2F,W
02632:  SUBLW  64
02634:  BC    263C
02636:  CLRF   30
02638:  MOVLW  64
0263A:  MOVWF  2F
....................               
....................       if(abs(sensorValues[1] - lastValueLuz) <= 6){ 
0263C:  MOVF   31,W
0263E:  SUBWF  2D,W
02640:  MOVWF  x74
02642:  MOVF   32,W
02644:  SUBWFB 2E,W
02646:  MOVWF  x75
02648:  MOVWF  03
0264A:  MOVF   x74,W
0264C:  MOVF   x75,F
0264E:  BNZ   2660
02650:  MOVF   x74,W
02652:  SUBLW  06
02654:  BNC   2660
....................       sensorValues[1] = lastValueLuz; 
02656:  MOVFF  32,2E
0265A:  MOVFF  31,2D
....................       }else{ 
0265E:  BRA    2668
....................       lastValueLuz=sensorValues[1]; 
02660:  MOVFF  2E,32
02664:  MOVFF  2D,31
....................       } 
....................       //Salidas PWM 
....................       duty1 = (unsigned int8)rule3(sensorValues[2],0,outLimitMax[2],0,255); //Bombillo Humedad 
02668:  CLRF   x77
0266A:  CLRF   x76
0266C:  MOVFF  30,75
02670:  MOVFF  2F,74
02674:  CLRF   x7B
02676:  CLRF   x7A
02678:  CLRF   x79
0267A:  CLRF   x78
0267C:  CLRF   x7F
0267E:  CLRF   x7E
02680:  MOVFF  3E,7D
02684:  MOVFF  3D,7C
02688:  CLRF   x83
0268A:  CLRF   x82
0268C:  CLRF   x81
0268E:  CLRF   x80
02690:  CLRF   x87
02692:  CLRF   x86
02694:  CLRF   x85
02696:  SETF   x84
02698:  CALL   1D3E
0269C:  MOVFF  00,3F
....................       duty2 = (unsigned int8)rule3(sensorValues[1],0,outLimitMax[1],0,255);  // Bombillo Luz 
026A0:  CLRF   x77
026A2:  CLRF   x76
026A4:  MOVFF  2E,75
026A8:  MOVFF  2D,74
026AC:  CLRF   x7B
026AE:  CLRF   x7A
026B0:  CLRF   x79
026B2:  CLRF   x78
026B4:  CLRF   x7F
026B6:  CLRF   x7E
026B8:  MOVFF  3C,7D
026BC:  MOVFF  3B,7C
026C0:  CLRF   x83
026C2:  CLRF   x82
026C4:  CLRF   x81
026C6:  CLRF   x80
026C8:  CLRF   x87
026CA:  CLRF   x86
026CC:  CLRF   x85
026CE:  SETF   x84
026D0:  CALL   1D3E
026D4:  MOVFF  00,40
....................       duty3 = (unsigned int8)rule3(sensorValues[0],0,outLimitMax[0],0,255); //Bombillo Temperatura 
026D8:  CLRF   x77
026DA:  CLRF   x76
026DC:  MOVFF  2C,75
026E0:  MOVFF  2B,74
026E4:  CLRF   x7B
026E6:  CLRF   x7A
026E8:  CLRF   x79
026EA:  CLRF   x78
026EC:  CLRF   x7F
026EE:  CLRF   x7E
026F0:  MOVFF  3A,7D
026F4:  MOVFF  39,7C
026F8:  CLRF   x83
026FA:  CLRF   x82
026FC:  CLRF   x81
026FE:  CLRF   x80
02700:  CLRF   x87
02702:  CLRF   x86
02704:  CLRF   x85
02706:  SETF   x84
02708:  CALL   1D3E
0270C:  MOVFF  00,41
....................       
....................       set_pwm5_duty(duty1); 
02710:  MOVFF  3F,F10
....................       set_pwm6_duty(duty2); 
02714:  MOVFF  40,F0D
....................       set_pwm7_duty(duty3); 
02718:  MOVFF  41,F0A
....................        
....................       if(sensorValues[0] >= outLimitMax[0]){ 
0271C:  MOVF   3A,W
0271E:  SUBWF  2C,W
02720:  BNC   2754
02722:  BNZ   272A
02724:  MOVF   39,W
02726:  SUBWF  2B,W
02728:  BNC   2754
....................       Bandera1=false; 
0272A:  BCF    21.3
....................       set_pwm7_duty(255); 
0272C:  MOVLB  F
0272E:  SETF   x0A
....................       printf(lcd_putc_4bits,"\f   Limite Max.\nde temperatura!"); 
02730:  MOVLW  5E
02732:  MOVWF  FF6
02734:  MOVLW  16
02736:  MOVWF  FF7
02738:  MOVLW  00
0273A:  MOVWF  FF8
0273C:  MOVLB  0
0273E:  CALL   188A
....................       delay_ms(500); 
02742:  MOVLW  02
02744:  MOVWF  x74
02746:  MOVLW  FA
02748:  MOVWF  x83
0274A:  CALL   16D4
0274E:  DECFSZ x74,F
02750:  BRA    2746
....................       }else if(sensorValues[2] >= outLimitMax[2]){ 
02752:  BRA    27FE
02754:  MOVF   3E,W
02756:  SUBWF  30,W
02758:  BNC   278C
0275A:  BNZ   2762
0275C:  MOVF   3D,W
0275E:  SUBWF  2F,W
02760:  BNC   278C
....................       Bandera1=false; 
02762:  BCF    21.3
....................       set_pwm5_duty(255); 
02764:  MOVLB  F
02766:  SETF   x10
....................       printf(lcd_putc_4bits,"\f   Limite Max.\n de Humedad!"); 
02768:  MOVLW  7E
0276A:  MOVWF  FF6
0276C:  MOVLW  16
0276E:  MOVWF  FF7
02770:  MOVLW  00
02772:  MOVWF  FF8
02774:  MOVLB  0
02776:  CALL   188A
....................       delay_ms(500); 
0277A:  MOVLW  02
0277C:  MOVWF  x74
0277E:  MOVLW  FA
02780:  MOVWF  x83
02782:  CALL   16D4
02786:  DECFSZ x74,F
02788:  BRA    277E
....................       }else if(sensorValues[1] >= outLimitMax[1]){ 
0278A:  BRA    27FE
0278C:  MOVF   3C,W
0278E:  SUBWF  2E,W
02790:  BNC   27C4
02792:  BNZ   279A
02794:  MOVF   3B,W
02796:  SUBWF  2D,W
02798:  BNC   27C4
....................       Bandera1=false; 
0279A:  BCF    21.3
....................       set_pwm6_duty(255); 
0279C:  MOVLB  F
0279E:  SETF   x0D
....................       printf(lcd_putc_4bits,"\f   Limite Max.\n  de Luz!"); 
027A0:  MOVLW  9C
027A2:  MOVWF  FF6
027A4:  MOVLW  16
027A6:  MOVWF  FF7
027A8:  MOVLW  00
027AA:  MOVWF  FF8
027AC:  MOVLB  0
027AE:  CALL   188A
....................       delay_ms(500); 
027B2:  MOVLW  02
027B4:  MOVWF  x74
027B6:  MOVLW  FA
027B8:  MOVWF  x83
027BA:  CALL   16D4
027BE:  DECFSZ x74,F
027C0:  BRA    27B6
....................       }else{ 
027C2:  BRA    27FE
....................       if(!Bandera1){ //Imprime una sola vez 
027C4:  BTFSC  21.3
027C6:  BRA    27FA
....................       printf(lcd_putc_4bits,"\fTmp:   C Hm:   %c\nLuz:      ",'%'); 
027C8:  MOVLW  B6
027CA:  MOVWF  FF6
027CC:  MOVLW  16
027CE:  MOVWF  FF7
027D0:  MOVLW  00
027D2:  MOVWF  FF8
027D4:  MOVLW  10
027D6:  MOVWF  x74
027D8:  CALL   1AF6
027DC:  MOVLW  25
027DE:  MOVWF  x7D
027E0:  CALL   1854
027E4:  MOVLW  C8
027E6:  MOVWF  FF6
027E8:  MOVLW  16
027EA:  MOVWF  FF7
027EC:  MOVLW  00
027EE:  MOVWF  FF8
027F0:  MOVLW  0B
027F2:  MOVWF  x74
027F4:  CALL   1AF6
....................       Bandera1=true; 
027F8:  BSF    21.3
....................       } 
....................       imprimir_sensores(); 
027FA:  GOTO   1E1E
....................       } 
....................      delay_ms(150); 
027FE:  MOVLW  96
02800:  MOVWF  x83
02802:  CALL   16D4
....................    } 
02806:  MOVLB  F
02808:  BRA    2420
....................  
.................... } 
.................... //FUNCIONES 
....................  
.................... //----------------------------------------------------------------------------- 
.................... // Decodificacin de pulsaciones 
.................... //----------------------------------------------------------------------------- 
.................... void decode(unsigned char sc) 
.................... { 
0280A:  SLEEP 
....................    static unsigned char is_up=0, shift = 0, mode = 0; 
....................    unsigned char i; 
....................  
....................       
....................    //printf(lcd_putc_4bits,"[%X]",sc); 
....................        
....................     
....................  
....................    //-------- El ltimo dato recibido fue el identificador de Up-Key 
....................    if (!is_up){ 
*
01236:  MOVF   x71,F
01238:  BTFSS  FD8.2
0123A:  BRA    1452
....................          switch (sc){ 
0123C:  MOVF   x9F,W
0123E:  XORLW  F0
01240:  BZ    1258
01242:  XORLW  E2
01244:  BZ    125E
01246:  XORLW  4B
01248:  BZ    1264
0124A:  XORLW  03
0124C:  BZ    126A
0124E:  XORLW  3C
01250:  BZ    127A
01252:  XORLW  10
01254:  BZ    1282
01256:  BRA    128A
....................                //-------- Identificador de Up-Key 
....................                case 0xF0 : 
....................                   is_up = 1; 
01258:  MOVLW  01
0125A:  MOVWF  x71
....................                   break; 
0125C:  BRA    1450
....................                //-------- SHIFT Izquierdo 
....................                case 0x12 : 
....................                   shift = 1; 
0125E:  MOVLW  01
01260:  MOVWF  x72
....................                   break; 
01262:  BRA    1450
....................                //-------- SHIFT Derecho 
....................                case 0x59 : 
....................                   shift = 1; 
01264:  MOVLW  01
01266:  MOVWF  x72
....................                   break; 
01268:  BRA    1450
....................                //-------- ENTER 
....................                case 0x5A : 
....................                   shift = 0; 
0126A:  CLRF   x72
....................                   EnterFlag=true; 
0126C:  BSF    21.2
....................                   tecla='#'; 
0126E:  MOVLW  23
01270:  MOVWF  22
....................                   putc ('*');  
01272:  MOVLW  2A
01274:  MOVWF  xA2
01276:  RCALL  11F6
....................                   
....................                   //printf(lcd_putc_4bits,"\n"); 
....................                   break; 
01278:  BRA    1450
....................               case 0x66: 
....................                shift = 0; //Borrado 
0127A:  CLRF   x72
....................                tecla = 'D'; 
0127C:  MOVLW  44
0127E:  MOVWF  22
....................                break; 
01280:  BRA    1450
....................                case 0x76: //ESSC 
....................                shift = 0; //Borrado 
01282:  CLRF   x72
....................                tecla = '*'; 
01284:  MOVLW  2A
01286:  MOVWF  22
....................                break; 
01288:  BRA    1450
....................                  //-------- Borrado 
....................                //-------- Si no es ninguno de los identificadores especiales, procesar 
....................                //-------- pulsacin, localizando caracter en tabla de caracteres. 
....................                default: 
....................                   //-------- Pulsacfin normal 
....................                   if(!shift) 
0128A:  MOVF   x72,F
0128C:  BTFSS  FD8.2
0128E:  BRA    1376
....................                      { 
....................                         for(i = 0; unshifted[i][0]!=sc && unshifted[i][0]; i++); 
01290:  CLRF   xA0
01292:  BCF    FD8.0
01294:  RLCF   xA0,W
01296:  CLRF   xA2
01298:  MOVWF  xA1
0129A:  MOVFF  A2,03
0129E:  MOVF   xA1,W
012A0:  RCALL  10BE
012A2:  SUBWF  x9F,W
012A4:  BZ    12C0
012A6:  BCF    FD8.0
012A8:  RLCF   xA0,W
012AA:  CLRF   xA4
012AC:  MOVWF  xA3
012AE:  MOVFF  A4,03
012B2:  MOVF   xA3,W
012B4:  RCALL  10BE
012B6:  MOVWF  01
012B8:  MOVF   01,F
012BA:  BZ    12C0
012BC:  INCF   xA0,F
012BE:  BRA    1292
....................                        
....................                          if(unshifted[i][0] == sc && sc==0x66){ 
012C0:  BCF    FD8.0
012C2:  RLCF   xA0,W
012C4:  CLRF   xA2
012C6:  MOVWF  xA1
012C8:  MOVFF  A2,03
012CC:  MOVF   xA1,W
012CE:  RCALL  10BE
012D0:  SUBWF  x9F,W
012D2:  BNZ   12FC
012D4:  MOVF   x9F,W
012D6:  SUBLW  66
012D8:  BNZ   12FC
....................                          --x; 
012DA:  DECF   46,F
....................                          tecla=unshifted[i][1]; 
012DC:  BCF    FD8.0
012DE:  RLCF   xA0,W
012E0:  CLRF   xA2
012E2:  MOVWF  xA1
012E4:  MOVLW  01
012E6:  ADDWF  xA1,W
012E8:  MOVWF  01
012EA:  MOVLW  00
012EC:  ADDWFC xA2,W
012EE:  MOVWF  03
012F0:  MOVF   01,W
012F2:  RCALL  10BE
012F4:  MOVWF  22
....................                          //lcd_ubicaxy_4bits(x,1); 
....................                         // lcd_putc_4bits(unshifted[i][1]); 
....................                          putc('#'); 
012F6:  MOVLW  23
012F8:  MOVWF  xA2
012FA:  RCALL  11F6
....................                          } 
....................                           
....................                             if (unshifted[i][0] == sc && sc!=0x66) 
012FC:  BCF    FD8.0
012FE:  RLCF   xA0,W
01300:  CLRF   xA2
01302:  MOVWF  xA1
01304:  MOVFF  A2,03
01308:  MOVF   xA1,W
0130A:  RCALL  10BE
0130C:  SUBWF  x9F,W
0130E:  BNZ   1354
01310:  MOVF   x9F,W
01312:  SUBLW  66
01314:  BZ    1354
....................                            { 
....................                            /* if (x<16)lcd_ubicaxy_4bits(x,1); 
....................                             else 
....................                             lcd_ubicaxy_4bits(x-16,2); 
....................                            */  
....................                              
....................                              
....................                             //lcd_putc_4bits(unshifted[i][1]); 
....................                             tecla=unshifted[i][1]; 
01316:  BCF    FD8.0
01318:  RLCF   xA0,W
0131A:  CLRF   xA2
0131C:  MOVWF  xA1
0131E:  MOVLW  01
01320:  ADDWF  xA1,W
01322:  MOVWF  01
01324:  MOVLW  00
01326:  ADDWFC xA2,W
01328:  MOVWF  03
0132A:  MOVF   01,W
0132C:  RCALL  10BE
0132E:  MOVWF  22
....................                             putc (mensaje[x]); 
01330:  CLRF   03
01332:  MOVF   46,W
01334:  ADDLW  4A
01336:  MOVWF  FE9
01338:  MOVLW  00
0133A:  ADDWFC 03,W
0133C:  MOVWF  FEA
0133E:  MOVFF  FEF,A1
01342:  MOVFF  A1,A2
01346:  RCALL  11F6
....................                            if ( x++==32)x=1; 
01348:  MOVF   46,W
0134A:  INCF   46,F
0134C:  SUBLW  20
0134E:  BNZ   1354
01350:  MOVLW  01
01352:  MOVWF  46
....................                             
....................                             
....................                            }   
....................                             
....................                            if (unshifted[i][0] == sc && sc==0x5b) 
01354:  BCF    FD8.0
01356:  RLCF   xA0,W
01358:  CLRF   xA2
0135A:  MOVWF  xA1
0135C:  MOVFF  A2,03
01360:  MOVF   xA1,W
01362:  RCALL  10BE
01364:  SUBWF  x9F,W
01366:  BNZ   1374
01368:  MOVF   x9F,W
0136A:  SUBLW  5B
0136C:  BNZ   1374
....................                            { 
....................                            putc('!'); 
0136E:  MOVLW  21
01370:  MOVWF  xA2
01372:  RCALL  11F6
....................                            }   
....................                             
....................                      } 
....................                   else 
01374:  BRA    144E
....................                   //-------- Pulsacin + SHIFT presionado 
....................                      { 
....................                         for(i = 0; shifted[i][0]!=sc && shifted[i][0]; i++); 
01376:  CLRF   xA0
01378:  BCF    FD8.0
0137A:  RLCF   xA0,W
0137C:  CLRF   xA2
0137E:  MOVWF  xA1
01380:  MOVFF  A2,03
01384:  MOVF   xA1,W
01386:  RCALL  115A
01388:  SUBWF  x9F,W
0138A:  BZ    13A6
0138C:  BCF    FD8.0
0138E:  RLCF   xA0,W
01390:  CLRF   xA4
01392:  MOVWF  xA3
01394:  MOVFF  A4,03
01398:  MOVF   xA3,W
0139A:  RCALL  115A
0139C:  MOVWF  01
0139E:  MOVF   01,F
013A0:  BZ    13A6
013A2:  INCF   xA0,F
013A4:  BRA    1378
....................                         if (shifted[i][0] == sc) 
013A6:  BCF    FD8.0
013A8:  RLCF   xA0,W
013AA:  CLRF   xA2
013AC:  MOVWF  xA1
013AE:  MOVFF  A2,03
013B2:  MOVF   xA1,W
013B4:  RCALL  115A
013B6:  SUBWF  x9F,W
013B8:  BNZ   144E
....................                            {  
....................                                
....................                          if(shifted[i][0] == sc && sc==0x66){ 
013BA:  BCF    FD8.0
013BC:  RLCF   xA0,W
013BE:  CLRF   xA2
013C0:  MOVWF  xA1
013C2:  MOVFF  A2,03
013C6:  MOVF   xA1,W
013C8:  RCALL  115A
013CA:  SUBWF  x9F,W
013CC:  BNZ   13F6
013CE:  MOVF   x9F,W
013D0:  SUBLW  66
013D2:  BNZ   13F6
....................                          --x; 
013D4:  DECF   46,F
....................                          //lcd_ubicaxy_4bits(x,1); 
....................                          //lcd_putc_4bits(); 
....................                          tecla = shifted[i][1]; 
013D6:  BCF    FD8.0
013D8:  RLCF   xA0,W
013DA:  CLRF   xA2
013DC:  MOVWF  xA1
013DE:  MOVLW  01
013E0:  ADDWF  xA1,W
013E2:  MOVWF  01
013E4:  MOVLW  00
013E6:  ADDWFC xA2,W
013E8:  MOVWF  03
013EA:  MOVF   01,W
013EC:  RCALL  115A
013EE:  MOVWF  22
....................                          putc('#'); 
013F0:  MOVLW  23
013F2:  MOVWF  xA2
013F4:  RCALL  11F6
....................                          } 
....................                                
....................                          if (shifted[i][0] == sc && sc!=0x66) {  
013F6:  BCF    FD8.0
013F8:  RLCF   xA0,W
013FA:  CLRF   xA2
013FC:  MOVWF  xA1
013FE:  MOVFF  A2,03
01402:  MOVF   xA1,W
01404:  RCALL  115A
01406:  SUBWF  x9F,W
01408:  BNZ   144E
0140A:  MOVF   x9F,W
0140C:  SUBLW  66
0140E:  BZ    144E
....................                           
....................                          //if (x<16)lcd_ubicaxy_4bits(x,1); 
....................                            // else 
....................                            // lcd_ubicaxy_4bits(x-16,2); 
....................                              
....................                          //lcd_putc_4bits(shifted[i][1]); 
....................                          tecla=shifted[i][1]; 
01410:  BCF    FD8.0
01412:  RLCF   xA0,W
01414:  CLRF   xA2
01416:  MOVWF  xA1
01418:  MOVLW  01
0141A:  ADDWF  xA1,W
0141C:  MOVWF  01
0141E:  MOVLW  00
01420:  ADDWFC xA2,W
01422:  MOVWF  03
01424:  MOVF   01,W
01426:  RCALL  115A
01428:  MOVWF  22
....................                          putc (mensaje[x]); 
0142A:  CLRF   03
0142C:  MOVF   46,W
0142E:  ADDLW  4A
01430:  MOVWF  FE9
01432:  MOVLW  00
01434:  ADDWFC 03,W
01436:  MOVWF  FEA
01438:  MOVFF  FEF,A1
0143C:  MOVFF  A1,A2
01440:  RCALL  11F6
....................                           if ( x++==32)x=1;                         } 
01442:  MOVF   46,W
01444:  INCF   46,F
01446:  SUBLW  20
01448:  BNZ   144E
0144A:  MOVLW  01
0144C:  MOVWF  46
....................                          } 
....................                      } 
....................                      break; 
0144E:  BRA    1450
....................                } // --- End Switch 
....................          } 
....................       else 
01450:  BRA    1468
....................          { 
....................          //-------- No se permiten 2 0xF0 en una fila 
....................          is_up = 0; 
01452:  CLRF   x71
....................          switch (sc) 
....................             { 
01454:  MOVF   x9F,W
01456:  XORLW  12
01458:  BZ    1460
0145A:  XORLW  4B
0145C:  BZ    1464
0145E:  BRA    1468
....................                //-------- SHIFT Izquierdo 
....................                case 0x12 : 
....................                   shift = 0; 
01460:  CLRF   x72
....................                   break; 
01462:  BRA    1468
....................                //-------- SHIFT Derecho 
....................                case 0x59 : 
....................                   shift = 0; 
01464:  CLRF   x72
....................                   break; 
01466:  BRA    1468
....................             } // --- End Switch 
....................          } 
....................          //tecla=0; 
.................... } 
01468:  GOTO   1494 (RETURN)
....................  
....................  
....................  
.................... void imprimir_sensores(){ 
....................       //MOSTRAR VALOR DE TEMPERATURA 
....................       lcd_ubicaxy_4bits(5,1); //Cursor para la temperatura 
*
01E1E:  MOVLW  05
01E20:  MOVWF  x7E
01E22:  MOVLW  01
01E24:  MOVWF  x7F
01E26:  RCALL  17BA
....................       printf(lcd_putc_4bits,"%Lu",sensorValues[0]); 
01E28:  MOVLW  10
01E2A:  MOVWF  FE9
01E2C:  MOVFF  2C,75
01E30:  MOVFF  2B,74
01E34:  RCALL  1B1C
....................       if(sensorValues[0]<100 && sensorValues[0]>9) 
01E36:  MOVF   2C,F
01E38:  BNZ   1E52
01E3A:  MOVF   2B,W
01E3C:  SUBLW  63
01E3E:  BNC   1E52
01E40:  MOVF   2C,F
01E42:  BNZ   1E4A
01E44:  MOVF   2B,W
01E46:  SUBLW  09
01E48:  BC    1E52
....................       { 
....................          printf(lcd_putc_4bits," "); 
01E4A:  MOVLW  20
01E4C:  MOVWF  x7D
01E4E:  RCALL  1854
....................       }else if(sensorValues[0]<10)printf(lcd_putc_4bits,"  "); 
01E50:  BRA    1E68
01E52:  MOVF   2C,F
01E54:  BNZ   1E68
01E56:  MOVF   2B,W
01E58:  SUBLW  09
01E5A:  BNC   1E68
01E5C:  MOVLW  20
01E5E:  MOVWF  x7D
01E60:  RCALL  1854
01E62:  MOVLW  20
01E64:  MOVWF  x7D
01E66:  RCALL  1854
....................       
....................      //MOSTRAR VALORES DE LUZ 
....................      lcd_ubicaxy_4bits(5,2); 
01E68:  MOVLW  05
01E6A:  MOVWF  x7E
01E6C:  MOVLW  02
01E6E:  MOVWF  x7F
01E70:  RCALL  17BA
....................       printf(lcd_putc_4bits,"%Lu",sensorValues[1]); 
01E72:  MOVLW  10
01E74:  MOVWF  FE9
01E76:  MOVFF  2E,75
01E7A:  MOVFF  2D,74
01E7E:  RCALL  1B1C
....................        printf(lcd_putc_4bits," lm"); 
01E80:  MOVLW  20
01E82:  MOVWF  x7D
01E84:  RCALL  1854
01E86:  MOVLW  6C
01E88:  MOVWF  x7D
01E8A:  RCALL  1854
01E8C:  MOVLW  6D
01E8E:  MOVWF  x7D
01E90:  RCALL  1854
....................       if(sensorValues[1]<1000 && sensorValues[1]>99) 
01E92:  MOVF   2E,W
01E94:  SUBLW  03
01E96:  BNC   1EB2
01E98:  BNZ   1EA0
01E9A:  MOVF   2D,W
01E9C:  SUBLW  E7
01E9E:  BNC   1EB2
01EA0:  MOVF   2E,F
01EA2:  BNZ   1EAA
01EA4:  MOVF   2D,W
01EA6:  SUBLW  63
01EA8:  BC    1EB2
....................       { 
....................       printf(lcd_putc_4bits," "); 
01EAA:  MOVLW  20
01EAC:  MOVWF  x7D
01EAE:  RCALL  1854
....................       }else if(sensorValues[1]<100 && sensorValues[1] > 9){ 
01EB0:  BRA    1EEA
01EB2:  MOVF   2E,F
01EB4:  BNZ   1ECE
01EB6:  MOVF   2D,W
01EB8:  SUBLW  63
01EBA:  BNC   1ECE
01EBC:  MOVF   2E,F
01EBE:  BNZ   1EC6
01EC0:  MOVF   2D,W
01EC2:  SUBLW  09
01EC4:  BC    1ECE
....................        printf(lcd_putc_4bits," "); 
01EC6:  MOVLW  20
01EC8:  MOVWF  x7D
01ECA:  RCALL  1854
....................    }else if(sensorValues[1]<10)printf(lcd_putc_4bits,"   "); 
01ECC:  BRA    1EEA
01ECE:  MOVF   2E,F
01ED0:  BNZ   1EEA
01ED2:  MOVF   2D,W
01ED4:  SUBLW  09
01ED6:  BNC   1EEA
01ED8:  MOVLW  20
01EDA:  MOVWF  x7D
01EDC:  RCALL  1854
01EDE:  MOVLW  20
01EE0:  MOVWF  x7D
01EE2:  RCALL  1854
01EE4:  MOVLW  20
01EE6:  MOVWF  x7D
01EE8:  RCALL  1854
....................        
....................        //VALORES DE HUMEDAD 
....................        lcd_ubicaxy_4bits(13,1); //Cursor para la humedad 
01EEA:  MOVLW  0D
01EEC:  MOVWF  x7E
01EEE:  MOVLW  01
01EF0:  MOVWF  x7F
01EF2:  RCALL  17BA
....................        if(sensorValues[2] > 100 ) sensorValues[2] = 100; 
01EF4:  MOVF   30,F
01EF6:  BNZ   1EFE
01EF8:  MOVF   2F,W
01EFA:  SUBLW  64
01EFC:  BC    1F04
01EFE:  CLRF   30
01F00:  MOVLW  64
01F02:  MOVWF  2F
....................       printf(lcd_putc_4bits,"%Lu",sensorValues[2]); 
01F04:  MOVLW  10
01F06:  MOVWF  FE9
01F08:  MOVFF  30,75
01F0C:  MOVFF  2F,74
01F10:  RCALL  1B1C
....................       if(sensorValues[2]<100 && sensorValues[0]>9) 
01F12:  MOVF   30,F
01F14:  BNZ   1F2E
01F16:  MOVF   2F,W
01F18:  SUBLW  63
01F1A:  BNC   1F2E
01F1C:  MOVF   2C,F
01F1E:  BNZ   1F26
01F20:  MOVF   2B,W
01F22:  SUBLW  09
01F24:  BC    1F2E
....................       { 
....................          printf(lcd_putc_4bits," "); 
01F26:  MOVLW  20
01F28:  MOVWF  x7D
01F2A:  RCALL  1854
....................       }else if(sensorValues[2]<10)printf(lcd_putc_4bits,"  "); 
01F2C:  BRA    1F44
01F2E:  MOVF   30,F
01F30:  BNZ   1F44
01F32:  MOVF   2F,W
01F34:  SUBLW  09
01F36:  BNC   1F44
01F38:  MOVLW  20
01F3A:  MOVWF  x7D
01F3C:  RCALL  1854
01F3E:  MOVLW  20
01F40:  MOVWF  x7D
01F42:  RCALL  1854
.................... }//Fin del codigo 
01F44:  GOTO   27FE (RETURN)
.................... int32 rule3(int32  x, int32  in_min, int32  in_max, int32  out_min, int32  out_max) 
.................... { 
....................    return(x-in_min)*(out_max-out_min)/(in_max-in_min)+out_min; 
*
01D3E:  MOVF   x78,W
01D40:  SUBWF  x74,W
01D42:  MOVWF  x88
01D44:  MOVF   x79,W
01D46:  SUBWFB x75,W
01D48:  MOVWF  x89
01D4A:  MOVF   x7A,W
01D4C:  SUBWFB x76,W
01D4E:  MOVWF  x8A
01D50:  MOVF   x7B,W
01D52:  SUBWFB x77,W
01D54:  MOVWF  x8B
01D56:  MOVF   x80,W
01D58:  SUBWF  x84,W
01D5A:  MOVWF  00
01D5C:  MOVF   x81,W
01D5E:  SUBWFB x85,W
01D60:  MOVWF  01
01D62:  MOVF   x82,W
01D64:  SUBWFB x86,W
01D66:  MOVWF  02
01D68:  MOVF   x83,W
01D6A:  SUBWFB x87,W
01D6C:  MOVWF  03
01D6E:  MOVWF  x8F
01D70:  MOVFF  02,8E
01D74:  MOVFF  01,8D
01D78:  MOVFF  00,8C
01D7C:  MOVFF  8B,93
01D80:  MOVFF  8A,92
01D84:  MOVFF  89,91
01D88:  MOVFF  88,90
01D8C:  MOVWF  x97
01D8E:  MOVFF  02,96
01D92:  MOVFF  01,95
01D96:  MOVFF  00,94
01D9A:  BRA    1C58
01D9C:  MOVFF  03,8B
01DA0:  MOVFF  02,8A
01DA4:  MOVFF  01,89
01DA8:  MOVFF  00,88
01DAC:  MOVF   x78,W
01DAE:  SUBWF  x7C,W
01DB0:  MOVWF  00
01DB2:  MOVF   x79,W
01DB4:  SUBWFB x7D,W
01DB6:  MOVWF  01
01DB8:  MOVF   x7A,W
01DBA:  SUBWFB x7E,W
01DBC:  MOVWF  02
01DBE:  MOVF   x7B,W
01DC0:  SUBWFB x7F,W
01DC2:  MOVWF  03
01DC4:  MOVWF  x8F
01DC6:  MOVFF  02,8E
01DCA:  MOVFF  01,8D
01DCE:  MOVFF  00,8C
01DD2:  BCF    FD8.1
01DD4:  MOVFF  8B,93
01DD8:  MOVFF  8A,92
01DDC:  MOVFF  89,91
01DE0:  MOVFF  88,90
01DE4:  MOVWF  x97
01DE6:  MOVFF  02,96
01DEA:  MOVFF  01,95
01DEE:  MOVFF  00,94
01DF2:  BRA    1CAE
01DF4:  MOVFF  03,8B
01DF8:  MOVFF  02,8A
01DFC:  MOVFF  01,89
01E00:  MOVFF  00,88
01E04:  MOVF   x80,W
01E06:  ADDWF  00,W
01E08:  MOVWF  00
01E0A:  MOVF   x81,W
01E0C:  ADDWFC 01,W
01E0E:  MOVWF  01
01E10:  MOVF   x82,W
01E12:  ADDWFC 02,W
01E14:  MOVWF  02
01E16:  MOVF   x83,W
01E18:  ADDWFC 03,W
01E1A:  MOVWF  03
.................... } 
01E1C:  RETURN 0
....................  

Configuration Fuses:
   Word  1: F79A   NOWDT PLL3 NOPLLEN NOSTVREN NOXINST NODEBUG NOCPUDIV NOPROTECT
   Word  2: FF3D   HSPLL SOSC_HIGH CLOCKOUT NOFCMEN NOIESO WDT32768
   Word  3: F861   DSWDTOSC_INT RTCOSC_INT NODSBOR NODSWDT DSWDT8192 NOIOL1WAY ADC12 MSSPMSK7
   Word  4: F980   NOWPFP NOWPCFG WPDIS WPEND LS48MHZ
