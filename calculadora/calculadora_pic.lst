CCS PCH C Compiler, Version 4.120, 26417               23-Oct.-16 23:23

               Filename: C:\Users\Michael Vargas\Documents\MICROS 1\calculadora\calculadora_pic.lst

               ROM used: 6796 bytes (5%)
                         Largest free fragment is 65528
               RAM used: 79 (2%) at main() level
                         195 (5%) worst case
               Stack:    9 worst case (4 in main + 5 for interrupts)

*
01000:  GOTO   29B8
*
01008:  MOVWF  04
0100A:  MOVFF  FD8,05
0100E:  MOVFF  FE0,06
01012:  MOVLB  0
01014:  MOVFF  FE9,0C
01018:  MOVFF  FEA,07
0101C:  MOVFF  FE1,08
01020:  MOVFF  FE2,09
01024:  MOVFF  FD9,0A
01028:  MOVFF  FDA,0B
0102C:  MOVFF  FF3,12
01030:  MOVFF  FF4,13
01034:  MOVFF  FFA,14
01038:  MOVFF  FF5,15
0103C:  MOVFF  FF6,16
01040:  MOVFF  FF7,17
01044:  MOVFF  FF8,18
01048:  MOVFF  FFB,19
0104C:  MOVFF  00,0E
01050:  MOVFF  01,0F
01054:  MOVFF  02,10
01058:  MOVFF  03,11
0105C:  BTFSS  FF2.4
0105E:  GOTO   1068
01062:  BTFSC  FF2.1
01064:  GOTO   2678
01068:  BTFSS  FF2.3
0106A:  GOTO   1074
0106E:  BTFSC  FF2.0
01070:  GOTO   2418
01074:  MOVFF  0E,00
01078:  MOVFF  0F,01
0107C:  MOVFF  10,02
01080:  MOVFF  11,03
01084:  MOVFF  0C,FE9
01088:  MOVFF  07,FEA
0108C:  BSF    07.7
0108E:  MOVFF  08,FE1
01092:  MOVFF  09,FE2
01096:  MOVFF  0A,FD9
0109A:  MOVFF  0B,FDA
0109E:  MOVFF  12,FF3
010A2:  MOVFF  13,FF4
010A6:  MOVFF  14,FFA
010AA:  MOVFF  15,FF5
010AE:  MOVFF  16,FF6
010B2:  MOVFF  17,FF7
010B6:  MOVFF  18,FF8
010BA:  MOVFF  19,FFB
010BE:  MOVF   04,W
010C0:  MOVFF  06,FE0
010C4:  MOVFF  05,FD8
010C8:  RETFIE 0
.................... #include <18F47J53.h> 
.................... //////// Standard Header file for the PIC18F47J53 device //////////////// 
.................... #device PIC18F47J53 
.................... #list 
....................  
.................... #device ADC=8 
.................... #FUSES NOWDT         //WDT disabled (enabled by SWDTEN bit)                     
.................... #FUSES PLL3          //Divide by 3 (12 MHz oscillator input)             
.................... #FUSES NOPLLEN       //PLL Disabled 
.................... #FUSES NOSTVREN      //stack overflow/underflow reset enabled                 
.................... #FUSES NOXINST       //Extended instruction set disabled             
.................... #FUSES NOCPUDIV      //No CPU system clock divide          
.................... #FUSES NOPROTECT     //Program memory is not code-protected           
.................... #FUSES HSPLL         //HS oscillator, PLL enabled, HSPLL used by USB            
.................... #FUSES SOSC_HIGH     //High Power T1OSC/SOSC circuit selected 
.................... #FUSES CLOCKOUT      //CLKO output enabled on the RA6 pin  
.................... #FUSES NOFCMEN       //Fail-Safe Clock Monitor disabled 
.................... #FUSES NOIESO        //Two-Speed Start-up disabled 
.................... #FUSES WDT32768      //Watchdog Postscaler 1:32768 
.................... #FUSES DSWDTOSC_int  //DSWDT uses INTOSC/INTRC as clock 
.................... #FUSES RTCOSC_int    //RTCC uses INTRC as clock 
.................... #FUSES NODSBOR       //Zero-Power BOR disabled in Deep Sleep 
.................... #FUSES NODSWDT       //Deep Sleep Watchdog Timer Disabled 
.................... #FUSES DSWDT8192     //Deep Sleep Watchdog Postscaler: 1:8,192 (8.5 seconds)    
.................... #FUSES NOIOL1WAY     //IOLOCK bit can be set and cleared 
.................... #FUSES ADC12         //ADC 10 or 12 Bit Select:12 - Bit ADC Enabed  
.................... #FUSES MSSPMSK7      //MSSP 7 Bit address masking 
.................... #FUSES NOWPFP        //Write Protect Program Flash Page 0 
.................... #FUSES NOWPCFG       //Write/Erase last page protect Disabled 
.................... #FUSES WPDIS         //WPFP[5:0], WPEND, and WPCFG bits ignored  
.................... #FUSES WPEND         //Start protection at page 0 
.................... #FUSES LS48MHZ       //Low Speed USB mode with 48 MHz System clock at 48 MHz USB CLKEN divide-by is set to 8  
.................... #use delay(clock=48000000) 
*
01C00:  CLRF   FEA
01C02:  MOVLW  91
01C04:  MOVWF  FE9
01C06:  MOVF   FEF,W
01C08:  BZ    1C26
01C0A:  MOVLW  0F
01C0C:  MOVWF  01
01C0E:  CLRF   00
01C10:  DECFSZ 00,F
01C12:  BRA    1C10
01C14:  DECFSZ 01,F
01C16:  BRA    1C0E
01C18:  MOVLW  8F
01C1A:  MOVWF  00
01C1C:  DECFSZ 00,F
01C1E:  BRA    1C1C
01C20:  NOP   
01C22:  DECFSZ FEF,F
01C24:  BRA    1C0A
01C26:  RETURN 0
.................... #pin_select U2TX=PIN_D2 //Selecciona hardware UART2 
.................... #pin_select U2RX=PIN_D3 //Selecciona hardware UART2 
.................... #define LOADER_END   0xFFF                         
.................... #build(reset=LOADER_END+1, interrupt=LOADER_END+9)   //Protege posiciones de memoria desde la 0x0000 hasta la 0x1000    
.................... #org 0, LOADER_END {} 
.................... #bit PLLEN = 0xf9b.6 
.................... #use  rs232(baud=9600,parity=N,UART1,bits=8,timeout=30) 
....................  
.................... /********************************************************/ 
.................... /*------- Espacio para declaracion de constantes  ------*/ 
.................... /********************************************************/ 
.................... #define d_unidad  PIN_E1   // Pin seleccionado para el control del 7segmento Unidad 
.................... #define d_decena  PIN_E2   // Pin seleccionado para el control del 7segmento Decena 
.................... #define d_centena PIN_E0      // Pin seleccionado para el control del 7segmento Centena 
.................... #define d_umil    PIN_A5   // Pin seleccionado para el control del 7segmento Unidad de Mil 
.................... /********************************************************/ 
.................... /*--- Espacio para declaracion de variables globales  --*/ 
.................... /********************************************************/ 
.................... unsigned int16 i=0; 
.................... //Declaracion de caracteristicas del circuito de displays 7 segmentos 
.................... #define NUM_DISPLAYS 4 
.................... #define CATODO_COMUN 0x01 
.................... #define ANODO_COMUN 0x00 
.................... #define NPN 0x01 
.................... #define PNP 0x00 
.................... #define output_Displays(x) output_d(x) 
.................... #define TIME_MUX 1000 // tiempo de multiplexacion en microsegundos 
....................  
....................      //Tipos de displays   //tipo de transistores 
.................... int1 D7Seg= ANODO_COMUN , Q = PNP; 
....................  const unsigned int16 transistorPins[NUM_DISPLAYS]={d_unidad,d_decena,d_centena,d_umil}; 
.................... const unsigned char Tabla7seg[10]= 
.................... { // HGFEDCBA <-- Segmento 
....................    0b00111111, // 0 
....................    0b00000110, // 1 
....................    0b01011011, // 2 
....................    0b01001111, // 3 
....................    0b01100110, // 4 
....................    0b01101101, // 5 
....................    0b01111101, // 6 
....................    0b00000111, // 7 
....................    0b01111111, // 8 
....................    0b01100111  // 9 
.................... }; 
....................    
.................... /********************************************************/ 
.................... /********************************************************/ 
.................... /*-------------- Espacio para funciones  ---------------*/ 
.................... /********************************************************/ 
.................... #INCLUDE <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
*
01888:  BCF    xAE.0
....................    y = x; 
0188A:  MOVFF  A2,A7
0188E:  MOVFF  A1,A6
01892:  MOVFF  A0,A5
01896:  MOVFF  9F,A4
....................  
....................    if (x < 0) 
0189A:  MOVFF  A2,B2
0189E:  MOVFF  A1,B1
018A2:  MOVFF  A0,B0
018A6:  MOVFF  9F,AF
018AA:  CLRF   xB6
018AC:  CLRF   xB5
018AE:  CLRF   xB4
018B0:  CLRF   xB3
018B2:  RCALL  11EC
018B4:  BNC   18BE
....................    { 
....................       s = 1; 
018B6:  BSF    xAE.0
....................       y = -y; 
018B8:  MOVF   xA5,W
018BA:  XORLW  80
018BC:  MOVWF  xA5
....................    } 
....................  
....................    if (y <= 32768.0) 
018BE:  MOVFF  A7,B2
018C2:  MOVFF  A6,B1
018C6:  MOVFF  A5,B0
018CA:  MOVFF  A4,AF
018CE:  CLRF   xB6
018D0:  CLRF   xB5
018D2:  CLRF   xB4
018D4:  MOVLW  8E
018D6:  MOVWF  xB3
018D8:  RCALL  11EC
018DA:  BC    18DE
018DC:  BNZ   190C
....................       res = (float32)(unsigned int16)y; 
018DE:  MOVFF  A7,B2
018E2:  MOVFF  A6,B1
018E6:  MOVFF  A5,B0
018EA:  MOVFF  A4,AF
018EE:  RCALL  1432
018F0:  MOVFF  02,B4
018F4:  MOVFF  01,B3
018F8:  RCALL  115E
018FA:  MOVFF  03,AB
018FE:  MOVFF  02,AA
01902:  MOVFF  01,A9
01906:  MOVFF  00,A8
....................  
....................  else if (y < 10000000.0) 
0190A:  BRA    1A8C
0190C:  MOVFF  A7,B2
01910:  MOVFF  A6,B1
01914:  MOVFF  A5,B0
01918:  MOVFF  A4,AF
0191C:  MOVLW  80
0191E:  MOVWF  xB6
01920:  MOVLW  96
01922:  MOVWF  xB5
01924:  MOVLW  18
01926:  MOVWF  xB4
01928:  MOVLW  96
0192A:  MOVWF  xB3
0192C:  RCALL  11EC
0192E:  BTFSS  FD8.0
01930:  BRA    1A7C
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
01932:  MOVFF  A7,B2
01936:  MOVFF  A6,B1
0193A:  MOVFF  A5,B0
0193E:  MOVFF  A4,AF
01942:  CLRF   xB6
01944:  CLRF   xB5
01946:  CLRF   xB4
01948:  MOVLW  70
0194A:  MOVWF  xB3
0194C:  RCALL  1340
0194E:  MOVFF  03,B2
01952:  MOVFF  02,B1
01956:  MOVFF  01,B0
0195A:  MOVFF  00,AF
0195E:  RCALL  1432
01960:  MOVFF  02,AD
01964:  MOVFF  01,AC
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
01968:  MOVFF  A7,B2
0196C:  MOVFF  A6,B1
01970:  MOVFF  A5,B0
01974:  MOVFF  A4,AF
01978:  CLRF   xB6
0197A:  CLRF   xB5
0197C:  CLRF   xB4
0197E:  MOVLW  70
01980:  MOVWF  xB3
01982:  RCALL  1340
01984:  MOVFF  00,AF
01988:  MOVFF  01,B0
0198C:  MOVFF  02,B1
01990:  MOVFF  03,B2
01994:  MOVFF  AD,B4
01998:  MOVFF  AC,B3
0199C:  CALL   115E
019A0:  BSF    FD8.1
019A2:  MOVFF  B2,B6
019A6:  MOVFF  B1,B5
019AA:  MOVFF  B0,B4
019AE:  MOVFF  AF,B3
019B2:  MOVFF  03,BA
019B6:  MOVFF  02,B9
019BA:  MOVFF  01,B8
019BE:  MOVFF  00,B7
019C2:  RCALL  161E
019C4:  CLRF   xB2
019C6:  CLRF   xB1
019C8:  CLRF   xB0
019CA:  MOVLW  8E
019CC:  MOVWF  xAF
019CE:  MOVFF  03,B6
019D2:  MOVFF  02,B5
019D6:  MOVFF  01,B4
019DA:  MOVFF  00,B3
019DE:  RCALL  1340
019E0:  MOVFF  03,A7
019E4:  MOVFF  02,A6
019E8:  MOVFF  01,A5
019EC:  MOVFF  00,A4
....................       res = 32768.0*(float32)l; 
019F0:  MOVFF  AD,B4
019F4:  MOVFF  AC,B3
019F8:  CALL   115E
019FC:  CLRF   xB2
019FE:  CLRF   xB1
01A00:  CLRF   xB0
01A02:  MOVLW  8E
01A04:  MOVWF  xAF
01A06:  MOVFF  03,B6
01A0A:  MOVFF  02,B5
01A0E:  MOVFF  01,B4
01A12:  MOVFF  00,B3
01A16:  RCALL  1340
01A18:  MOVFF  03,AB
01A1C:  MOVFF  02,AA
01A20:  MOVFF  01,A9
01A24:  MOVFF  00,A8
....................       res += (float32)(unsigned int16)y; 
01A28:  MOVFF  A7,B2
01A2C:  MOVFF  A6,B1
01A30:  MOVFF  A5,B0
01A34:  MOVFF  A4,AF
01A38:  RCALL  1432
01A3A:  MOVFF  02,B4
01A3E:  MOVFF  01,B3
01A42:  CALL   115E
01A46:  BCF    FD8.1
01A48:  MOVFF  AB,B6
01A4C:  MOVFF  AA,B5
01A50:  MOVFF  A9,B4
01A54:  MOVFF  A8,B3
01A58:  MOVFF  03,BA
01A5C:  MOVFF  02,B9
01A60:  MOVFF  01,B8
01A64:  MOVFF  00,B7
01A68:  RCALL  161E
01A6A:  MOVFF  03,AB
01A6E:  MOVFF  02,AA
01A72:  MOVFF  01,A9
01A76:  MOVFF  00,A8
....................    } 
....................  
....................  else 
01A7A:  BRA    1A8C
....................   res = y; 
01A7C:  MOVFF  A7,AB
01A80:  MOVFF  A6,AA
01A84:  MOVFF  A5,A9
01A88:  MOVFF  A4,A8
....................  
....................  y = y - (float32)(unsigned int16)y; 
01A8C:  MOVFF  A7,B2
01A90:  MOVFF  A6,B1
01A94:  MOVFF  A5,B0
01A98:  MOVFF  A4,AF
01A9C:  RCALL  1432
01A9E:  MOVFF  02,B4
01AA2:  MOVFF  01,B3
01AA6:  CALL   115E
01AAA:  BSF    FD8.1
01AAC:  MOVFF  A7,B6
01AB0:  MOVFF  A6,B5
01AB4:  MOVFF  A5,B4
01AB8:  MOVFF  A4,B3
01ABC:  MOVFF  03,BA
01AC0:  MOVFF  02,B9
01AC4:  MOVFF  01,B8
01AC8:  MOVFF  00,B7
01ACC:  RCALL  161E
01ACE:  MOVFF  03,A7
01AD2:  MOVFF  02,A6
01AD6:  MOVFF  01,A5
01ADA:  MOVFF  00,A4
....................  
....................  if (s) 
01ADE:  BTFSS  xAE.0
01AE0:  BRA    1AE8
....................   res = -res; 
01AE2:  MOVF   xA9,W
01AE4:  XORLW  80
01AE6:  MOVWF  xA9
....................  
....................  if (y != 0) 
01AE8:  MOVFF  A7,B2
01AEC:  MOVFF  A6,B1
01AF0:  MOVFF  A5,B0
01AF4:  MOVFF  A4,AF
01AF8:  CLRF   xB6
01AFA:  CLRF   xB5
01AFC:  CLRF   xB4
01AFE:  CLRF   xB3
01B00:  CALL   11EC
01B04:  BZ    1B72
....................  { 
....................   if (s == 1 && n == 0) 
01B06:  BTFSS  xAE.0
01B08:  BRA    1B3C
01B0A:  MOVF   xA3,F
01B0C:  BNZ   1B3C
....................    res -= 1.0; 
01B0E:  BSF    FD8.1
01B10:  MOVFF  AB,B6
01B14:  MOVFF  AA,B5
01B18:  MOVFF  A9,B4
01B1C:  MOVFF  A8,B3
01B20:  CLRF   xBA
01B22:  CLRF   xB9
01B24:  CLRF   xB8
01B26:  MOVLW  7F
01B28:  MOVWF  xB7
01B2A:  RCALL  161E
01B2C:  MOVFF  03,AB
01B30:  MOVFF  02,AA
01B34:  MOVFF  01,A9
01B38:  MOVFF  00,A8
....................  
....................   if (s == 0 && n == 1) 
01B3C:  BTFSC  xAE.0
01B3E:  BRA    1B72
01B40:  DECFSZ xA3,W
01B42:  BRA    1B72
....................    res += 1.0; 
01B44:  BCF    FD8.1
01B46:  MOVFF  AB,B6
01B4A:  MOVFF  AA,B5
01B4E:  MOVFF  A9,B4
01B52:  MOVFF  A8,B3
01B56:  CLRF   xBA
01B58:  CLRF   xB9
01B5A:  CLRF   xB8
01B5C:  MOVLW  7F
01B5E:  MOVWF  xB7
01B60:  RCALL  161E
01B62:  MOVFF  03,AB
01B66:  MOVFF  02,AA
01B6A:  MOVFF  01,A9
01B6E:  MOVFF  00,A8
....................  } 
....................  if (x == 0) 
01B72:  MOVFF  A2,B2
01B76:  MOVFF  A1,B1
01B7A:  MOVFF  A0,B0
01B7E:  MOVFF  9F,AF
01B82:  CLRF   xB6
01B84:  CLRF   xB5
01B86:  CLRF   xB4
01B88:  CLRF   xB3
01B8A:  CALL   11EC
01B8E:  BNZ   1B98
....................     res = 0; 
01B90:  CLRF   xAB
01B92:  CLRF   xAA
01B94:  CLRF   xA9
01B96:  CLRF   xA8
....................  
....................  return (res); 
01B98:  MOVFF  A8,00
01B9C:  MOVFF  A9,01
01BA0:  MOVFF  AA,02
01BA4:  MOVFF  AB,03
.................... } 
01BA8:  RETURN 0
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
01BAA:  MOVFF  9E,A2
01BAE:  MOVFF  9D,A1
01BB2:  MOVFF  9C,A0
01BB6:  MOVFF  9B,9F
01BBA:  MOVLW  01
01BBC:  MOVWF  xA3
01BBE:  RCALL  1888
.................... } 
01BC0:  RETURN 0
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #INCLUDE <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... float num,x,y; 
.................... void displayMux(float numero,unsigned int16 time,char precision=0);    
.................... unsigned int16 umil,cent,dec,unid; 
.................... int8 prec= 0; 
.................... #INT_RB 
.................... void interrupcion_RB (void){ 
....................  if( !input_state(PIN_B7)){ 
*
02418:  BTFSC  F81.7
0241A:  BRA    2432
....................     ++unid; 
0241C:  INCF   38,F
0241E:  BTFSC  FD8.2
02420:  INCF   39,F
....................     if(unid==10)unid=0; 
02422:  MOVF   38,W
02424:  SUBLW  0A
02426:  BNZ   2430
02428:  MOVF   39,F
0242A:  BNZ   2430
0242C:  CLRF   39
0242E:  CLRF   38
....................     } 
....................     else if(!input_state(PIN_B6) ){  
02430:  BRA    247E
02432:  BTFSC  F81.6
02434:  BRA    244C
....................     ++dec; 
02436:  INCF   36,F
02438:  BTFSC  FD8.2
0243A:  INCF   37,F
....................      if(dec==10)dec=0; 
0243C:  MOVF   36,W
0243E:  SUBLW  0A
02440:  BNZ   244A
02442:  MOVF   37,F
02444:  BNZ   244A
02446:  CLRF   37
02448:  CLRF   36
....................     } 
....................     else if(!input_state(PIN_B5) ){  
0244A:  BRA    247E
0244C:  BTFSC  F81.5
0244E:  BRA    2466
....................     ++cent; 
02450:  INCF   34,F
02452:  BTFSC  FD8.2
02454:  INCF   35,F
....................     if(cent==10)cent=0; 
02456:  MOVF   34,W
02458:  SUBLW  0A
0245A:  BNZ   2464
0245C:  MOVF   35,F
0245E:  BNZ   2464
02460:  CLRF   35
02462:  CLRF   34
....................     } 
....................     else if(!input_state(PIN_B4) ){ 
02464:  BRA    247E
02466:  BTFSC  F81.4
02468:  BRA    247E
....................     ++umil; 
0246A:  INCF   32,F
0246C:  BTFSC  FD8.2
0246E:  INCF   33,F
....................     if(umil==10)umil=0; 
02470:  MOVF   32,W
02472:  SUBLW  0A
02474:  BNZ   247E
02476:  MOVF   33,F
02478:  BNZ   247E
0247A:  CLRF   33
0247C:  CLRF   32
....................     } 
....................    num = (float) (umil*1000 + cent*100 + dec*10 + unid); 
0247E:  MOVFF  33,8B
02482:  MOVFF  32,8A
02486:  MOVLW  03
02488:  MOVWF  x8D
0248A:  MOVLW  E8
0248C:  MOVWF  x8C
0248E:  CALL   1140
02492:  MOVFF  02,89
02496:  MOVFF  01,88
0249A:  MOVFF  35,8B
0249E:  MOVFF  34,8A
024A2:  CLRF   x8D
024A4:  MOVLW  64
024A6:  MOVWF  x8C
024A8:  CALL   1140
024AC:  MOVFF  02,03
024B0:  MOVF   01,W
024B2:  ADDWF  x88,F
024B4:  MOVF   02,W
024B6:  ADDWFC x89,F
024B8:  MOVFF  37,8B
024BC:  MOVFF  36,8A
024C0:  CLRF   x8D
024C2:  MOVLW  0A
024C4:  MOVWF  x8C
024C6:  CALL   1140
024CA:  MOVF   01,W
024CC:  ADDWF  x88,F
024CE:  MOVF   02,W
024D0:  ADDWFC x89,F
024D2:  MOVF   38,W
024D4:  ADDWF  x88,W
024D6:  MOVWF  01
024D8:  MOVF   39,W
024DA:  ADDWFC x89,W
024DC:  MOVWF  03
024DE:  MOVFF  01,B3
024E2:  MOVWF  xB4
024E4:  CALL   115E
024E8:  MOVFF  03,29
024EC:  MOVFF  02,28
024F0:  MOVFF  01,27
024F4:  MOVFF  00,26
....................    displayMux(num,40,prec);  
024F8:  MOVFF  29,8D
024FC:  MOVFF  28,8C
02500:  MOVFF  27,8B
02504:  MOVFF  26,8A
02508:  CLRF   x8F
0250A:  MOVLW  28
0250C:  MOVWF  x8E
0250E:  MOVFF  3A,90
02512:  CALL   1C28
.................... } 
02516:  BCF    FF2.0
02518:  GOTO   1074
.................... unsigned int8 h; 
.................... #INT_EXT 
....................  void interrupcion_INT0 (void){ 
....................      if(!input(PIN_B0)){ 
*
02678:  BSF    F93.0
0267A:  BTFSC  F81.0
0267C:  BRA    2966
....................      h++; 
0267E:  INCF   3B,F
....................       switch(h){ 
02680:  MOVLW  01
02682:  SUBWF  3B,W
02684:  ADDLW  F9
02686:  BTFSC  FD8.0
02688:  BRA    2966
0268A:  ADDLW  07
0268C:  GOTO   298A
....................       case 1: 
....................                x = num; 
02690:  MOVFF  29,2D
02694:  MOVFF  28,2C
02698:  MOVFF  27,2B
0269C:  MOVFF  26,2A
....................                umil = cent = dec = unid = num = 0; 
026A0:  CLRF   29
026A2:  CLRF   28
026A4:  CLRF   27
026A6:  CLRF   26
026A8:  MOVFF  29,B2
026AC:  MOVFF  28,B1
026B0:  MOVFF  27,B0
026B4:  MOVFF  26,AF
026B8:  CALL   1432
026BC:  MOVFF  02,39
026C0:  MOVFF  01,38
026C4:  MOVFF  39,37
026C8:  MOVFF  38,36
026CC:  MOVFF  37,35
026D0:  MOVFF  36,34
026D4:  MOVFF  35,33
026D8:  MOVFF  34,32
....................                break; 
026DC:  BRA    2966
....................       case 2: 
....................                y = num; 
026DE:  MOVFF  29,31
026E2:  MOVFF  28,30
026E6:  MOVFF  27,2F
026EA:  MOVFF  26,2E
....................                num = 10e+3; 
026EE:  CLRF   29
026F0:  MOVLW  40
026F2:  MOVWF  28
026F4:  MOVLW  1C
026F6:  MOVWF  27
026F8:  MOVLW  8C
026FA:  MOVWF  26
....................                break; 
026FC:  BRA    2966
....................       case 3:  
....................                num = x +y ; 
026FE:  BCF    FD8.1
02700:  MOVFF  2D,B6
02704:  MOVFF  2C,B5
02708:  MOVFF  2B,B4
0270C:  MOVFF  2A,B3
02710:  MOVFF  31,BA
02714:  MOVFF  30,B9
02718:  MOVFF  2F,B8
0271C:  MOVFF  2E,B7
02720:  CALL   161E
02724:  MOVFF  03,29
02728:  MOVFF  02,28
0272C:  MOVFF  01,27
02730:  MOVFF  00,26
....................                break; 
02734:  BRA    2966
....................       case 4:  
....................                num = x  -y ; 
02736:  BSF    FD8.1
02738:  MOVFF  2D,B6
0273C:  MOVFF  2C,B5
02740:  MOVFF  2B,B4
02744:  MOVFF  2A,B3
02748:  MOVFF  31,BA
0274C:  MOVFF  30,B9
02750:  MOVFF  2F,B8
02754:  MOVFF  2E,B7
02758:  CALL   161E
0275C:  MOVFF  03,29
02760:  MOVFF  02,28
02764:  MOVFF  01,27
02768:  MOVFF  00,26
....................                break; 
0276C:  BRA    2966
....................       case 5:  
....................                num = x /y ; 
0276E:  MOVFF  2D,8D
02772:  MOVFF  2C,8C
02776:  MOVFF  2B,8B
0277A:  MOVFF  2A,8A
0277E:  MOVFF  31,91
02782:  MOVFF  30,90
02786:  MOVFF  2F,8F
0278A:  MOVFF  2E,8E
0278E:  BRA    251C
02790:  MOVFF  03,29
02794:  MOVFF  02,28
02798:  MOVFF  01,27
0279C:  MOVFF  00,26
....................                if(y == 0) num = 10e+3; 
027A0:  MOVFF  31,B2
027A4:  MOVFF  30,B1
027A8:  MOVFF  2F,B0
027AC:  MOVFF  2E,AF
027B0:  CLRF   xB6
027B2:  CLRF   xB5
027B4:  CLRF   xB4
027B6:  CLRF   xB3
027B8:  CALL   11EC
027BC:  BNZ   27CC
027BE:  CLRF   29
027C0:  MOVLW  40
027C2:  MOVWF  28
027C4:  MOVLW  1C
027C6:  MOVWF  27
027C8:  MOVLW  8C
027CA:  MOVWF  26
....................                int16 aux =ceil(num); 
027CC:  MOVFF  29,9E
027D0:  MOVFF  28,9D
027D4:  MOVFF  27,9C
027D8:  MOVFF  26,9B
027DC:  CALL   1BAA
027E0:  MOVFF  03,B2
027E4:  MOVFF  02,B1
027E8:  MOVFF  01,B0
027EC:  MOVFF  00,AF
027F0:  CALL   1432
027F4:  MOVFF  02,89
027F8:  MOVFF  01,88
....................                if(fabs(num - aux) >= num * 1e-6){ 
027FC:  MOVFF  89,B4
02800:  MOVFF  88,B3
02804:  CALL   115E
02808:  BSF    FD8.1
0280A:  MOVFF  29,B6
0280E:  MOVFF  28,B5
02812:  MOVFF  27,B4
02816:  MOVFF  26,B3
0281A:  MOVFF  03,BA
0281E:  MOVFF  02,B9
02822:  MOVFF  01,B8
02826:  MOVFF  00,B7
0282A:  CALL   161E
0282E:  MOVFF  00,8A
02832:  MOVFF  01,8B
02836:  MOVFF  02,8C
0283A:  MOVFF  03,8D
0283E:  MOVFF  00,00
02842:  MOVFF  01,01
02846:  MOVFF  02,02
0284A:  MOVFF  03,03
0284E:  BCF    01.7
02850:  MOVFF  00,8A
02854:  MOVFF  01,8B
02858:  MOVFF  02,8C
0285C:  MOVFF  03,8D
02860:  MOVFF  29,B2
02864:  MOVFF  28,B1
02868:  MOVFF  27,B0
0286C:  MOVFF  26,AF
02870:  MOVLW  BD
02872:  MOVWF  xB6
02874:  MOVLW  37
02876:  MOVWF  xB5
02878:  MOVLW  06
0287A:  MOVWF  xB4
0287C:  MOVLW  6B
0287E:  MOVWF  xB3
02880:  CALL   1340
02884:  MOVFF  03,B2
02888:  MOVFF  02,B1
0288C:  MOVFF  01,B0
02890:  MOVFF  00,AF
02894:  MOVFF  8D,B6
02898:  MOVFF  8C,B5
0289C:  MOVFF  8B,B4
028A0:  MOVFF  8A,B3
028A4:  CALL   11EC
028A8:  BC    28AC
028AA:  BNZ   28DA
....................                prec = 1; 
028AC:  MOVLW  01
028AE:  MOVWF  3A
....................                if(num < 0.1) prec = 3; 
028B0:  MOVFF  29,B2
028B4:  MOVFF  28,B1
028B8:  MOVFF  27,B0
028BC:  MOVFF  26,AF
028C0:  MOVLW  CD
028C2:  MOVWF  xB6
028C4:  MOVLW  CC
028C6:  MOVWF  xB5
028C8:  MOVLW  4C
028CA:  MOVWF  xB4
028CC:  MOVLW  7B
028CE:  MOVWF  xB3
028D0:  CALL   11EC
028D4:  BNC   28DA
028D6:  MOVLW  03
028D8:  MOVWF  3A
....................                } 
....................                break; 
028DA:  BRA    2966
....................      case 6:  
....................                prec = 0; 
028DC:  CLRF   3A
....................                num = x *y ; 
028DE:  MOVFF  2D,B2
028E2:  MOVFF  2C,B1
028E6:  MOVFF  2B,B0
028EA:  MOVFF  2A,AF
028EE:  MOVFF  31,B6
028F2:  MOVFF  30,B5
028F6:  MOVFF  2F,B4
028FA:  MOVFF  2E,B3
028FE:  CALL   1340
02902:  MOVFF  03,29
02906:  MOVFF  02,28
0290A:  MOVFF  01,27
0290E:  MOVFF  00,26
....................                break; 
02912:  BRA    2966
....................      case 7:         
....................                umil = cent = dec = unid = num = h = 0; 
02914:  CLRF   3B
02916:  CLRF   xB4
02918:  MOVFF  3B,B3
0291C:  CALL   115E
02920:  MOVFF  03,29
02924:  MOVFF  02,28
02928:  MOVFF  01,27
0292C:  MOVFF  00,26
02930:  MOVFF  29,B2
02934:  MOVFF  28,B1
02938:  MOVFF  27,B0
0293C:  MOVFF  26,AF
02940:  CALL   1432
02944:  MOVFF  02,39
02948:  MOVFF  01,38
0294C:  MOVFF  39,37
02950:  MOVFF  38,36
02954:  MOVFF  37,35
02958:  MOVFF  36,34
0295C:  MOVFF  35,33
02960:  MOVFF  34,32
....................                break; 
02964:  BRA    2966
....................       } 
....................    
....................      } 
....................    displayMux(num,40,prec);  
02966:  MOVFF  29,8D
0296A:  MOVFF  28,8C
0296E:  MOVFF  27,8B
02972:  MOVFF  26,8A
02976:  CLRF   x8F
02978:  MOVLW  28
0297A:  MOVWF  x8E
0297C:  MOVFF  3A,90
02980:  CALL   1C28
.................... } 
....................    
.................... /******************************************************************************/ 
.................... /******************************************************************************/ 
.................... /*--------------------- Espacio de codigo principal --------------------------*/ 
.................... /******************************************************************************/  
.................... #zero_ram 
....................  
02984:  BCF    FF2.1
02986:  GOTO   1074
.................... void main() 
.................... { 
*
029B8:  CLRF   FF8
029BA:  BCF    FD0.7
029BC:  BSF    07.7
029BE:  MOVLB  E
029C0:  MOVLW  55
029C2:  MOVWF  FA7
029C4:  MOVLW  AA
029C6:  MOVWF  FA7
029C8:  BCF    xBF.0
029CA:  MOVLW  14
029CC:  MOVWF  xF7
029CE:  MOVLW  06
029D0:  MOVWF  xD3
029D2:  MOVLW  55
029D4:  MOVWF  FA7
029D6:  MOVLW  AA
029D8:  MOVWF  FA7
029DA:  BSF    xBF.0
029DC:  MOVLW  AE
029DE:  MOVWF  00
029E0:  MOVLW  0F
029E2:  MOVWF  01
029E4:  MOVLW  02
029E6:  MOVWF  FE9
029E8:  MOVLW  00
029EA:  MOVWF  FEA
029EC:  CLRF   FEE
029EE:  DECFSZ 00,F
029F0:  BRA    29EC
029F2:  DECFSZ 01,F
029F4:  BRA    29EC
029F6:  CLRF   FEA
029F8:  CLRF   FE9
029FA:  CLRF   1C
029FC:  BSF    F7E.3
029FE:  MOVLW  E1
02A00:  MOVWF  FB0
02A02:  MOVLW  04
02A04:  MOVWF  F7F
02A06:  MOVLW  A6
02A08:  MOVWF  FAD
02A0A:  MOVLW  90
02A0C:  MOVWF  FAC
02A0E:  CLRF   1E
02A10:  CLRF   1D
02A12:  BCF    1F.0
02A14:  BCF    1F.1
02A16:  CLRF   3A
02A18:  CLRF   41
02A1A:  CLRF   48
02A1C:  CLRF   47
02A1E:  CLRF   4A
02A20:  CLRF   49
02A22:  CLRF   4E
02A24:  CLRF   4D
02A26:  BCF    1F.2
02A28:  BCF    1F.3
02A2A:  MOVLB  1
02A2C:  CLRF   x88
02A2E:  MOVLW  FF
02A30:  MOVLB  F
02A32:  MOVWF  x48
02A34:  BCF    FC2.6
02A36:  BCF    FC2.7
02A38:  MOVF   x49,W
02A3A:  ANDLW  E0
02A3C:  IORLW  1F
02A3E:  MOVWF  x49
02A40:  CLRF   x25
02A42:  CLRF   FD1
02A44:  CLRF   FD2
02A46:  CLRF   20
02A48:  CLRF   21
....................    PLLEN = 1;          //Habilita PLL para generar 48MHz de oscilador*/\ 
02A4A:  BSF    F9B.6
....................    set_tris_d (0) ; 
02A4C:  MOVLW  00
02A4E:  MOVWF  F95
....................    enable_interrupts(GLOBAL); 
02A50:  MOVLW  C0
02A52:  IORWF  FF2,F
....................    enable_interrupts(INT_RB); 
02A54:  BSF    FF2.3
02A56:  MOVLW  FF
02A58:  IORWF  F7A,F
....................    ext_int_edge( 0, H_TO_L); 
02A5A:  BCF    FF1.6
....................    enable_interrupts(INT_EXT); 
02A5C:  BSF    FF2.4
02A5E:  CLRF   1B
02A60:  BTFSC  FF2.7
02A62:  BSF    1B.7
02A64:  BCF    FF2.7
....................    for(;;) 
....................    { 
....................      displayMux (num,4,prec) ; 
02A66:  MOVFF  29,8D
02A6A:  MOVFF  28,8C
02A6E:  MOVFF  27,8B
02A72:  MOVFF  26,8A
02A76:  MOVLB  0
02A78:  CLRF   x8F
02A7A:  MOVLW  04
02A7C:  MOVWF  x8E
02A7E:  MOVFF  3A,90
02A82:  CALL   1C28
02A86:  BTFSC  1B.7
02A88:  BSF    FF2.7
....................    } 
02A8A:  MOVLB  F
02A8C:  BRA    2A5E
.................... }//end main 
.................... void displayMux(float numero,unsigned int16 time,char precision=0) 
.................... { 
02A8E:  SLEEP 
....................   disable_interrupts(INT_RB); 
*
01C28:  CLRF   F7A
....................   //Crea variables estaticas dentro de la funcin para evitar conflictos con el cdigo del menu principal 
....................    static unsigned char digito[NUM_DISPLAYS]; 
....................    static unsigned int size, max = 0,size2; 
....................    static signed int32 temp; 
....................    static int16 i = 0, j = 0, decimal, dec = 0; 
....................    static int1 signo = 0, limit = 0; 
....................    static const unsigned int32 powersOf10[]  = 
....................    { 
....................       1, // 10 ^ 0 
....................       10, 
....................       100, 
....................       1000, 
....................       10000, 
....................       100000, 
....................       1000000, 
....................       10000000, 
....................       100000000, 
....................       1000000000 
....................    }; // 10 ^ 9 
....................    memset(digito, 0, NUM_DISPLAYS);//Borra los digitos anteriores 
01C2A:  CLRF   FEA
01C2C:  MOVLW  3C
01C2E:  MOVWF  FE9
01C30:  CLRF   x91
01C32:  CLRF   x93
01C34:  MOVLW  04
01C36:  MOVWF  x92
01C38:  CALL   1194
....................   temp = numero; //Separa la parte entera 
01C3C:  MOVFF  8D,94
01C40:  MOVFF  8C,93
01C44:  MOVFF  8B,92
01C48:  MOVFF  8A,91
01C4C:  CALL   11AE
01C50:  MOVFF  03,46
01C54:  MOVFF  02,45
01C58:  MOVFF  01,44
01C5C:  MOVFF  00,43
....................    if (numero < 0) 
01C60:  MOVFF  8D,B2
01C64:  MOVFF  8C,B1
01C68:  MOVFF  8B,B0
01C6C:  MOVFF  8A,AF
01C70:  CLRF   xB6
01C72:  CLRF   xB5
01C74:  CLRF   xB4
01C76:  CLRF   xB3
01C78:  CALL   11EC
01C7C:  BNC   1CB8
....................    { 
....................       temp = abs (numero);  
01C7E:  MOVFF  8A,00
01C82:  MOVFF  8B,01
01C86:  MOVFF  8C,02
01C8A:  MOVFF  8D,03
01C8E:  BCF    01.7
01C90:  MOVFF  8D,94
01C94:  MOVFF  8C,93
01C98:  MOVFF  01,92
01C9C:  MOVFF  8A,91
01CA0:  CALL   11AE
01CA4:  MOVFF  03,46
01CA8:  MOVFF  02,45
01CAC:  MOVFF  01,44
01CB0:  MOVFF  00,43
....................       signo = 1; //Verifica si el numero es negativo 
01CB4:  BSF    1F.2
....................       }else{ 
01CB6:  BRA    1CBA
....................       signo = 0; 
01CB8:  BCF    1F.2
....................    } 
....................    max = NUM_DISPLAYS - precision - signo; //Calcula el numero de displays maximos para terminar los rangos permitidos 
01CBA:  MOVLW  04
01CBC:  BSF    FD8.0
01CBE:  SUBFWB x90,W
01CC0:  MOVWF  x92
01CC2:  MOVLW  00
01CC4:  BTFSC  1F.2
01CC6:  MOVLW  01
01CC8:  SUBWF  x92,W
01CCA:  MOVWF  41
....................    limit = (signo) ? numero > (powersOf10[max] * - 1): numero < powersOf10[max]; // determina si el limite del numero segun los digitos ingresados 
01CCC:  BTFSS  1F.2
01CCE:  BRA    1D58
01CD0:  MOVF   41,W
01CD2:  MULLW  04
01CD4:  MOVF   FF3,W
01CD6:  CLRF   03
01CD8:  CALL   1104
01CDC:  MOVWF  00
01CDE:  TBLRD*+
01CE0:  MOVFF  FF5,01
01CE4:  TBLRD*+
01CE6:  MOVFF  FF5,02
01CEA:  TBLRD*+
01CEC:  MOVFF  FF5,03
01CF0:  MOVFF  03,94
01CF4:  MOVFF  02,93
01CF8:  MOVFF  01,92
01CFC:  MOVWF  x91
01CFE:  MOVFF  03,98
01D02:  MOVFF  02,97
01D06:  MOVFF  01,96
01D0A:  MOVWF  x95
01D0C:  SETF   x9C
01D0E:  SETF   x9B
01D10:  SETF   x9A
01D12:  SETF   x99
01D14:  CALL   1262
01D18:  MOVFF  03,94
01D1C:  MOVFF  02,93
01D20:  MOVFF  01,92
01D24:  MOVFF  00,91
01D28:  CALL   12B6
01D2C:  MOVFF  03,B2
01D30:  MOVFF  02,B1
01D34:  MOVFF  01,B0
01D38:  MOVFF  00,AF
01D3C:  MOVFF  8D,B6
01D40:  MOVFF  8C,B5
01D44:  MOVFF  8B,B4
01D48:  MOVFF  8A,B3
01D4C:  CALL   11EC
01D50:  MOVLW  00
01D52:  BTFSC  FD8.0
01D54:  MOVLW  01
01D56:  BRA    1DB4
01D58:  MOVF   41,W
01D5A:  MULLW  04
01D5C:  MOVF   FF3,W
01D5E:  CLRF   03
01D60:  CALL   1104
01D64:  MOVWF  00
01D66:  TBLRD*+
01D68:  MOVFF  FF5,01
01D6C:  TBLRD*+
01D6E:  MOVFF  FF5,02
01D72:  TBLRD*+
01D74:  MOVFF  FF5,03
01D78:  MOVFF  03,94
01D7C:  MOVFF  02,93
01D80:  MOVFF  01,92
01D84:  MOVWF  x91
01D86:  CALL   130C
01D8A:  MOVFF  8D,B2
01D8E:  MOVFF  8C,B1
01D92:  MOVFF  8B,B0
01D96:  MOVFF  8A,AF
01D9A:  MOVFF  03,B6
01D9E:  MOVFF  02,B5
01DA2:  MOVFF  01,B4
01DA6:  MOVFF  00,B3
01DAA:  CALL   11EC
01DAE:  MOVLW  00
01DB0:  BTFSC  FD8.0
01DB2:  MOVLW  01
01DB4:  BCF    1F.3
01DB6:  BTFSC  FE8.0
01DB8:  BSF    1F.3
....................    if (precision > 0)       //Separa la parte decimal siempre y se escogen la cantidad de decimales 
01DBA:  MOVF   x90,F
01DBC:  BZ    1EB8
....................    { 
....................       decimal = abs (numero * powersOf10[precision]) ; 
01DBE:  MOVF   x90,W
01DC0:  MULLW  04
01DC2:  MOVF   FF3,W
01DC4:  CLRF   03
01DC6:  CALL   1104
01DCA:  MOVWF  00
01DCC:  TBLRD*+
01DCE:  MOVFF  FF5,01
01DD2:  TBLRD*+
01DD4:  MOVFF  FF5,02
01DD8:  TBLRD*+
01DDA:  MOVFF  FF5,03
01DDE:  MOVFF  03,94
01DE2:  MOVFF  02,93
01DE6:  MOVFF  01,92
01DEA:  MOVWF  x91
01DEC:  CALL   130C
01DF0:  MOVFF  8D,B2
01DF4:  MOVFF  8C,B1
01DF8:  MOVFF  8B,B0
01DFC:  MOVFF  8A,AF
01E00:  MOVFF  03,B6
01E04:  MOVFF  02,B5
01E08:  MOVFF  01,B4
01E0C:  MOVFF  00,B3
01E10:  CALL   1340
01E14:  MOVFF  00,91
01E18:  MOVFF  01,92
01E1C:  MOVFF  02,93
01E20:  MOVFF  03,94
01E24:  MOVFF  00,00
01E28:  MOVFF  01,01
01E2C:  MOVFF  02,02
01E30:  MOVFF  03,03
01E34:  BCF    01.7
01E36:  MOVFF  03,B2
01E3A:  MOVFF  02,B1
01E3E:  MOVFF  01,B0
01E42:  MOVFF  00,AF
01E46:  CALL   1432
01E4A:  MOVFF  02,4C
01E4E:  MOVFF  01,4B
....................       decimal %= powersOf10[precision]; 
01E52:  MOVF   x90,W
01E54:  MULLW  04
01E56:  MOVF   FF3,W
01E58:  CLRF   03
01E5A:  CALL   1104
01E5E:  MOVWF  00
01E60:  TBLRD*+
01E62:  MOVFF  FF5,01
01E66:  TBLRD*+
01E68:  MOVFF  FF5,02
01E6C:  TBLRD*+
01E6E:  MOVFF  FF5,03
01E72:  MOVFF  03,94
01E76:  MOVFF  02,93
01E7A:  MOVFF  01,92
01E7E:  MOVWF  x91
01E80:  BSF    FD8.1
01E82:  CLRF   FEA
01E84:  MOVLW  95
01E86:  MOVWF  FE9
01E88:  CLRF   x9C
01E8A:  CLRF   x9B
01E8C:  MOVFF  4C,9A
01E90:  MOVFF  4B,99
01E94:  MOVFF  03,A0
01E98:  MOVFF  02,9F
01E9C:  MOVFF  01,9E
01EA0:  MOVFF  00,9D
01EA4:  CALL   146A
01EA8:  MOVFF  96,4C
01EAC:  MOVFF  95,4B
....................       dec=decimal; 
01EB0:  MOVFF  4C,4E
01EB4:  MOVFF  4B,4D
....................    } 
....................  
....................    if (limit)// condicion para calcular los digitos si el numero ingresado es menor que el posible a mostrar 
01EB8:  BTFSS  1F.3
01EBA:  BRA    2138
....................    { 
....................       size = 0; 
01EBC:  CLRF   40
....................        //Obtiene los digitos y cuenta cuantos digitos son 
....................       do{ 
....................          if (precision > 0 && size < precision)  
01EBE:  MOVF   x90,F
01EC0:  BZ    1F0E
01EC2:  MOVF   x90,W
01EC4:  SUBWF  40,W
01EC6:  BC    1F0E
....................          { 
....................            digito[size] = abs(decimal % 10); 
01EC8:  CLRF   03
01ECA:  MOVF   40,W
01ECC:  ADDLW  3C
01ECE:  MOVWF  FE9
01ED0:  MOVLW  00
01ED2:  ADDWFC 03,W
01ED4:  MOVWF  FEA
01ED6:  MOVFF  4C,94
01EDA:  MOVFF  4B,93
01EDE:  CLRF   x96
01EE0:  MOVLW  0A
01EE2:  MOVWF  x95
01EE4:  CALL   14F8
01EE8:  MOVFF  03,94
01EEC:  MOVF   00,W
01EEE:  MOVFF  00,FEF
....................             decimal /= 10; 
01EF2:  MOVFF  4C,94
01EF6:  MOVFF  4B,93
01EFA:  CLRF   x96
01EFC:  MOVLW  0A
01EFE:  MOVWF  x95
01F00:  CALL   14F8
01F04:  MOVFF  02,4C
01F08:  MOVFF  01,4B
....................             }else{ 
01F0C:  BRA    1F94
....................             digito[size] = temp % 10; 
01F0E:  CLRF   03
01F10:  MOVF   40,W
01F12:  ADDLW  3C
01F14:  MOVWF  01
01F16:  MOVLW  00
01F18:  ADDWFC 03,F
01F1A:  MOVFF  01,91
01F1E:  MOVFF  03,92
01F22:  MOVFF  FEA,94
01F26:  MOVFF  FE9,93
01F2A:  BSF    FD8.1
01F2C:  CLRF   FEA
01F2E:  MOVLW  95
01F30:  MOVWF  FE9
01F32:  MOVFF  46,9C
01F36:  MOVFF  45,9B
01F3A:  MOVFF  44,9A
01F3E:  MOVFF  43,99
01F42:  CLRF   xA0
01F44:  CLRF   x9F
01F46:  CLRF   x9E
01F48:  MOVLW  0A
01F4A:  MOVWF  x9D
01F4C:  CALL   153A
01F50:  MOVFF  94,FEA
01F54:  MOVFF  93,FE9
01F58:  MOVFF  92,FEA
01F5C:  MOVFF  91,FE9
01F60:  MOVFF  95,FEF
....................             temp /= 10; 
01F64:  BCF    FD8.1
01F66:  MOVFF  46,9C
01F6A:  MOVFF  45,9B
01F6E:  MOVFF  44,9A
01F72:  MOVFF  43,99
01F76:  CLRF   xA0
01F78:  CLRF   x9F
01F7A:  CLRF   x9E
01F7C:  MOVLW  0A
01F7E:  MOVWF  x9D
01F80:  CALL   153A
01F84:  MOVFF  03,46
01F88:  MOVFF  02,45
01F8C:  MOVFF  01,44
01F90:  MOVFF  00,43
....................          } 
....................          size++; 
01F94:  INCF   40,F
....................       }while (temp > 0 || decimal > 0); 
01F96:  BTFSC  46.7
01F98:  BRA    1FAC
01F9A:  MOVF   46,F
01F9C:  BNZ   1EBE
01F9E:  MOVF   45,F
01FA0:  BNZ   1EBE
01FA2:  MOVF   44,F
01FA4:  BNZ   1EBE
01FA6:  MOVF   43,W
01FA8:  SUBLW  00
01FAA:  BNC   1EBE
01FAC:  MOVF   4B,F
01FAE:  BNZ   1EBE
01FB0:  MOVF   4C,F
01FB2:  BNZ   1EBE
....................    temp=abs(numero); 
01FB4:  MOVFF  8A,00
01FB8:  MOVFF  8B,01
01FBC:  MOVFF  8C,02
01FC0:  MOVFF  8D,03
01FC4:  BCF    01.7
01FC6:  MOVFF  8D,94
01FCA:  MOVFF  8C,93
01FCE:  MOVFF  01,92
01FD2:  MOVFF  8A,91
01FD6:  CALL   11AE
01FDA:  MOVFF  03,46
01FDE:  MOVFF  02,45
01FE2:  MOVFF  01,44
01FE6:  MOVFF  00,43
....................    size+=(signo && temp==0 && precision > 1) ? (precision - ceil(precision*0.5)) : (temp>=1) ? 0 : ceil(precision*0.5); 
01FEA:  BTFSS  1F.2
01FEC:  BRA    20B6
01FEE:  MOVF   43,F
01FF0:  BNZ   20B6
01FF2:  MOVF   44,F
01FF4:  BNZ   20B6
01FF6:  MOVF   45,F
01FF8:  BNZ   20B6
01FFA:  MOVF   46,F
01FFC:  BNZ   20B6
01FFE:  MOVF   x90,W
02000:  SUBLW  01
02002:  BC    20B6
02004:  CLRF   xB4
02006:  MOVFF  90,B3
0200A:  CALL   115E
0200E:  MOVFF  03,B2
02012:  MOVFF  02,B1
02016:  MOVFF  01,B0
0201A:  MOVFF  00,AF
0201E:  CLRF   xB6
02020:  CLRF   xB5
02022:  CLRF   xB4
02024:  MOVLW  7E
02026:  MOVWF  xB3
02028:  CALL   1340
0202C:  MOVFF  00,91
02030:  MOVFF  01,92
02034:  MOVFF  02,93
02038:  MOVFF  03,94
0203C:  MOVFF  03,9E
02040:  MOVFF  02,9D
02044:  MOVFF  01,9C
02048:  MOVFF  00,9B
0204C:  RCALL  1BAA
0204E:  MOVFF  00,91
02052:  MOVFF  01,92
02056:  MOVFF  02,93
0205A:  MOVFF  03,94
0205E:  CLRF   xB4
02060:  MOVFF  90,B3
02064:  CALL   115E
02068:  MOVFF  FEA,96
0206C:  MOVFF  FE9,95
02070:  BSF    FD8.1
02072:  MOVFF  03,B6
02076:  MOVFF  02,B5
0207A:  MOVFF  01,B4
0207E:  MOVFF  00,B3
02082:  MOVFF  94,BA
02086:  MOVFF  93,B9
0208A:  MOVFF  92,B8
0208E:  MOVFF  91,B7
02092:  CALL   161E
02096:  MOVFF  96,FEA
0209A:  MOVFF  95,FE9
0209E:  MOVFF  03,B2
020A2:  MOVFF  02,B1
020A6:  MOVFF  01,B0
020AA:  MOVFF  00,AF
020AE:  CALL   1432
020B2:  MOVF   01,W
020B4:  BRA    2136
020B6:  BTFSC  46.7
020B8:  BRA    20D6
020BA:  MOVF   46,F
020BC:  BNZ   20CC
020BE:  MOVF   45,F
020C0:  BNZ   20CC
020C2:  MOVF   44,F
020C4:  BNZ   20CC
020C6:  MOVF   43,W
020C8:  SUBLW  00
020CA:  BC    20D6
020CC:  CLRF   00
020CE:  CLRF   01
020D0:  CLRF   02
020D2:  CLRF   03
020D4:  BRA    2120
020D6:  CLRF   xB4
020D8:  MOVFF  90,B3
020DC:  CALL   115E
020E0:  MOVFF  03,B2
020E4:  MOVFF  02,B1
020E8:  MOVFF  01,B0
020EC:  MOVFF  00,AF
020F0:  CLRF   xB6
020F2:  CLRF   xB5
020F4:  CLRF   xB4
020F6:  MOVLW  7E
020F8:  MOVWF  xB3
020FA:  CALL   1340
020FE:  MOVFF  00,97
02102:  MOVFF  01,98
02106:  MOVFF  02,99
0210A:  MOVFF  03,9A
0210E:  MOVFF  03,9E
02112:  MOVFF  02,9D
02116:  MOVFF  01,9C
0211A:  MOVFF  00,9B
0211E:  RCALL  1BAA
02120:  MOVFF  03,B2
02124:  MOVFF  02,B1
02128:  MOVFF  01,B0
0212C:  MOVFF  00,AF
02130:  CALL   1432
02134:  MOVF   01,W
02136:  ADDWF  40,F
....................    } 
....................    for (i = 0; i < NUM_DISPLAYS; i++){output_Displays (~D7Seg); output_bit (transistorPins[i], ~Q); } //Apaga todos los displays 
02138:  CLRF   48
0213A:  CLRF   47
0213C:  MOVF   48,F
0213E:  BNZ   219C
02140:  MOVF   47,W
02142:  SUBLW  03
02144:  BNC   219C
02146:  MOVLW  00
02148:  BTFSS  1F.0
0214A:  MOVLW  01
0214C:  MOVWF  x91
0214E:  CLRF   F95
02150:  MOVWF  F8C
02152:  BCF    FD8.0
02154:  RLCF   47,W
02156:  MOVWF  02
02158:  RLCF   48,W
0215A:  MOVWF  03
0215C:  MOVF   02,W
0215E:  CALL   10CA
02162:  TBLRD*+
02164:  MOVFF  FF5,03
02168:  MOVWF  x91
0216A:  MOVFF  03,92
0216E:  MOVLW  00
02170:  BTFSS  1F.1
02172:  MOVLW  01
02174:  MOVFF  91,93
02178:  MOVWF  x94
0217A:  MOVLW  0F
0217C:  MOVWF  x96
0217E:  MOVLW  89
02180:  MOVWF  x95
02182:  RCALL  1BC2
02184:  MOVFF  91,93
02188:  CLRF   x94
0218A:  MOVLW  0F
0218C:  MOVWF  x96
0218E:  MOVLW  92
02190:  MOVWF  x95
02192:  RCALL  1BC2
02194:  INCF   47,F
02196:  BTFSC  FD8.2
02198:  INCF   48,F
0219A:  BRA    213C
....................    time = time / ( (TIME_MUX / 1000) * size); //Calcula el numero de ciclos segun el tiempo de multiplexacion que se introdujo 
0219C:  MOVFF  8F,94
021A0:  MOVFF  8E,93
021A4:  CLRF   x96
021A6:  MOVFF  40,95
021AA:  CALL   14F8
021AE:  MOVFF  02,8F
021B2:  MOVFF  01,8E
....................    if (time == 0) time = 1; //Evita que el valor sea 0 y nunca entre al bucle 
021B6:  MOVF   x8E,F
021B8:  BNZ   21C4
021BA:  MOVF   x8F,F
021BC:  BNZ   21C4
021BE:  CLRF   x8F
021C0:  MOVLW  01
021C2:  MOVWF  x8E
....................    for (j = 0; j < time; j++) 
021C4:  CLRF   4A
021C6:  CLRF   49
021C8:  MOVF   4A,W
021CA:  SUBWF  x8F,W
021CC:  BTFSS  FD8.0
021CE:  BRA    2410
021D0:  BNZ   21DA
021D2:  MOVF   x8E,W
021D4:  SUBWF  49,W
021D6:  BTFSC  FD8.0
021D8:  BRA    2410
....................    { 
....................       if (limit) 
021DA:  BTFSS  1F.3
021DC:  BRA    234E
....................       { 
....................       if(numero < 0 ) size2 = (size+((signo) ? 1 : 0)); 
021DE:  MOVFF  8D,B2
021E2:  MOVFF  8C,B1
021E6:  MOVFF  8B,B0
021EA:  MOVFF  8A,AF
021EE:  CLRF   xB6
021F0:  CLRF   xB5
021F2:  CLRF   xB4
021F4:  CLRF   xB3
021F6:  CALL   11EC
021FA:  BNC   220C
021FC:  BTFSS  1F.2
021FE:  BRA    2204
02200:  MOVLW  01
02202:  BRA    2206
02204:  MOVLW  00
02206:  ADDWF  40,W
02208:  MOVWF  42
....................       else size2 = NUM_DISPLAYS; 
0220A:  BRA    2210
0220C:  MOVLW  04
0220E:  MOVWF  42
....................        
....................          for (i = 0; i < size2; i++) 
02210:  CLRF   48
02212:  CLRF   47
02214:  MOVF   48,F
02216:  BTFSS  FD8.2
02218:  BRA    234C
0221A:  MOVF   42,W
0221C:  SUBWF  47,W
0221E:  BTFSC  FD8.0
02220:  BRA    234C
....................          { 
....................             
....................             if (i == (size) && signo){temp = 0b01000000; } //Asigna el signo 
02222:  MOVF   40,W
02224:  SUBWF  47,W
02226:  BNZ   223C
02228:  MOVF   48,F
0222A:  BNZ   223C
0222C:  BTFSS  1F.2
0222E:  BRA    223C
02230:  CLRF   46
02232:  CLRF   45
02234:  CLRF   44
02236:  MOVLW  40
02238:  MOVWF  43
....................             else{ temp = tabla7Seg[digito[i]] | ( (i == precision && precision > 0) ? 0b10000000 : 0); } // escoge el numero y aade el punto si es necesario 
0223A:  BRA    2286
0223C:  MOVLW  3C
0223E:  ADDWF  47,W
02240:  MOVWF  FE9
02242:  MOVLW  00
02244:  ADDWFC 48,W
02246:  MOVWF  FEA
02248:  CLRF   03
0224A:  MOVF   FEF,W
0224C:  CALL   10E6
02250:  MOVWF  x91
02252:  MOVF   x90,W
02254:  SUBWF  47,W
02256:  BNZ   226C
02258:  MOVF   48,F
0225A:  BNZ   226C
0225C:  MOVF   x90,F
0225E:  BZ    226C
02260:  MOVLW  80
02262:  MOVWF  00
02264:  CLRF   01
02266:  CLRF   02
02268:  CLRF   03
0226A:  BRA    2274
0226C:  CLRF   00
0226E:  CLRF   01
02270:  CLRF   02
02272:  CLRF   03
02274:  MOVF   00,W
02276:  IORWF  x91,W
02278:  MOVWF  43
0227A:  MOVFF  01,44
0227E:  MOVFF  02,45
02282:  MOVFF  03,46
....................             output_Displays ( ( (D7Seg) ? temp : ~ (temp))); //Activa la salida dependiendo si es de anodo o catodo comun los displays 
02286:  BTFSS  1F.0
02288:  BRA    229C
0228A:  MOVFF  43,00
0228E:  MOVFF  44,01
02292:  MOVFF  45,02
02296:  MOVFF  46,03
0229A:  BRA    22B4
0229C:  MOVFF  43,00
022A0:  COMF   00,F
022A2:  MOVFF  44,01
022A6:  COMF   01,F
022A8:  MOVFF  45,02
022AC:  COMF   02,F
022AE:  MOVFF  46,03
022B2:  COMF   03,F
022B4:  CLRF   F95
022B6:  MOVFF  00,F8C
....................             output_bit (transistorPins[i], Q); //Satura el transistor dependiendo si son PNP o NPN 
022BA:  BCF    FD8.0
022BC:  RLCF   47,W
022BE:  MOVWF  02
022C0:  RLCF   48,W
022C2:  MOVWF  03
022C4:  MOVF   02,W
022C6:  CALL   10CA
022CA:  TBLRD*+
022CC:  MOVFF  FF5,03
022D0:  MOVWF  x91
022D2:  MOVFF  03,92
022D6:  MOVLW  00
022D8:  BTFSC  1F.1
022DA:  MOVLW  01
022DC:  MOVFF  91,93
022E0:  MOVWF  x94
022E2:  MOVLW  0F
022E4:  MOVWF  x96
022E6:  MOVLW  89
022E8:  MOVWF  x95
022EA:  RCALL  1BC2
022EC:  MOVFF  91,93
022F0:  CLRF   x94
022F2:  MOVLW  0F
022F4:  MOVWF  x96
022F6:  MOVLW  92
022F8:  MOVWF  x95
022FA:  RCALL  1BC2
....................             delay_us (TIME_MUX); 
022FC:  MOVLW  01
022FE:  MOVWF  x91
02300:  RCALL  1C00
....................             output_bit (transistorPins[i], ~Q) ;//Apaga el transistor 
02302:  BCF    FD8.0
02304:  RLCF   47,W
02306:  MOVWF  02
02308:  RLCF   48,W
0230A:  MOVWF  03
0230C:  MOVF   02,W
0230E:  CALL   10CA
02312:  TBLRD*+
02314:  MOVFF  FF5,03
02318:  MOVWF  x91
0231A:  MOVFF  03,92
0231E:  MOVLW  00
02320:  BTFSS  1F.1
02322:  MOVLW  01
02324:  MOVFF  91,93
02328:  MOVWF  x94
0232A:  MOVLW  0F
0232C:  MOVWF  x96
0232E:  MOVLW  89
02330:  MOVWF  x95
02332:  RCALL  1BC2
02334:  MOVFF  91,93
02338:  CLRF   x94
0233A:  MOVLW  0F
0233C:  MOVWF  x96
0233E:  MOVLW  92
02340:  MOVWF  x95
02342:  RCALL  1BC2
....................          } 
02344:  INCF   47,F
02346:  BTFSC  FD8.2
02348:  INCF   48,F
0234A:  BRA    2214
....................  
....................          }else{ 
0234C:  BRA    2408
....................          time=1; 
0234E:  CLRF   x8F
02350:  MOVLW  01
02352:  MOVWF  x8E
....................          for (i = 0; i < NUM_DISPLAYS; i++) //Indicador que el numero ingresado es mayor de lo permitido 
02354:  CLRF   48
02356:  CLRF   47
02358:  MOVF   48,F
0235A:  BNZ   2408
0235C:  MOVF   47,W
0235E:  SUBLW  03
02360:  BNC   2408
....................          { 
....................             output_Displays ( ( (D7Seg) ? 0b01000000 : ~0b01000000)); 
02362:  BTFSS  1F.0
02364:  BRA    236C
02366:  CLRF   03
02368:  MOVLW  40
0236A:  BRA    236E
0236C:  MOVLW  BF
0236E:  CLRF   F95
02370:  MOVWF  F8C
....................             output_bit (transistorPins[i], Q) ; 
02372:  BCF    FD8.0
02374:  RLCF   47,W
02376:  MOVWF  02
02378:  RLCF   48,W
0237A:  MOVWF  03
0237C:  MOVF   02,W
0237E:  CALL   10CA
02382:  TBLRD*+
02384:  MOVFF  FF5,03
02388:  MOVWF  x91
0238A:  MOVFF  03,92
0238E:  MOVLW  00
02390:  BTFSC  1F.1
02392:  MOVLW  01
02394:  MOVFF  91,93
02398:  MOVWF  x94
0239A:  MOVLW  0F
0239C:  MOVWF  x96
0239E:  MOVLW  89
023A0:  MOVWF  x95
023A2:  RCALL  1BC2
023A4:  MOVFF  91,93
023A8:  CLRF   x94
023AA:  MOVLW  0F
023AC:  MOVWF  x96
023AE:  MOVLW  92
023B0:  MOVWF  x95
023B2:  RCALL  1BC2
....................             delay_us (TIME_MUX) ; 
023B4:  MOVLW  01
023B6:  MOVWF  x91
023B8:  RCALL  1C00
....................             output_bit (transistorPins[i], ~Q) ; 
023BA:  BCF    FD8.0
023BC:  RLCF   47,W
023BE:  MOVWF  02
023C0:  RLCF   48,W
023C2:  MOVWF  03
023C4:  MOVF   02,W
023C6:  CALL   10CA
023CA:  TBLRD*+
023CC:  MOVFF  FF5,03
023D0:  MOVWF  x91
023D2:  MOVFF  03,92
023D6:  MOVLW  00
023D8:  BTFSS  1F.1
023DA:  MOVLW  01
023DC:  MOVFF  91,93
023E0:  MOVWF  x94
023E2:  MOVLW  0F
023E4:  MOVWF  x96
023E6:  MOVLW  89
023E8:  MOVWF  x95
023EA:  CALL   1BC2
023EE:  MOVFF  91,93
023F2:  CLRF   x94
023F4:  MOVLW  0F
023F6:  MOVWF  x96
023F8:  MOVLW  92
023FA:  MOVWF  x95
023FC:  CALL   1BC2
....................          } 
02400:  INCF   47,F
02402:  BTFSC  FD8.2
02404:  INCF   48,F
02406:  BRA    2358
....................       } 
....................    } 
02408:  INCF   49,F
0240A:  BTFSC  FD8.2
0240C:  INCF   4A,F
0240E:  BRA    21C8
....................     enable_interrupts(INT_RB); 
02410:  BSF    FF2.3
02412:  MOVLW  FF
02414:  IORWF  F7A,F
.................... } 
02416:  RETURN 0
....................  
....................       
....................    

Configuration Fuses:
   Word  1: F79A   NOWDT PLL3 NOPLLEN NOSTVREN NOXINST NODEBUG NOCPUDIV NOPROTECT
   Word  2: FF3D   HSPLL SOSC_HIGH CLOCKOUT NOFCMEN NOIESO WDT32768
   Word  3: F861   DSWDTOSC_INT RTCOSC_INT NODSBOR NODSWDT DSWDT8192 NOIOL1WAY ADC12 MSSPMSK7
   Word  4: F980   NOWPFP NOWPCFG WPDIS WPEND LS48MHZ
