CCS PCH C Compiler, Version 4.120, 26417               15-Sept.-16 21:34

               Filename: C:\Users\Michael Vargas\Desktop\LauraPrimerCorte\i2c_ds1307.lst

               ROM used: 5584 bytes (4%)
                         Largest free fragment is 65528
               RAM used: 109 (3%) at main() level
                         140 (4%) worst case
               Stack:    6 locations

*
01000:  GOTO   1D3E
.................... #include <18F47J53.h> 
.................... //////// Standard Header file for the PIC18F47J53 device //////////////// 
.................... #device PIC18F47J53 
.................... #list 
....................  
....................  
.................... #device ADC=12 
....................  
.................... #FUSES NOWDT         //WDT disabled (enabled by SWDTEN bit)                     
.................... #FUSES PLL3          //Divide by 3 (12 MHz oscillator input)             
.................... #FUSES NOPLLEN       //PLL Disabled 
.................... #FUSES NOSTVREN      //stack overflow/underflow reset enabled                 
.................... #FUSES NOXINST       //Extended instruction set disabled             
.................... #FUSES NOCPUDIV      //No CPU system clock divide          
.................... #FUSES NOPROTECT     //Program memory is not code-protected           
.................... #FUSES HSPLL         //HS oscillator, PLL enabled, HSPLL used by USB            
.................... #FUSES SOSC_HIGH     //High Power T1OSC/SOSC circuit selected 
.................... #FUSES CLOCKOUT      //CLKO output enabled on the RA6 pin  
.................... #FUSES NOFCMEN       //Fail-Safe Clock Monitor disabled 
.................... #FUSES NOIESO        //Two-Speed Start-up disabled 
.................... #FUSES WDT32768      //Watchdog Postscaler 1:32768 
.................... #FUSES DSWDTOSC_INT  //DSWDT uses INTOSC/INTRC as clock 
.................... #FUSES RTCOSC_INT    //RTCC uses INTRC as clock 
.................... #FUSES NODSBOR       //Zero-Power BOR disabled in Deep Sleep 
.................... #FUSES NODSWDT       //Deep Sleep Watchdog Timer Disabled 
.................... #FUSES DSWDT8192     //Deep Sleep Watchdog Postscaler: 1:8,192 (8.5 seconds)    
.................... #FUSES NOIOL1WAY     //IOLOCK bit can be set and cleared 
.................... #FUSES ADC12         //ADC 10 or 12 Bit Select:12 - Bit ADC Enabed  
.................... #FUSES MSSPMSK7      //MSSP 7 Bit address masking 
.................... #FUSES NOWPFP        //Write Protect Program Flash Page 0 
.................... #FUSES NOWPCFG       //Write/Erase last page protect Disabled 
.................... #FUSES WPDIS         //WPFP[5:0], WPEND, and WPCFG bits ignored  
.................... #FUSES WPEND         //Start protection at page 0 
.................... #FUSES LS48MHZ       //Low Speed USB mode with 48 MHz System clock at 48 MHz USB CLKEN divide-by is set to 8  
.................... #use delay(clock=48000000) 
*
0120E:  CLRF   FEA
01210:  MOVLW  88
01212:  MOVWF  FE9
01214:  MOVF   FEF,W
01216:  BZ    1234
01218:  MOVLW  0F
0121A:  MOVWF  01
0121C:  CLRF   00
0121E:  DECFSZ 00,F
01220:  BRA    121E
01222:  DECFSZ 01,F
01224:  BRA    121C
01226:  MOVLW  8F
01228:  MOVWF  00
0122A:  DECFSZ 00,F
0122C:  BRA    122A
0122E:  NOP   
01230:  DECFSZ FEF,F
01232:  BRA    1218
01234:  RETURN 0
....................  
.................... //#use  rs232(baud=115200,parity=N,UART1,bits=8,timeout=30) 
.................... #use  I2C(master, sda=PIN_D1,scl=PIN_D0,SLOW) // I2C usando software 
*
013F0:  MOVLW  08
013F2:  MOVWF  01
013F4:  MOVLW  11
013F6:  MOVWF  00
013F8:  DECFSZ 00,F
013FA:  BRA    13F8
013FC:  BCF    F8C.0
013FE:  BCF    F95.0
01400:  MOVLW  11
01402:  MOVWF  00
01404:  DECFSZ 00,F
01406:  BRA    1404
01408:  RLCF   x75,F
0140A:  BCF    F8C.1
0140C:  BTFSC  FD8.0
0140E:  BSF    F95.1
01410:  BTFSS  FD8.0
01412:  BCF    F95.1
01414:  BSF    F95.0
01416:  BTFSS  F83.0
01418:  BRA    1416
0141A:  DECFSZ 01,F
0141C:  BRA    13F4
0141E:  MOVLW  11
01420:  MOVWF  00
01422:  DECFSZ 00,F
01424:  BRA    1422
01426:  BCF    F8C.0
01428:  BCF    F95.0
0142A:  NOP   
0142C:  BSF    F95.1
0142E:  MOVLW  11
01430:  MOVWF  00
01432:  DECFSZ 00,F
01434:  BRA    1432
01436:  MOVLW  11
01438:  MOVWF  00
0143A:  DECFSZ 00,F
0143C:  BRA    143A
0143E:  BSF    F95.0
01440:  BTFSS  F83.0
01442:  BRA    1440
01444:  CLRF   01
01446:  MOVLW  11
01448:  MOVWF  00
0144A:  DECFSZ 00,F
0144C:  BRA    144A
0144E:  BTFSC  F83.1
01450:  BSF    01.0
01452:  BCF    F8C.0
01454:  BCF    F95.0
01456:  BCF    F8C.1
01458:  BCF    F95.1
0145A:  RETURN 0
0145C:  MOVLW  08
0145E:  MOVWF  x77
01460:  MOVFF  00,78
01464:  BSF    F95.1
01466:  MOVLW  11
01468:  MOVWF  00
0146A:  DECFSZ 00,F
0146C:  BRA    146A
0146E:  BSF    F95.0
01470:  BTFSS  F83.0
01472:  BRA    1470
01474:  BTFSC  F83.1
01476:  BSF    FD8.0
01478:  BTFSS  F83.1
0147A:  BCF    FD8.0
0147C:  RLCF   01,F
0147E:  MOVLW  11
01480:  MOVWF  00
01482:  DECFSZ 00,F
01484:  BRA    1482
01486:  BCF    F95.0
01488:  BCF    F8C.0
0148A:  DECFSZ x77,F
0148C:  BRA    1464
0148E:  BSF    F95.1
01490:  MOVLW  11
01492:  MOVWF  00
01494:  DECFSZ 00,F
01496:  BRA    1494
01498:  BCF    F8C.1
0149A:  MOVF   x78,W
0149C:  BTFSS  FD8.2
0149E:  BCF    F95.1
014A0:  NOP   
014A2:  BSF    F95.0
014A4:  BTFSS  F83.0
014A6:  BRA    14A4
014A8:  MOVLW  11
014AA:  MOVWF  00
014AC:  DECFSZ 00,F
014AE:  BRA    14AC
014B0:  BCF    F8C.0
014B2:  BCF    F95.0
014B4:  MOVLW  11
014B6:  MOVWF  00
014B8:  DECFSZ 00,F
014BA:  BRA    14B8
014BC:  BCF    F8C.1
014BE:  BCF    F95.1
014C0:  RETURN 0
.................... //#use  I2C(master,I2C2, SLOW,FORCE_HW )          // I2C usando hardware 
....................  
....................  
....................  
.................... #define LOADER_END   0xFFF                         
.................... #build(reset=LOADER_END+1, interrupt=LOADER_END+9)   //Protege posiciones de memoria desde la 0x0000 hasta la 0x1000    
.................... #org 0, LOADER_END {} 
....................  
.................... #bit PLLEN = 0xf9b.6 
....................  
....................  
....................  
.................... #include "Configura_LCD_4-8_bits.c" 
.................... //Definicion de instruccion de la LCD 
.................... short bits_8_4; 
....................  
.................... #define LCD_LINEA2 0xC0    // Dirección de memoria para la segunda línea 
.................... #define clear_display            1 
.................... #define home                     0b10 
.................... #define entry_mode_set           0b100 
.................... #define display_on_off_control   0b1100 
.................... #define cursor_or_display_shift  0b1100 
.................... #define function_set             0b101000 
....................  
.................... #define RS_LCD        PIN_B0 
.................... #define RW_LCD        PIN_B1 
.................... #define E_LCD         PIN_B3 
.................... #define LCD_D4        PIN_D4 
.................... #define LCD_D5        PIN_D5 
.................... #define LCD_D6        PIN_D6 
.................... #define LCD_D7        PIN_D7 
....................  
.................... #define DATOS  PORTD 
....................  
.................... //-------------- Funcion que envia byte a pantalla lcd -------------------- 
.................... void lcd_envia_byte_4bits(int1 operacion, char dato ) { 
.................... output_low(E_LCD); 
*
01236:  BCF    F93.3
01238:  BCF    F8A.3
.................... output_low(RW_LCD); 
0123A:  BCF    F93.1
0123C:  BCF    F8A.1
.................... output_bit(RS_LCD,operacion); 
0123E:  MOVF   x86,F
01240:  BNZ   1246
01242:  BCF    F8A.0
01244:  BRA    1248
01246:  BSF    F8A.0
01248:  BCF    F93.0
....................  
.................... if(bit_test(dato,4)==1)output_high (LCD_D4);else output_low (LCD_D4); 
0124A:  BTFSS  x87.4
0124C:  BRA    1254
0124E:  BCF    F95.4
01250:  BSF    F8C.4
01252:  BRA    1258
01254:  BCF    F95.4
01256:  BCF    F8C.4
.................... if(bit_test(dato,5)==1)output_high (LCD_D5);else output_low (LCD_D5); 
01258:  BTFSS  x87.5
0125A:  BRA    1262
0125C:  BCF    F95.5
0125E:  BSF    F8C.5
01260:  BRA    1266
01262:  BCF    F95.5
01264:  BCF    F8C.5
.................... if(bit_test(dato,6)==1)output_high (LCD_D6);else output_low (LCD_D6); 
01266:  BTFSS  x87.6
01268:  BRA    1270
0126A:  BCF    F95.6
0126C:  BSF    F8C.6
0126E:  BRA    1274
01270:  BCF    F95.6
01272:  BCF    F8C.6
.................... if(bit_test(dato,7)==1)output_high (LCD_D7);else output_low (LCD_D7); 
01274:  BTFSS  x87.7
01276:  BRA    127E
01278:  BCF    F95.7
0127A:  BSF    F8C.7
0127C:  BRA    1282
0127E:  BCF    F95.7
01280:  BCF    F8C.7
.................... delay_us(10); 
01282:  MOVLW  27
01284:  MOVWF  00
01286:  DECFSZ 00,F
01288:  BRA    1286
0128A:  BRA    128C
....................  
.................... output_high(E_LCD); 
0128C:  BCF    F93.3
0128E:  BSF    F8A.3
.................... delay_ms(1); 
01290:  MOVLW  01
01292:  MOVWF  x88
01294:  RCALL  120E
.................... output_low(E_LCD); 
01296:  BCF    F93.3
01298:  BCF    F8A.3
.................... delay_ms(1); 
0129A:  MOVLW  01
0129C:  MOVWF  x88
0129E:  RCALL  120E
....................  
.................... if(bit_test(dato,0)==1)output_high (LCD_D4);else output_low (LCD_D4); 
012A0:  BTFSS  x87.0
012A2:  BRA    12AA
012A4:  BCF    F95.4
012A6:  BSF    F8C.4
012A8:  BRA    12AE
012AA:  BCF    F95.4
012AC:  BCF    F8C.4
.................... if(bit_test(dato,1)==1)output_high (LCD_D5);else output_low (LCD_D5); 
012AE:  BTFSS  x87.1
012B0:  BRA    12B8
012B2:  BCF    F95.5
012B4:  BSF    F8C.5
012B6:  BRA    12BC
012B8:  BCF    F95.5
012BA:  BCF    F8C.5
.................... if(bit_test(dato,2)==1)output_high (LCD_D6);else output_low (LCD_D6); 
012BC:  BTFSS  x87.2
012BE:  BRA    12C6
012C0:  BCF    F95.6
012C2:  BSF    F8C.6
012C4:  BRA    12CA
012C6:  BCF    F95.6
012C8:  BCF    F8C.6
.................... if(bit_test(dato,3)==1)output_high (LCD_D7);else output_low (LCD_D7); 
012CA:  BTFSS  x87.3
012CC:  BRA    12D4
012CE:  BCF    F95.7
012D0:  BSF    F8C.7
012D2:  BRA    12D8
012D4:  BCF    F95.7
012D6:  BCF    F8C.7
.................... delay_us(10); 
012D8:  MOVLW  27
012DA:  MOVWF  00
012DC:  DECFSZ 00,F
012DE:  BRA    12DC
012E0:  BRA    12E2
....................  
.................... output_high(E_LCD); 
012E2:  BCF    F93.3
012E4:  BSF    F8A.3
.................... delay_ms(1); 
012E6:  MOVLW  01
012E8:  MOVWF  x88
012EA:  RCALL  120E
.................... output_low(E_LCD); 
012EC:  BCF    F93.3
012EE:  BCF    F8A.3
.................... delay_ms(1); 
012F0:  MOVLW  01
012F2:  MOVWF  x88
012F4:  RCALL  120E
.................... } 
012F6:  RETURN 0
.................... //--------- Funcion que establece la posicion del cursor en la lcd ------------ 
.................... void lcd_ubicaxy_4bits(char columna,char fila) { 
.................... char posicion; 
....................      switch (fila) { 
012F8:  MOVLW  01
012FA:  SUBWF  x84,W
012FC:  ADDLW  FC
012FE:  BC    1326
01300:  ADDLW  04
01302:  GOTO   1330
....................      case 1   : posicion=(0x7F+columna); 
01306:  MOVLW  7F
01308:  ADDWF  x83,W
0130A:  MOVWF  x85
....................      break; 
0130C:  BRA    1326
....................      case 2   : posicion=(0xBF+columna); 
0130E:  MOVLW  BF
01310:  ADDWF  x83,W
01312:  MOVWF  x85
....................      break; 
01314:  BRA    1326
....................      case 3   : posicion=(0x8F+columna); 
01316:  MOVLW  8F
01318:  ADDWF  x83,W
0131A:  MOVWF  x85
....................      break; 
0131C:  BRA    1326
....................      case 4   : posicion=(0xCF+columna); 
0131E:  MOVLW  CF
01320:  ADDWF  x83,W
01322:  MOVWF  x85
....................      break; 
01324:  BRA    1326
....................    } 
....................    lcd_envia_byte_4bits( 0,posicion); 
01326:  CLRF   x86
01328:  MOVFF  85,87
0132C:  RCALL  1236
.................... } 
0132E:  RETURN 0
.................... //----------- Funcion que envia secuencia de inicializaciona lcd -------------- 
.................... void lcd_init_4bits() { 
....................     delay_ms(50); 
*
01358:  MOVLW  32
0135A:  MOVWF  x88
0135C:  RCALL  120E
....................     lcd_envia_byte_4bits(0,0B00110011); 
0135E:  CLRF   x86
01360:  MOVLW  33
01362:  MOVWF  x87
01364:  RCALL  1236
....................     lcd_envia_byte_4bits(0,0B00110010); 
01366:  CLRF   x86
01368:  MOVLW  32
0136A:  MOVWF  x87
0136C:  RCALL  1236
....................     lcd_envia_byte_4bits(0,function_set); 
0136E:  CLRF   x86
01370:  MOVLW  28
01372:  MOVWF  x87
01374:  RCALL  1236
....................     lcd_envia_byte_4bits(0,display_on_off_control); 
01376:  CLRF   x86
01378:  MOVLW  0C
0137A:  MOVWF  x87
0137C:  RCALL  1236
....................     lcd_envia_byte_4bits(0,clear_display); 
0137E:  CLRF   x86
01380:  MOVLW  01
01382:  MOVWF  x87
01384:  RCALL  1236
....................     lcd_ubicaxy_4bits(1,1); 
01386:  MOVLW  01
01388:  MOVWF  x83
0138A:  MOVWF  x84
0138C:  RCALL  12F8
.................... } 
0138E:  GOTO   1DA0 (RETURN)
.................... //---------------------- Escribe en la lcd la letra dada ---------------------- 
.................... void lcd_putc_4bits( char letra) { 
....................      switch (letra) { 
01392:  MOVF   x82,W
01394:  XORLW  0C
01396:  BZ    139E
01398:  XORLW  06
0139A:  BZ    13B0
0139C:  BRA    13BA
....................      case '\f'   : lcd_envia_byte_4bits(0,1);       //Borra la pantalla LCD 
0139E:  CLRF   x86
013A0:  MOVLW  01
013A2:  MOVWF  x87
013A4:  RCALL  1236
....................                    lcd_ubicaxy_4bits(1,1);         //Ubica cursor en fila 1 
013A6:  MOVLW  01
013A8:  MOVWF  x83
013AA:  MOVWF  x84
013AC:  RCALL  12F8
....................      break; 
013AE:  BRA    13C6
....................  
....................      case '\n'   : lcd_ubicaxy_4bits(0,2);          //Busca la fila 2 
013B0:  CLRF   x83
013B2:  MOVLW  02
013B4:  MOVWF  x84
013B6:  RCALL  12F8
....................      break; 
013B8:  BRA    13C6
....................  
....................      default     : lcd_envia_byte_4bits(1,letra); 
013BA:  MOVLW  01
013BC:  MOVWF  x86
013BE:  MOVFF  82,87
013C2:  RCALL  1236
....................      break; 
013C4:  BRA    13C6
....................    } 
....................  
.................... } 
013C6:  RETURN 0
.................... //************************************************************************************** 
.................... //************************************************************************************** 
.................... //************************************************************************************** 
.................... //************************************************************************************** 
.................... //************************************************************************************** 
.................... // Comandos para el funcionamiento a 8 bits 
.................... #define LCD_DATO    1 
.................... #define LCD_COMANDO 0 
....................  
.................... // instruccion de inicializacion 
.................... #define LCD_CLEAR          0x01 
.................... #define LCD_HOME          0x02 
....................  
.................... // Opciones para el display 
.................... #define LCD_DISPLAY_OFF  0x08 
.................... #define LCD_DISPLAY_ON   0x0C 
.................... #define LCD_CURSOR_ON    0x0E 
.................... #define LCD_CURSOR_BLINK 0x0F 
....................  
.................... // opciones epeciales del cursor 
.................... #define LCD_CURSOR_SHIFT_RIGHT  0x10 
.................... #define LCD_CURSOR_SHIFT_LEFT   0x14 
.................... #define LCD_DISPLAY_SHIFT_RIGHT 0x18 
.................... #define LCD_DISPLAY_SHIFT_LEFT  0x1C 
....................  
.................... // Configurar el hardware 
.................... #define LCD_DISPLAY_8_BITS   0x38  //0b00111000 
.................... #define LCD_DISPLAY_4_BITS   0x28  //0b00111000 
....................  
....................  
....................  
.................... void lcd_envia_8bits(int dir, int valor) 
.................... { 
....................     
....................         
....................     output_low(RW_LCD); 
....................     output_bit(RS_LCD,dir); 
....................     output_high(E_LCD); 
....................     output_d(valor);  // !!!!!Cambiar al puerto donde esten conectados los datos!!!!!! 
....................     delay_us(350); 
....................     output_low(E_LCD); 
....................     delay_us(350); 
....................     
....................       
.................... } 
....................  
....................  
.................... void lcd_init_8bits() 
.................... { 
....................   int dir,valor; 
....................   dir=LCD_COMANDO; 
....................   
....................   valor=LCD_DISPLAY_8_BITS;   //0x38 Inicia el modulo a 8 bits 
....................   bits_8_4=1; 
....................   
....................   lcd_envia_8bits(dir,valor); 
....................   delay_ms(1);    
....................   lcd_envia_8bits(dir,valor); 
....................  
....................   valor=LCD_DISPLAY_ON;    //0x0c activa display 
....................   lcd_envia_8bits(dir,valor); 
....................   valor=LCD_CLEAR;         //0x01 borra display 
....................   lcd_envia_8bits(dir,valor);  
....................   valor=0x06;               //selecciona mensaje fijo 
....................   lcd_envia_8bits(dir,valor); 
....................  
.................... } 
....................  
....................  
.................... void lcd_ubicaxy_8bits( char x, char y) { 
....................    char dir; 
....................  
....................    if(y!=1) 
....................      dir=LCD_LINEA2; 
....................    else 
....................      dir=0; 
....................    dir+=x-1; 
....................    lcd_envia_8bits(LCD_COMANDO,0x80|dir); 
.................... } 
....................  
....................  
.................... void lcd_putc_8bits( char c) 
.................... { 
....................    switch (c) 
....................    { 
....................      case '\f': 
....................          lcd_envia_8bits(LCD_COMANDO,0x01); 
....................          delay_ms(2); 
....................      break; 
....................      case '\n': 
....................          lcd_ubicaxy_8bits(1,2); 
....................      break; 
....................      case '\b': 
....................         lcd_envia_8bits(LCD_COMANDO,0x10); 
....................      break; 
....................      default : 
....................         lcd_envia_8bits(LCD_DATO,c); 
....................      break; 
....................    } 
.................... } 
....................  
.................... #include <stdlib.h> // for atoi32 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0173E:  CLRF   x88
....................    sign = 0; 
01740:  CLRF   x86
....................    base = 10; 
01742:  MOVLW  0A
01744:  MOVWF  x87
....................    result = 0; 
01746:  CLRF   x85
....................  
....................    if (!s) 
01748:  MOVF   x83,W
0174A:  IORWF  x84,W
0174C:  BNZ   1754
....................       return 0; 
0174E:  MOVLW  00
01750:  MOVWF  01
01752:  BRA    18D6
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
01754:  MOVF   x88,W
01756:  INCF   x88,F
01758:  CLRF   03
0175A:  ADDWF  x83,W
0175C:  MOVWF  FE9
0175E:  MOVF   x84,W
01760:  ADDWFC 03,W
01762:  MOVWF  FEA
01764:  MOVFF  FEF,89
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
01768:  MOVF   x89,W
0176A:  SUBLW  2D
0176C:  BNZ   1788
....................    { 
....................       sign = 1;         // Set the sign to negative 
0176E:  MOVLW  01
01770:  MOVWF  x86
....................       c = s[index++]; 
01772:  MOVF   x88,W
01774:  INCF   x88,F
01776:  CLRF   03
01778:  ADDWF  x83,W
0177A:  MOVWF  FE9
0177C:  MOVF   x84,W
0177E:  ADDWFC 03,W
01780:  MOVWF  FEA
01782:  MOVFF  FEF,89
....................    } 
....................    else if (c == '+') 
01786:  BRA    17A2
01788:  MOVF   x89,W
0178A:  SUBLW  2B
0178C:  BNZ   17A2
....................    { 
....................       c = s[index++]; 
0178E:  MOVF   x88,W
01790:  INCF   x88,F
01792:  CLRF   03
01794:  ADDWF  x83,W
01796:  MOVWF  FE9
01798:  MOVF   x84,W
0179A:  ADDWFC 03,W
0179C:  MOVWF  FEA
0179E:  MOVFF  FEF,89
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
017A2:  MOVF   x89,W
017A4:  SUBLW  2F
017A6:  BTFSC  FD8.0
017A8:  BRA    18C6
017AA:  MOVF   x89,W
017AC:  SUBLW  39
017AE:  BTFSS  FD8.0
017B0:  BRA    18C6
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
017B2:  MOVF   x89,W
017B4:  SUBLW  30
017B6:  BNZ   17FA
017B8:  CLRF   03
017BA:  MOVF   x88,W
017BC:  ADDWF  x83,W
017BE:  MOVWF  FE9
017C0:  MOVF   x84,W
017C2:  ADDWFC 03,W
017C4:  MOVWF  FEA
017C6:  MOVF   FEF,W
017C8:  SUBLW  78
017CA:  BZ    17E0
017CC:  CLRF   03
017CE:  MOVF   x88,W
017D0:  ADDWF  x83,W
017D2:  MOVWF  FE9
017D4:  MOVF   x84,W
017D6:  ADDWFC 03,W
017D8:  MOVWF  FEA
017DA:  MOVF   FEF,W
017DC:  SUBLW  58
017DE:  BNZ   17FA
....................       { 
....................          base = 16; 
017E0:  MOVLW  10
017E2:  MOVWF  x87
....................          index++; 
017E4:  INCF   x88,F
....................          c = s[index++]; 
017E6:  MOVF   x88,W
017E8:  INCF   x88,F
017EA:  CLRF   03
017EC:  ADDWF  x83,W
017EE:  MOVWF  FE9
017F0:  MOVF   x84,W
017F2:  ADDWFC 03,W
017F4:  MOVWF  FEA
017F6:  MOVFF  FEF,89
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
017FA:  MOVF   x87,W
017FC:  SUBLW  0A
017FE:  BNZ   1836
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
01800:  MOVF   x89,W
01802:  SUBLW  2F
01804:  BC    1834
01806:  MOVF   x89,W
01808:  SUBLW  39
0180A:  BNC   1834
....................             result = 10*result + (c - '0'); 
0180C:  MOVLW  0A
0180E:  MOVWF  x8A
01810:  MOVFF  85,8B
01814:  BRA    16F2
01816:  MOVLW  30
01818:  SUBWF  x89,W
0181A:  ADDWF  01,W
0181C:  MOVWF  x85
....................             c = s[index++]; 
0181E:  MOVF   x88,W
01820:  INCF   x88,F
01822:  CLRF   03
01824:  ADDWF  x83,W
01826:  MOVWF  FE9
01828:  MOVF   x84,W
0182A:  ADDWFC 03,W
0182C:  MOVWF  FEA
0182E:  MOVFF  FEF,89
....................          } 
01832:  BRA    1800
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
01834:  BRA    18C6
01836:  MOVF   x87,W
01838:  SUBLW  10
0183A:  BNZ   18C6
....................       { 
....................          c = toupper(c); 
0183C:  MOVF   x89,W
0183E:  SUBLW  60
01840:  BC    184E
01842:  MOVF   x89,W
01844:  SUBLW  7A
01846:  BNC   184E
01848:  MOVF   x89,W
0184A:  ANDLW  DF
0184C:  BRA    1850
0184E:  MOVF   x89,W
01850:  MOVWF  x89
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
01852:  MOVF   x89,W
01854:  SUBLW  2F
01856:  BC    185E
01858:  MOVF   x89,W
0185A:  SUBLW  39
0185C:  BC    186A
0185E:  MOVF   x89,W
01860:  SUBLW  40
01862:  BC    18C6
01864:  MOVF   x89,W
01866:  SUBLW  46
01868:  BNC   18C6
....................             if (c >= '0' && c <= '9') 
0186A:  MOVF   x89,W
0186C:  SUBLW  2F
0186E:  BC    1888
01870:  MOVF   x89,W
01872:  SUBLW  39
01874:  BNC   1888
....................                result = (result << 4) + (c - '0'); 
01876:  SWAPF  x85,W
01878:  MOVWF  x8A
0187A:  MOVLW  F0
0187C:  ANDWF  x8A,F
0187E:  MOVLW  30
01880:  SUBWF  x89,W
01882:  ADDWF  x8A,W
01884:  MOVWF  x85
....................             else 
01886:  BRA    189A
....................                result = (result << 4) + (c - 'A' + 10); 
01888:  SWAPF  x85,W
0188A:  MOVWF  x8A
0188C:  MOVLW  F0
0188E:  ANDWF  x8A,F
01890:  MOVLW  41
01892:  SUBWF  x89,W
01894:  ADDLW  0A
01896:  ADDWF  x8A,W
01898:  MOVWF  x85
....................  
....................             c = s[index++]; 
0189A:  MOVF   x88,W
0189C:  INCF   x88,F
0189E:  CLRF   03
018A0:  ADDWF  x83,W
018A2:  MOVWF  FE9
018A4:  MOVF   x84,W
018A6:  ADDWFC 03,W
018A8:  MOVWF  FEA
018AA:  MOVFF  FEF,89
....................             c = toupper(c); 
018AE:  MOVF   x89,W
018B0:  SUBLW  60
018B2:  BC    18C0
018B4:  MOVF   x89,W
018B6:  SUBLW  7A
018B8:  BNC   18C0
018BA:  MOVF   x89,W
018BC:  ANDLW  DF
018BE:  BRA    18C2
018C0:  MOVF   x89,W
018C2:  MOVWF  x89
....................          } 
018C4:  BRA    1852
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
018C6:  DECFSZ x86,W
018C8:  BRA    18D2
018CA:  MOVF   x87,W
018CC:  SUBLW  0A
018CE:  BNZ   18D2
....................        result = -result; 
018D0:  NEGF   x85
....................  
....................    return(result); 
018D2:  MOVFF  85,01
.................... } 
018D6:  GOTO   1980 (RETURN)
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /********************************************************/ 
.................... /*------- Espacio para declaracion de constantes  ------*/ 
.................... /********************************************************/ 
.................... #define segundos     0 
.................... #define minutos      1 
.................... #define horas        2 
.................... #define dia_semana   3 
.................... #define dia_mes      4 
.................... #define mes          5 
.................... #define anho         6 
.................... #define control      7  
.................... #define   F1  PIN_A5 
.................... #define   F2  PIN_E0 
.................... #define   F3  PIN_E1  
.................... #define   F4  PIN_E2 
.................... /********************************************************/ 
.................... /*--- Espacio para declaracion de variables globales  --*/ 
.................... /********************************************************/ 
....................  
....................  
.................... unsigned int16 i=0,n=0,duty; 
.................... unsigned char tecla; 
.................... char DS1307[64],OnTime[3][3],OffTime[3][3]; 
.................... char dutyUser[3]; 
....................  char col = 1, row = 2;    
.................... /********************************************************/ 
.................... /********************************************************/ 
.................... /*-------------- Espacio para funciones  ---------------*/ 
.................... /********************************************************/ 
.................... //Funciones para el teclado matricial 
.................... unsigned char barrer_teclado (void) 
.................... {        
*
01588:  MOVLW  0F
0158A:  MOVWF  x82
....................         unsigned char tecla=15; 
....................         delay_ms(10); 
0158C:  MOVLW  0A
0158E:  MOVWF  x88
01590:  RCALL  120E
....................  
....................         output_low(F1);  
01592:  BCF    F92.5
01594:  BCF    F89.5
....................           
....................         tecla=  input_a()&0x0f; 
01596:  SETF   F92
01598:  MOVF   F80,W
0159A:  ANDLW  0F
0159C:  MOVWF  x82
....................         if(tecla!=15){ 
0159E:  MOVF   x82,W
015A0:  SUBLW  0F
015A2:  BZ    15DE
....................         output_high(F1); 
015A4:  BCF    F92.5
015A6:  BSF    F89.5
....................         delay_ms(180); 
015A8:  MOVLW  B4
015AA:  MOVWF  x88
015AC:  RCALL  120E
....................         if(tecla==7)return('A'); 
015AE:  MOVF   x82,W
015B0:  SUBLW  07
015B2:  BNZ   15BA
015B4:  MOVLW  41
015B6:  MOVWF  01
015B8:  BRA    16D6
....................         if(tecla==11)return('3'); 
015BA:  MOVF   x82,W
015BC:  SUBLW  0B
015BE:  BNZ   15C6
015C0:  MOVLW  33
015C2:  MOVWF  01
015C4:  BRA    16D6
....................       if(tecla==13)return('2'); 
015C6:  MOVF   x82,W
015C8:  SUBLW  0D
015CA:  BNZ   15D2
015CC:  MOVLW  32
015CE:  MOVWF  01
015D0:  BRA    16D6
....................       if(tecla==14)return('1');  
015D2:  MOVF   x82,W
015D4:  SUBLW  0E
015D6:  BNZ   15DE
015D8:  MOVLW  31
015DA:  MOVWF  01
015DC:  BRA    16D6
....................         } 
....................         output_high(F1); 
015DE:  BCF    F92.5
015E0:  BSF    F89.5
....................          
....................         output_low(F2); 
015E2:  BCF    F96.0
015E4:  BCF    F8D.0
....................       
....................        tecla=  input_a()&0x0f; 
015E6:  SETF   F92
015E8:  MOVF   F80,W
015EA:  ANDLW  0F
015EC:  MOVWF  x82
....................         if(tecla!=15){  
015EE:  MOVF   x82,W
015F0:  SUBLW  0F
015F2:  BZ    162E
....................       output_high(F2); 
015F4:  BCF    F96.0
015F6:  BSF    F8D.0
....................       delay_ms(180); 
015F8:  MOVLW  B4
015FA:  MOVWF  x88
015FC:  RCALL  120E
....................         if(tecla==7)return('B'); 
015FE:  MOVF   x82,W
01600:  SUBLW  07
01602:  BNZ   160A
01604:  MOVLW  42
01606:  MOVWF  01
01608:  BRA    16D6
....................         if(tecla==11)return('6'); 
0160A:  MOVF   x82,W
0160C:  SUBLW  0B
0160E:  BNZ   1616
01610:  MOVLW  36
01612:  MOVWF  01
01614:  BRA    16D6
....................       if(tecla==13)return('5'); 
01616:  MOVF   x82,W
01618:  SUBLW  0D
0161A:  BNZ   1622
0161C:  MOVLW  35
0161E:  MOVWF  01
01620:  BRA    16D6
....................       if(tecla==14)return('4');  
01622:  MOVF   x82,W
01624:  SUBLW  0E
01626:  BNZ   162E
01628:  MOVLW  34
0162A:  MOVWF  01
0162C:  BRA    16D6
....................         } 
....................         output_high(F2); 
0162E:  BCF    F96.0
01630:  BSF    F8D.0
....................            
....................       output_low(F3);  
01632:  BCF    F96.1
01634:  BCF    F8D.1
....................        
....................         tecla=  input_a()&0x0f; 
01636:  SETF   F92
01638:  MOVF   F80,W
0163A:  ANDLW  0F
0163C:  MOVWF  x82
....................         if(tecla!=15){ 
0163E:  MOVF   x82,W
01640:  SUBLW  0F
01642:  BZ    167E
....................       output_high(F3); 
01644:  BCF    F96.1
01646:  BSF    F8D.1
....................      delay_ms(180); 
01648:  MOVLW  B4
0164A:  MOVWF  x88
0164C:  RCALL  120E
....................         if(tecla==7)return('C'); 
0164E:  MOVF   x82,W
01650:  SUBLW  07
01652:  BNZ   165A
01654:  MOVLW  43
01656:  MOVWF  01
01658:  BRA    16D6
....................         if(tecla==11)return('9'); 
0165A:  MOVF   x82,W
0165C:  SUBLW  0B
0165E:  BNZ   1666
01660:  MOVLW  39
01662:  MOVWF  01
01664:  BRA    16D6
....................       if(tecla==13)return('8'); 
01666:  MOVF   x82,W
01668:  SUBLW  0D
0166A:  BNZ   1672
0166C:  MOVLW  38
0166E:  MOVWF  01
01670:  BRA    16D6
....................       if(tecla==14)return('7'); 
01672:  MOVF   x82,W
01674:  SUBLW  0E
01676:  BNZ   167E
01678:  MOVLW  37
0167A:  MOVWF  01
0167C:  BRA    16D6
....................         }  
....................         output_high(F3); 
0167E:  BCF    F96.1
01680:  BSF    F8D.1
....................          
....................       output_low(F4);  
01682:  BCF    F96.2
01684:  BCF    F8D.2
....................          
....................         tecla=  input_a()&0x0f; 
01686:  SETF   F92
01688:  MOVF   F80,W
0168A:  ANDLW  0F
0168C:  MOVWF  x82
....................          if(tecla!=15){ 
0168E:  MOVF   x82,W
01690:  SUBLW  0F
01692:  BZ    16CE
....................        output_high(F4); 
01694:  BCF    F96.2
01696:  BSF    F8D.2
....................       delay_ms(180);      
01698:  MOVLW  B4
0169A:  MOVWF  x88
0169C:  RCALL  120E
....................         if(tecla==7)return('D'); 
0169E:  MOVF   x82,W
016A0:  SUBLW  07
016A2:  BNZ   16AA
016A4:  MOVLW  44
016A6:  MOVWF  01
016A8:  BRA    16D6
....................         if(tecla==11)return('#'); 
016AA:  MOVF   x82,W
016AC:  SUBLW  0B
016AE:  BNZ   16B6
016B0:  MOVLW  23
016B2:  MOVWF  01
016B4:  BRA    16D6
....................       if(tecla==13)return('0'); 
016B6:  MOVF   x82,W
016B8:  SUBLW  0D
016BA:  BNZ   16C2
016BC:  MOVLW  30
016BE:  MOVWF  01
016C0:  BRA    16D6
....................       if(tecla==14)return('x');  
016C2:  MOVF   x82,W
016C4:  SUBLW  0E
016C6:  BNZ   16CE
016C8:  MOVLW  78
016CA:  MOVWF  01
016CC:  BRA    16D6
....................         } 
....................         output_high(F4); 
016CE:  BCF    F96.2
016D0:  BSF    F8D.2
....................    
....................           
....................        return(0x80); 
016D2:  MOVLW  80
016D4:  MOVWF  01
....................         
.................... } 
016D6:  GOTO   16E6 (RETURN)
.................... unsigned char esperar_teclado (void) 
.................... {        
016DA:  MOVLW  80
016DC:  MOVWF  x81
....................         unsigned char tecla=0x80; 
....................         while(tecla==0x80)tecla=barrer_teclado (); 
016DE:  MOVF   x81,W
016E0:  SUBLW  80
016E2:  BNZ   16EC
016E4:  BRA    1588
016E6:  MOVFF  01,81
016EA:  BRA    16DE
....................         return(tecla); 
016EC:  MOVFF  81,01
.................... } 
016F0:  RETURN 0
.................... //Funciones para el reloj I2C 
.................... void write_ds1307(void) { 
.................... char ds1307_register; 
....................   i2c_start();                              //Genera señal de Start 
*
0198E:  BSF    F95.1
01990:  MOVLW  11
01992:  MOVWF  00
01994:  DECFSZ 00,F
01996:  BRA    1994
01998:  BSF    F95.0
0199A:  MOVLW  11
0199C:  MOVWF  00
0199E:  DECFSZ 00,F
019A0:  BRA    199E
019A2:  BCF    F8C.1
019A4:  BCF    F95.1
019A6:  MOVLW  11
019A8:  MOVWF  00
019AA:  DECFSZ 00,F
019AC:  BRA    19AA
019AE:  BCF    F8C.0
019B0:  BCF    F95.0
....................   i2c_write(0xD0);                          //Envia apuntador de dispositivo I2C 
019B2:  MOVLW  D0
019B4:  MOVWF  x75
019B6:  RCALL  13F0
....................   i2c_write(0x00);                          //Envia direccion LSB 
019B8:  CLRF   x75
019BA:  RCALL  13F0
....................   for(ds1307_register=0;ds1307_register<64;ds1307_register++){ 
019BC:  CLRF   x73
019BE:  MOVF   x73,W
019C0:  SUBLW  3F
019C2:  BNC   19E0
....................     i2c_write(DS1307 [ds1307_register]);    //Envia dato 
019C4:  CLRF   03
019C6:  MOVF   x73,W
019C8:  ADDLW  12
019CA:  MOVWF  FE9
019CC:  MOVLW  00
019CE:  ADDWFC 03,W
019D0:  MOVWF  FEA
019D2:  MOVFF  FEF,74
019D6:  MOVFF  74,75
019DA:  RCALL  13F0
....................   } 
019DC:  INCF   x73,F
019DE:  BRA    19BE
....................   i2c_stop();                               //Genera señal de Stop 
019E0:  BCF    F95.1
019E2:  NOP   
019E4:  BSF    F95.0
019E6:  BTFSS  F83.0
019E8:  BRA    19E6
019EA:  MOVLW  11
019EC:  MOVWF  00
019EE:  DECFSZ 00,F
019F0:  BRA    19EE
019F2:  BRA    19F4
019F4:  NOP   
019F6:  BSF    F95.1
019F8:  MOVLW  11
019FA:  MOVWF  00
019FC:  DECFSZ 00,F
019FE:  BRA    19FC
.................... } 
01A00:  GOTO   1F32 (RETURN)
....................  
.................... /******************************************************************************/ 
.................... /******************************************************************************/ 
....................  
.................... void read_ds1307(void) { 
.................... char ds1307_register; 
.................... i2c_start(); 
*
014C2:  BSF    F95.1
014C4:  MOVLW  11
014C6:  MOVWF  00
014C8:  DECFSZ 00,F
014CA:  BRA    14C8
014CC:  BSF    F95.0
014CE:  MOVLW  11
014D0:  MOVWF  00
014D2:  DECFSZ 00,F
014D4:  BRA    14D2
014D6:  BCF    F8C.1
014D8:  BCF    F95.1
014DA:  MOVLW  11
014DC:  MOVWF  00
014DE:  DECFSZ 00,F
014E0:  BRA    14DE
014E2:  BCF    F8C.0
014E4:  BCF    F95.0
.................... i2c_write(0xd0); 
014E6:  MOVLW  D0
014E8:  MOVWF  x75
014EA:  RCALL  13F0
.................... i2c_write(0); 
014EC:  CLRF   x75
014EE:  RCALL  13F0
.................... i2c_stop(); 
014F0:  BCF    F95.1
014F2:  NOP   
014F4:  BSF    F95.0
014F6:  BTFSS  F83.0
014F8:  BRA    14F6
014FA:  MOVLW  11
014FC:  MOVWF  00
014FE:  DECFSZ 00,F
01500:  BRA    14FE
01502:  BRA    1504
01504:  NOP   
01506:  BSF    F95.1
01508:  MOVLW  11
0150A:  MOVWF  00
0150C:  DECFSZ 00,F
0150E:  BRA    150C
.................... i2c_start(); 
01510:  BSF    F95.1
01512:  MOVLW  11
01514:  MOVWF  00
01516:  DECFSZ 00,F
01518:  BRA    1516
0151A:  BSF    F95.0
0151C:  MOVLW  11
0151E:  MOVWF  00
01520:  DECFSZ 00,F
01522:  BRA    1520
01524:  BCF    F8C.1
01526:  BCF    F95.1
01528:  MOVLW  11
0152A:  MOVWF  00
0152C:  DECFSZ 00,F
0152E:  BRA    152C
01530:  BCF    F8C.0
01532:  BCF    F95.0
.................... i2c_write(0xd1); 
01534:  MOVLW  D1
01536:  MOVWF  x75
01538:  RCALL  13F0
....................    for(ds1307_register=0;ds1307_register<63;ds1307_register++){ 
0153A:  CLRF   x73
0153C:  MOVF   x73,W
0153E:  SUBLW  3E
01540:  BNC   155E
....................       DS1307 [ds1307_register]=i2c_read();   // Toma lectura desde DS1307    
01542:  CLRF   03
01544:  MOVF   x73,W
01546:  ADDLW  12
01548:  MOVWF  FE9
0154A:  MOVLW  00
0154C:  ADDWFC 03,W
0154E:  MOVWF  FEA
01550:  MOVLW  01
01552:  MOVWF  00
01554:  RCALL  145C
01556:  MOVFF  01,FEF
....................    } 
0155A:  INCF   x73,F
0155C:  BRA    153C
.................... DS1307 [63]=i2c_read(0);                     // Toma lectura desde DS1307  
0155E:  CLRF   00
01560:  RCALL  145C
01562:  MOVFF  01,51
.................... i2c_stop();                                  // Genera señal de STOP     
01566:  BCF    F95.1
01568:  NOP   
0156A:  BSF    F95.0
0156C:  BTFSS  F83.0
0156E:  BRA    156C
01570:  MOVLW  11
01572:  MOVWF  00
01574:  DECFSZ 00,F
01576:  BRA    1574
01578:  BRA    157A
0157A:  NOP   
0157C:  BSF    F95.1
0157E:  MOVLW  11
01580:  MOVWF  00
01582:  DECFSZ 00,F
01584:  BRA    1582
.................... } 
01586:  RETURN 0
....................  void printHora(int1 fecha){ 
....................       lcd_ubicaxy_4bits(1,1); 
*
01C18:  MOVLW  01
01C1A:  MOVWF  x83
01C1C:  MOVWF  x84
01C1E:  CALL   12F8
....................       // Imprime resultado de lectura ds1307  
....................       printf(lcd_putc_4bits,"HORA:%2x:%2x:%2x   ",DS1307[horas],DS1307[minutos],DS1307[segundos]);  
01C22:  MOVLW  08
01C24:  MOVWF  FF6
01C26:  MOVLW  10
01C28:  MOVWF  FF7
01C2A:  MOVLW  00
01C2C:  MOVWF  FF8
01C2E:  MOVLW  05
01C30:  MOVWF  x75
01C32:  RCALL  1A04
01C34:  MOVFF  14,74
01C38:  MOVLW  57
01C3A:  MOVWF  x75
01C3C:  RCALL  1BD6
01C3E:  MOVLW  3A
01C40:  MOVWF  x82
01C42:  CALL   1392
01C46:  MOVFF  13,74
01C4A:  MOVLW  57
01C4C:  MOVWF  x75
01C4E:  RCALL  1BD6
01C50:  MOVLW  3A
01C52:  MOVWF  x82
01C54:  CALL   1392
01C58:  MOVFF  12,74
01C5C:  MOVLW  57
01C5E:  MOVWF  x75
01C60:  RCALL  1BD6
01C62:  MOVLW  20
01C64:  MOVWF  x82
01C66:  CALL   1392
01C6A:  MOVLW  20
01C6C:  MOVWF  x82
01C6E:  CALL   1392
01C72:  MOVLW  20
01C74:  MOVWF  x82
01C76:  CALL   1392
....................       if(fecha == true){ 
01C7A:  DECFSZ x73,W
01C7C:  BRA    1CCE
....................       printf(lcd_putc_4bits,"\nFECHA:%2x/%2x/20%2x",DS1307[dia_mes],DS1307[mes],DS1307[anho]); 
01C7E:  MOVLW  1C
01C80:  MOVWF  FF6
01C82:  MOVLW  10
01C84:  MOVWF  FF7
01C86:  MOVLW  00
01C88:  MOVWF  FF8
01C8A:  MOVLW  07
01C8C:  MOVWF  x75
01C8E:  RCALL  1A04
01C90:  MOVFF  16,74
01C94:  MOVLW  57
01C96:  MOVWF  x75
01C98:  RCALL  1BD6
01C9A:  MOVLW  2F
01C9C:  MOVWF  x82
01C9E:  CALL   1392
01CA2:  MOVFF  17,74
01CA6:  MOVLW  57
01CA8:  MOVWF  x75
01CAA:  RCALL  1BD6
01CAC:  MOVLW  2F
01CAE:  MOVWF  x82
01CB0:  CALL   1392
01CB4:  MOVLW  32
01CB6:  MOVWF  x82
01CB8:  CALL   1392
01CBC:  MOVLW  30
01CBE:  MOVWF  x82
01CC0:  CALL   1392
01CC4:  MOVFF  18,74
01CC8:  MOVLW  57
01CCA:  MOVWF  x75
01CCC:  RCALL  1BD6
....................       } 
.................... } 
01CCE:  GOTO   239E (RETURN)
.................... unsigned char esperar_teclado2(void) 
.................... {        
....................         unsigned int16 lastSeconds=0; 
....................         unsigned char tecla=0x80; 
....................         while(tecla==0x80){ 
....................         tecla=barrer_teclado (); 
....................         read_ds1307();                              // Lectura DS1307  
....................         if(DS1307[segundos] != lastSeconds){ 
....................         printHora(false); 
....................         } 
....................         lastSeconds = DS1307[segundos]; 
....................         } 
....................         return(tecla); 
.................... } 
.................... void convertDecToHex(char *data){ 
.................... char string[10]; 
.................... string[0] = '0'; //Añadir formato hexadecimal 
*
018DA:  MOVLW  30
018DC:  MOVWF  x77
.................... string[1] = 'x'; 
018DE:  MOVLW  78
018E0:  MOVWF  x78
.................... i = 2; //Iniciar en 2 
018E2:  CLRF   0C
018E4:  MOVLW  02
018E6:  MOVWF  0B
.................... while(tecla != 'x'){ 
018E8:  MOVF   11,W
018EA:  SUBLW  78
018EC:  BZ    195A
.................... tecla = esperar_teclado(); //Espera que se presione una tecla 
018EE:  RCALL  16DA
018F0:  MOVFF  01,11
.................... if(tecla == 'D'){ 
018F4:  MOVF   11,W
018F6:  SUBLW  44
018F8:  BNZ   191E
.................... col--; 
018FA:  DECF   x67,F
.................... lcd_ubicaxy_4bits(col,row); 
018FC:  MOVFF  67,83
01900:  MOVFF  68,84
01904:  RCALL  12F8
.................... lcd_putc_4bits(' '); 
01906:  MOVLW  20
01908:  MOVWF  x82
0190A:  RCALL  1392
.................... lcd_ubicaxy_4bits(col,row); 
0190C:  MOVFF  67,83
01910:  MOVFF  68,84
01914:  RCALL  12F8
.................... i--; 
01916:  MOVF   0B,W
01918:  BTFSC  FD8.2
0191A:  DECF   0C,F
0191C:  DECF   0B,F
.................... } 
.................... if(tecla >= '0' && tecla <= '9') { //Si la tecla presionada es un numero 
0191E:  MOVF   11,W
01920:  SUBLW  2F
01922:  BC    1958
01924:  MOVF   11,W
01926:  SUBLW  39
01928:  BNC   1958
.................... string[i] = tecla; 
0192A:  MOVLW  77
0192C:  ADDWF  0B,W
0192E:  MOVWF  FE9
01930:  MOVLW  00
01932:  ADDWFC 0C,W
01934:  MOVWF  FEA
01936:  MOVFF  11,FEF
.................... lcd_putc_4bits(string[i]); 
0193A:  MOVLW  77
0193C:  ADDWF  0B,W
0193E:  MOVWF  FE9
01940:  MOVLW  00
01942:  ADDWFC 0C,W
01944:  MOVWF  FEA
01946:  MOVFF  FEF,81
0194A:  MOVFF  81,82
0194E:  RCALL  1392
.................... col++; 
01950:  INCF   x67,F
.................... i++; 
01952:  INCF   0B,F
01954:  BTFSC  FD8.2
01956:  INCF   0C,F
.................... } 
.................... } 
01958:  BRA    18E8
.................... col++; 
0195A:  INCF   x67,F
.................... tecla = 0; 
0195C:  CLRF   11
.................... string[i] = '\0'; 
0195E:  MOVLW  77
01960:  ADDWF  0B,W
01962:  MOVWF  FE9
01964:  MOVLW  00
01966:  ADDWFC 0C,W
01968:  MOVWF  FEA
0196A:  CLRF   FEF
.................... //Escribe sobre la dirección de memoria ingresada 
.................... *data = atoi(string); //Convertir de string a entero 
0196C:  MOVFF  76,03
01970:  MOVFF  75,81
01974:  MOVFF  76,82
01978:  CLRF   x84
0197A:  MOVLW  77
0197C:  MOVWF  x83
0197E:  BRA    173E
01980:  MOVFF  82,FEA
01984:  MOVFF  81,FE9
01988:  MOVFF  01,FEF
.................... } 
0198C:  RETURN 0
.................... /******************************************************************************/ 
.................... /******************************************************************************/ 
.................... /*--------------------- Espacio de codigo principal --------------------------*/ 
.................... /******************************************************************************/  
.................... #zero_ram 
.................... void main(){ 
*
01D3E:  CLRF   FF8
01D40:  BCF    FD0.7
01D42:  MOVLW  AE
01D44:  MOVWF  00
01D46:  MOVLW  0F
01D48:  MOVWF  01
01D4A:  MOVLW  02
01D4C:  MOVWF  FE9
01D4E:  MOVLW  00
01D50:  MOVWF  FEA
01D52:  CLRF   FEE
01D54:  DECFSZ 00,F
01D56:  BRA    1D52
01D58:  DECFSZ 01,F
01D5A:  BRA    1D52
01D5C:  CLRF   FEA
01D5E:  CLRF   FE9
01D60:  CLRF   0C
01D62:  CLRF   0B
01D64:  CLRF   0E
01D66:  CLRF   0D
01D68:  MOVLW  01
01D6A:  MOVWF  x67
01D6C:  MOVLW  02
01D6E:  MOVWF  x68
01D70:  MOVLW  0E
01D72:  MOVWF  x69
01D74:  MOVLW  02
01D76:  MOVWF  x6A
01D78:  MOVLB  1
01D7A:  CLRF   x88
01D7C:  MOVLW  FF
01D7E:  MOVLB  F
01D80:  MOVWF  x48
01D82:  BCF    FC2.6
01D84:  BCF    FC2.7
01D86:  MOVF   x49,W
01D88:  ANDLW  E0
01D8A:  IORLW  1F
01D8C:  MOVWF  x49
01D8E:  CLRF   x25
01D90:  CLRF   FD1
01D92:  CLRF   FD2
01D94:  CLRF   05
01D96:  CLRF   06
.................... PLLEN = 1;          //Habilita PLL para generar 48MHz de oscilador*/\  
01D98:  BSF    F9B.6
.................... lcd_init_4bits();     
01D9A:  MOVLB  0
01D9C:  GOTO   1358
.................... //Configuracion de PWM 
.................... setup_timer_2(T2_DIV_BY_16,149,1); 
01DA0:  MOVLW  00
01DA2:  IORLW  06
01DA4:  MOVWF  FCA
01DA6:  MOVLW  95
01DA8:  MOVWF  FCB
.................... setup_adc( NO_ANALOGS); 
01DAA:  BCF    FC2.0
.................... setup_ccp5(CCP_PWM); 
01DAC:  BCF    F93.5
01DAE:  BCF    F8A.5
01DB0:  MOVLW  0C
01DB2:  MOVLB  F
01DB4:  MOVWF  x0F
01DB6:  BCF    x51.2
.................... setup_ccp6(CCP_PWM); 
01DB8:  BCF    F93.6
01DBA:  BCF    F8A.6
01DBC:  MOVWF  x0C
01DBE:  BCF    x51.4
.................... setup_ccp7(CCP_PWM); 
01DC0:  BCF    F93.7
01DC2:  BCF    F8A.7
01DC4:  MOVWF  x09
01DC6:  MOVLW  3F
01DC8:  ANDWF  x51,F
01DCA:  MOVLW  00
01DCC:  IORWF  x51,F
.................... set_pwm5_duty (0); 
01DCE:  CLRF   x10
.................... set_pwm6_duty (0); 
01DD0:  CLRF   x0D
.................... set_pwm7_duty (0); 
01DD2:  CLRF   x0A
....................  
....................  
.................... for(i=0;i<3;i++){  
01DD4:  CLRF   0C
01DD6:  CLRF   0B
01DD8:  MOVF   0C,F
01DDA:  BNZ   1E0E
01DDC:  MOVF   0B,W
01DDE:  SUBLW  02
01DE0:  BNC   1E0E
....................   printf(lcd_putc_4bits,"\f !!BIENVENIDO!!  \n   "); // 
01DE2:  MOVLW  32
01DE4:  MOVWF  FF6
01DE6:  MOVLW  10
01DE8:  MOVWF  FF7
01DEA:  MOVLW  00
01DEC:  MOVWF  FF8
01DEE:  MOVLB  0
01DF0:  CALL   13C8
....................   delay_ms(400); 
01DF4:  MOVLW  02
01DF6:  MOVWF  x73
01DF8:  MOVLW  C8
01DFA:  MOVWF  x88
01DFC:  CALL   120E
01E00:  DECFSZ x73,F
01E02:  BRA    1DF8
.................... } 
01E04:  INCF   0B,F
01E06:  BTFSC  FD8.2
01E08:  INCF   0C,F
01E0A:  MOVLB  F
01E0C:  BRA    1DD8
.................... for(i=0;i<4;i++){  
01E0E:  CLRF   0C
01E10:  CLRF   0B
01E12:  MOVF   0C,F
01E14:  BNZ   1E4C
01E16:  MOVF   0B,W
01E18:  SUBLW  03
01E1A:  BNC   1E4C
....................  printf(lcd_putc_4bits,"\fPARA ASIGNAR \n OPRIMA '*'"); // 
01E1C:  MOVLW  4A
01E1E:  MOVWF  FF6
01E20:  MOVLW  10
01E22:  MOVWF  FF7
01E24:  MOVLW  00
01E26:  MOVWF  FF8
01E28:  MOVLB  0
01E2A:  CALL   13C8
....................  read_ds1307();  
01E2E:  CALL   14C2
....................  delay_ms(400); 
01E32:  MOVLW  02
01E34:  MOVWF  x73
01E36:  MOVLW  C8
01E38:  MOVWF  x88
01E3A:  CALL   120E
01E3E:  DECFSZ x73,F
01E40:  BRA    1E36
.................... } 
01E42:  INCF   0B,F
01E44:  BTFSC  FD8.2
01E46:  INCF   0C,F
01E48:  MOVLB  F
01E4A:  BRA    1E12
....................  
.................... printf(lcd_putc_4bits,"\fModificar Hora?\nSi[A] No[B]->");   // Imprime mensaje de estado actual     
01E4C:  MOVLW  66
01E4E:  MOVWF  FF6
01E50:  MOVLW  10
01E52:  MOVWF  FF7
01E54:  MOVLW  00
01E56:  MOVWF  FF8
01E58:  MOVLB  0
01E5A:  CALL   13C8
.................... tecla = esperar_teclado(); 
01E5E:  RCALL  16DA
01E60:  MOVFF  01,11
.................... //################## Modificar hora - minutos ############ 
.................... if(tecla == 'A' || tecla == 'B'){ 
01E64:  MOVF   11,W
01E66:  SUBLW  41
01E68:  BZ    1E70
01E6A:  MOVF   11,W
01E6C:  SUBLW  42
01E6E:  BNZ   1F52
.................... lcd_putc_4bits(tecla); 
01E70:  MOVFF  11,82
01E74:  CALL   1392
.................... delay_ms(500); 
01E78:  MOVLW  02
01E7A:  MOVWF  x73
01E7C:  MOVLW  FA
01E7E:  MOVWF  x88
01E80:  CALL   120E
01E84:  DECFSZ x73,F
01E86:  BRA    1E7C
.................... if(tecla == 'A'){ 
01E88:  MOVF   11,W
01E8A:  SUBLW  41
01E8C:  BNZ   1F52
.................... col = 1, row = 2; 
01E8E:  MOVLW  01
01E90:  MOVWF  x67
01E92:  MOVLW  02
01E94:  MOVWF  x68
.................... printf(lcd_putc_4bits,"\fIngrese la Hora:\n"); 
01E96:  MOVLW  86
01E98:  MOVWF  FF6
01E9A:  MOVLW  10
01E9C:  MOVWF  FF7
01E9E:  MOVLW  00
01EA0:  MOVWF  FF8
01EA2:  CALL   13C8
.................... delay_ms(500); 
01EA6:  MOVLW  02
01EA8:  MOVWF  x73
01EAA:  MOVLW  FA
01EAC:  MOVWF  x88
01EAE:  CALL   120E
01EB2:  DECFSZ x73,F
01EB4:  BRA    1EAA
.................... read_ds1307(); 
01EB6:  CALL   14C2
.................... convertDectoHex(&DS1307[horas]); 
01EBA:  CLRF   x76
01EBC:  MOVLW  14
01EBE:  MOVWF  x75
01EC0:  RCALL  18DA
.................... printf(lcd_putc_4bits,":"); 
01EC2:  MOVLW  3A
01EC4:  MOVWF  x82
01EC6:  CALL   1392
.................... lcd_ubicaxy_4bits(1,1); 
01ECA:  MOVLW  01
01ECC:  MOVWF  x83
01ECE:  MOVWF  x84
01ED0:  CALL   12F8
.................... printf(lcd_putc_4bits,"Ingrese los Min:"); 
01ED4:  MOVLW  9A
01ED6:  MOVWF  FF6
01ED8:  MOVLW  10
01EDA:  MOVWF  FF7
01EDC:  MOVLW  00
01EDE:  MOVWF  FF8
01EE0:  CALL   13C8
.................... lcd_ubicaxy_4bits(4,2); 
01EE4:  MOVLW  04
01EE6:  MOVWF  x83
01EE8:  MOVLW  02
01EEA:  MOVWF  x84
01EEC:  CALL   12F8
.................... delay_ms(500); 
01EF0:  MOVLW  02
01EF2:  MOVWF  x73
01EF4:  MOVLW  FA
01EF6:  MOVWF  x88
01EF8:  CALL   120E
01EFC:  DECFSZ x73,F
01EFE:  BRA    1EF4
.................... convertDectoHex(&DS1307[minutos]); 
01F00:  CLRF   x76
01F02:  MOVLW  13
01F04:  MOVWF  x75
01F06:  RCALL  18DA
.................... printf(lcd_putc_4bits,":00"); 
01F08:  MOVLW  3A
01F0A:  MOVWF  x82
01F0C:  CALL   1392
01F10:  MOVLW  30
01F12:  MOVWF  x82
01F14:  CALL   1392
01F18:  MOVLW  30
01F1A:  MOVWF  x82
01F1C:  CALL   1392
.................... delay_ms(500); 
01F20:  MOVLW  02
01F22:  MOVWF  x73
01F24:  MOVLW  FA
01F26:  MOVWF  x88
01F28:  CALL   120E
01F2C:  DECFSZ x73,F
01F2E:  BRA    1F24
.................... /* 
.................... DS1307[dia_semana]=0x04; 
.................... DS1307[dia_mes]=0x15; 
.................... DS1307[mes]=0x09; 
.................... DS1307[anho]=0x16; 
.................... DS1307[control]=0x10;*/ 
.................... write_ds1307(); 
01F30:  BRA    198E
.................... printf(lcd_putc_4bits,"\fHora actualizada\n  con exito...!"); 
01F32:  MOVLW  AC
01F34:  MOVWF  FF6
01F36:  MOVLW  10
01F38:  MOVWF  FF7
01F3A:  MOVLW  00
01F3C:  MOVWF  FF8
01F3E:  CALL   13C8
.................... delay_ms(500); 
01F42:  MOVLW  02
01F44:  MOVWF  x73
01F46:  MOVLW  FA
01F48:  MOVWF  x88
01F4A:  CALL   120E
01F4E:  DECFSZ x73,F
01F50:  BRA    1F46
.................... } 
.................... } 
.................... //############### Ingreso de tiempo de encendido ################## 
.................... col = 8, row = 2; 
01F52:  MOVLW  08
01F54:  MOVWF  x67
01F56:  MOVLW  02
01F58:  MOVWF  x68
.................... for(n=0;n<3;n++){ 
01F5A:  CLRF   0E
01F5C:  CLRF   0D
01F5E:  MOVF   0E,F
01F60:  BNZ   2036
01F62:  MOVF   0D,W
01F64:  SUBLW  02
01F66:  BNC   2036
.................... col = 4, row = 2; 
01F68:  MOVLW  04
01F6A:  MOVWF  x67
01F6C:  MOVLW  02
01F6E:  MOVWF  x68
.................... printf(lcd_putc_4bits,"\fIngrese Hora On\nB%Lu=",n+1); 
01F70:  MOVLW  01
01F72:  ADDWF  0D,W
01F74:  MOVWF  x73
01F76:  MOVLW  00
01F78:  ADDWFC 0E,W
01F7A:  MOVWF  x74
01F7C:  MOVLW  CE
01F7E:  MOVWF  FF6
01F80:  MOVLW  10
01F82:  MOVWF  FF7
01F84:  MOVLW  00
01F86:  MOVWF  FF8
01F88:  MOVLW  12
01F8A:  MOVWF  x75
01F8C:  RCALL  1A04
01F8E:  MOVLW  10
01F90:  MOVWF  FE9
01F92:  MOVFF  74,76
01F96:  MOVFF  73,75
01F9A:  RCALL  1A2A
01F9C:  MOVLW  3D
01F9E:  MOVWF  x82
01FA0:  CALL   1392
.................... convertDecToHex(&onTime[horas][n]); 
01FA4:  MOVLW  58
01FA6:  ADDWF  0D,W
01FA8:  MOVWF  01
01FAA:  MOVLW  00
01FAC:  ADDWFC 0E,W
01FAE:  MOVWF  03
01FB0:  MOVFF  01,73
01FB4:  MOVWF  x74
01FB6:  MOVWF  x76
01FB8:  MOVFF  01,75
01FBC:  RCALL  18DA
.................... printf(lcd_putc_4bits,":"); 
01FBE:  MOVLW  3A
01FC0:  MOVWF  x82
01FC2:  CALL   1392
.................... lcd_ubicaxy_4bits(1,1); 
01FC6:  MOVLW  01
01FC8:  MOVWF  x83
01FCA:  MOVWF  x84
01FCC:  CALL   12F8
.................... printf(lcd_putc_4bits,"Ingrese Min On   "); 
01FD0:  MOVLW  E6
01FD2:  MOVWF  FF6
01FD4:  MOVLW  10
01FD6:  MOVWF  FF7
01FD8:  MOVLW  00
01FDA:  MOVWF  FF8
01FDC:  CALL   13C8
.................... lcd_ubicaxy_4bits(7,2); 
01FE0:  MOVLW  07
01FE2:  MOVWF  x83
01FE4:  MOVLW  02
01FE6:  MOVWF  x84
01FE8:  CALL   12F8
.................... convertDecToHex(&onTime[minutos][n]); 
01FEC:  MOVLW  55
01FEE:  ADDWF  0D,W
01FF0:  MOVWF  01
01FF2:  MOVLW  00
01FF4:  ADDWFC 0E,W
01FF6:  MOVWF  03
01FF8:  MOVFF  01,73
01FFC:  MOVWF  x74
01FFE:  MOVWF  x76
02000:  MOVFF  01,75
02004:  RCALL  18DA
.................... printf(lcd_putc_4bits,":00"); 
02006:  MOVLW  3A
02008:  MOVWF  x82
0200A:  CALL   1392
0200E:  MOVLW  30
02010:  MOVWF  x82
02012:  CALL   1392
02016:  MOVLW  30
02018:  MOVWF  x82
0201A:  CALL   1392
.................... delay_ms(500); 
0201E:  MOVLW  02
02020:  MOVWF  x73
02022:  MOVLW  FA
02024:  MOVWF  x88
02026:  CALL   120E
0202A:  DECFSZ x73,F
0202C:  BRA    2022
.................... } 
0202E:  INCF   0D,F
02030:  BTFSC  FD8.2
02032:  INCF   0E,F
02034:  BRA    1F5E
.................... //############### Ingreso de tiempo de apagado ################## 
.................... for(n=0;n<3;n++){ 
02036:  CLRF   0E
02038:  CLRF   0D
0203A:  MOVF   0E,F
0203C:  BNZ   2114
0203E:  MOVF   0D,W
02040:  SUBLW  02
02042:  BNC   2114
.................... col = 4, row = 2; 
02044:  MOVLW  04
02046:  MOVWF  x67
02048:  MOVLW  02
0204A:  MOVWF  x68
.................... printf(lcd_putc_4bits,"\fIngrese Hora Off\nB%Lu=",n+1); 
0204C:  MOVLW  01
0204E:  ADDWF  0D,W
02050:  MOVWF  x73
02052:  MOVLW  00
02054:  ADDWFC 0E,W
02056:  MOVWF  x74
02058:  MOVLW  F8
0205A:  MOVWF  FF6
0205C:  MOVLW  10
0205E:  MOVWF  FF7
02060:  MOVLW  00
02062:  MOVWF  FF8
02064:  MOVLW  13
02066:  MOVWF  x75
02068:  RCALL  1A04
0206A:  MOVLW  10
0206C:  MOVWF  FE9
0206E:  MOVFF  74,76
02072:  MOVFF  73,75
02076:  RCALL  1A2A
02078:  MOVLW  3D
0207A:  MOVWF  x82
0207C:  CALL   1392
.................... convertDecToHex(&offTime[horas][n]); 
02080:  MOVLW  61
02082:  ADDWF  0D,W
02084:  MOVWF  01
02086:  MOVLW  00
02088:  ADDWFC 0E,W
0208A:  MOVWF  03
0208C:  MOVFF  01,73
02090:  MOVWF  x74
02092:  MOVWF  x76
02094:  MOVFF  01,75
02098:  RCALL  18DA
.................... printf(lcd_putc_4bits,":"); 
0209A:  MOVLW  3A
0209C:  MOVWF  x82
0209E:  CALL   1392
.................... lcd_ubicaxy_4bits(1,1); 
020A2:  MOVLW  01
020A4:  MOVWF  x83
020A6:  MOVWF  x84
020A8:  CALL   12F8
.................... printf(lcd_putc_4bits,"Ingrese Min Off   "); 
020AC:  MOVLW  10
020AE:  MOVWF  FF6
020B0:  MOVLW  11
020B2:  MOVWF  FF7
020B4:  MOVLW  00
020B6:  MOVWF  FF8
020B8:  CALL   13C8
.................... lcd_ubicaxy_4bits(7,2); 
020BC:  MOVLW  07
020BE:  MOVWF  x83
020C0:  MOVLW  02
020C2:  MOVWF  x84
020C4:  CALL   12F8
.................... convertDecToHex(&offTime[minutos][n]); 
020C8:  MOVLW  5E
020CA:  ADDWF  0D,W
020CC:  MOVWF  01
020CE:  MOVLW  00
020D0:  ADDWFC 0E,W
020D2:  MOVWF  03
020D4:  MOVFF  01,73
020D8:  MOVWF  x74
020DA:  MOVWF  x76
020DC:  MOVFF  01,75
020E0:  CALL   18DA
.................... printf(lcd_putc_4bits,":00"); 
020E4:  MOVLW  3A
020E6:  MOVWF  x82
020E8:  CALL   1392
020EC:  MOVLW  30
020EE:  MOVWF  x82
020F0:  CALL   1392
020F4:  MOVLW  30
020F6:  MOVWF  x82
020F8:  CALL   1392
.................... delay_ms(500); 
020FC:  MOVLW  02
020FE:  MOVWF  x73
02100:  MOVLW  FA
02102:  MOVWF  x88
02104:  CALL   120E
02108:  DECFSZ x73,F
0210A:  BRA    2100
.................... } 
0210C:  INCF   0D,F
0210E:  BTFSC  FD8.2
02110:  INCF   0E,F
02112:  BRA    203A
.................... //################## Ingreso de porcentaje de PWM ################### 
.................... tecla = esperar_teclado(); 
02114:  CALL   16DA
02118:  MOVFF  01,11
.................... printf(lcd_putc_4bits,"\fBombillo 1\nIngrese %cPWM:",'%'); 
0211C:  MOVLW  24
0211E:  MOVWF  FF6
02120:  MOVLW  11
02122:  MOVWF  FF7
02124:  MOVLW  00
02126:  MOVWF  FF8
02128:  MOVLW  14
0212A:  MOVWF  x75
0212C:  RCALL  1A04
0212E:  MOVLW  25
02130:  MOVWF  x82
02132:  CALL   1392
02136:  MOVLW  3A
02138:  MOVWF  FF6
0213A:  MOVLW  11
0213C:  MOVWF  FF7
0213E:  MOVLW  00
02140:  MOVWF  FF8
02142:  MOVLW  04
02144:  MOVWF  x75
02146:  RCALL  1A04
.................... int menu,cont,decena,centena,unidad; 
....................    
....................   while(menu < 3){ 
02148:  MOVF   x6B,W
0214A:  SUBLW  02
0214C:  BTFSS  FD8.0
0214E:  BRA    238C
....................   static char col = 14, row = 2; 
....................   tecla= esperar_teclado (); 
02150:  CALL   16DA
02154:  MOVFF  01,11
....................   //Guarda el # oprimido 
....................   if(tecla >= '0' && tecla <= '9'){ 
02158:  MOVF   11,W
0215A:  SUBLW  2F
0215C:  BC    2194
0215E:  MOVF   11,W
02160:  SUBLW  39
02162:  BNC   2194
....................   lcd_putc_4bits(tecla); 
02164:  MOVFF  11,82
02168:  CALL   1392
....................   tecla-=48; 
0216C:  MOVLW  30
0216E:  SUBWF  11,F
....................   switch(cont){ 
02170:  MOVF   x6C,W
02172:  BZ    217E
02174:  XORLW  01
02176:  BZ    2184
02178:  XORLW  03
0217A:  BZ    218A
0217C:  BRA    2190
....................    case 0: centena = tecla; break; 
0217E:  MOVFF  11,6E
02182:  BRA    2190
....................    case 1: decena = tecla; break; 
02184:  MOVFF  11,6D
02188:  BRA    2190
....................    case 2: unidad = tecla; break; 
0218A:  MOVFF  11,6F
0218E:  BRA    2190
....................   } 
....................   cont++; 
02190:  INCF   x6C,F
....................   col++; 
02192:  INCF   x69,F
....................   } 
....................   if(tecla == 'D'){ 
02194:  MOVF   11,W
02196:  SUBLW  44
02198:  BNZ   21BE
....................   col--; 
0219A:  DECF   x69,F
....................   lcd_ubicaxy_4bits(col,row); 
0219C:  MOVFF  69,83
021A0:  MOVFF  6A,84
021A4:  CALL   12F8
....................   lcd_putc_4bits(' '); 
021A8:  MOVLW  20
021AA:  MOVWF  x82
021AC:  CALL   1392
....................   lcd_ubicaxy_4bits(col,row); 
021B0:  MOVFF  69,83
021B4:  MOVFF  6A,84
021B8:  CALL   12F8
....................   cont--; 
021BC:  DECF   x6C,F
....................   } 
....................  //Guardar valor de PWM 
....................   if(tecla == 'x'){ 
021BE:  MOVF   11,W
021C0:  SUBLW  78
021C2:  BTFSS  FD8.2
021C4:  BRA    238A
....................   if(cont > 2) duty = (centena * 100 ) + (decena*10) + (unidad); 
021C6:  MOVF   x6C,W
021C8:  SUBLW  02
021CA:  BC    21E4
021CC:  MOVF   x6E,W
021CE:  MULLW  64
021D0:  MOVFF  FF3,73
021D4:  MOVF   x6D,W
021D6:  MULLW  0A
021D8:  MOVF   FF3,W
021DA:  ADDWF  x73,W
021DC:  ADDWF  x6F,W
021DE:  MOVWF  0F
021E0:  CLRF   10
....................   else if (cont == 2) duty = (centena * 10 ) +  decena; 
021E2:  BRA    2202
021E4:  MOVF   x6C,W
021E6:  SUBLW  02
021E8:  BNZ   21F8
021EA:  MOVF   x6E,W
021EC:  MULLW  0A
021EE:  MOVF   FF3,W
021F0:  ADDWF  x6D,W
021F2:  MOVWF  0F
021F4:  CLRF   10
....................   else if (cont == 1) duty = centena; 
021F6:  BRA    2202
021F8:  DECFSZ x6C,W
021FA:  BRA    2202
021FC:  CLRF   10
021FE:  MOVFF  6E,0F
....................   if(duty > 100) duty = 100; 
02202:  MOVF   10,F
02204:  BNZ   220C
02206:  MOVF   0F,W
02208:  SUBLW  64
0220A:  BC    2212
0220C:  CLRF   10
0220E:  MOVLW  64
02210:  MOVWF  0F
....................   duty = (255*duty) / 100; 
02212:  CLRF   x74
02214:  SETF   x73
02216:  MOVFF  10,76
0221A:  MOVFF  0F,75
0221E:  BRA    1ADC
02220:  MOVFF  02,74
02224:  MOVFF  01,73
02228:  MOVFF  02,76
0222C:  MOVFF  01,75
02230:  CLRF   x78
02232:  MOVLW  64
02234:  MOVWF  x77
02236:  BRA    1AFC
02238:  MOVFF  02,10
0223C:  MOVFF  01,0F
....................   dutyUser[menu] = duty; 
02240:  CLRF   03
02242:  MOVF   x6B,W
02244:  ADDLW  64
02246:  MOVWF  FE9
02248:  MOVLW  00
0224A:  ADDWFC 03,W
0224C:  MOVWF  FEA
0224E:  MOVFF  0F,FEF
....................   printf(lcd_putc_4bits,"\fPWM Asignado \n%u",dutyUser[menu]); 
02252:  CLRF   03
02254:  MOVF   x6B,W
02256:  ADDLW  64
02258:  MOVWF  FE9
0225A:  MOVLW  00
0225C:  ADDWFC 03,W
0225E:  MOVWF  FEA
02260:  MOVFF  FEF,73
02264:  MOVLW  40
02266:  MOVWF  FF6
02268:  MOVLW  11
0226A:  MOVWF  FF7
0226C:  MOVLW  00
0226E:  MOVWF  FF8
02270:  MOVLW  0F
02272:  MOVWF  x75
02274:  CALL   1A04
02278:  MOVFF  73,74
0227C:  MOVLW  1B
0227E:  MOVWF  x75
02280:  BRA    1B68
....................   delay_ms(1000); 
02282:  MOVLW  04
02284:  MOVWF  x73
02286:  MOVLW  FA
02288:  MOVWF  x88
0228A:  CALL   120E
0228E:  DECFSZ x73,F
02290:  BRA    2286
....................   menu++;  
02292:  INCF   x6B,F
....................   IF(menu == 3){ 
02294:  MOVF   x6B,W
02296:  SUBLW  03
02298:  BNZ   22DA
....................   printf(lcd_putc_4bits,"\fDesea cambiar el\n%cPWM?Si[A] No[B]",'%'); 
0229A:  MOVLW  52
0229C:  MOVWF  FF6
0229E:  MOVLW  11
022A0:  MOVWF  FF7
022A2:  MOVLW  00
022A4:  MOVWF  FF8
022A6:  MOVLW  12
022A8:  MOVWF  x75
022AA:  CALL   1A04
022AE:  MOVLW  25
022B0:  MOVWF  x82
022B2:  CALL   1392
022B6:  MOVLW  66
022B8:  MOVWF  FF6
022BA:  MOVLW  11
022BC:  MOVWF  FF7
022BE:  MOVLW  00
022C0:  MOVWF  FF8
022C2:  MOVLW  0F
022C4:  MOVWF  x75
022C6:  CALL   1A04
....................   tecla = esperar_teclado(); 
022CA:  CALL   16DA
022CE:  MOVFF  01,11
....................   if(tecla == 'A') menu = 0; 
022D2:  MOVF   11,W
022D4:  SUBLW  41
022D6:  BTFSC  FD8.2
022D8:  CLRF   x6B
....................   } 
....................    col = 14;  
022DA:  MOVLW  0E
022DC:  MOVWF  x69
....................     switch(menu){ 
022DE:  MOVF   x6B,W
022E0:  BZ    22EC
022E2:  XORLW  01
022E4:  BZ    231E
022E6:  XORLW  03
022E8:  BZ    2350
022EA:  BRA    2382
....................    case 0: printf(lcd_putc_4bits,"\fBombillo 1\nIngrese %cPWM:",'%');  break; 
022EC:  MOVLW  76
022EE:  MOVWF  FF6
022F0:  MOVLW  11
022F2:  MOVWF  FF7
022F4:  MOVLW  00
022F6:  MOVWF  FF8
022F8:  MOVLW  14
022FA:  MOVWF  x75
022FC:  CALL   1A04
02300:  MOVLW  25
02302:  MOVWF  x82
02304:  CALL   1392
02308:  MOVLW  8C
0230A:  MOVWF  FF6
0230C:  MOVLW  11
0230E:  MOVWF  FF7
02310:  MOVLW  00
02312:  MOVWF  FF8
02314:  MOVLW  04
02316:  MOVWF  x75
02318:  CALL   1A04
0231C:  BRA    2382
....................    case 1: printf(lcd_putc_4bits,"\fBombillo 2\nIngrese %cPWM:",'%'); break; 
0231E:  MOVLW  92
02320:  MOVWF  FF6
02322:  MOVLW  11
02324:  MOVWF  FF7
02326:  MOVLW  00
02328:  MOVWF  FF8
0232A:  MOVLW  14
0232C:  MOVWF  x75
0232E:  CALL   1A04
02332:  MOVLW  25
02334:  MOVWF  x82
02336:  CALL   1392
0233A:  MOVLW  A8
0233C:  MOVWF  FF6
0233E:  MOVLW  11
02340:  MOVWF  FF7
02342:  MOVLW  00
02344:  MOVWF  FF8
02346:  MOVLW  04
02348:  MOVWF  x75
0234A:  CALL   1A04
0234E:  BRA    2382
....................    case 2: printf(lcd_putc_4bits,"\fBombillo 3\nIngrese %cPWM:",'%'); break;      
02350:  MOVLW  AE
02352:  MOVWF  FF6
02354:  MOVLW  11
02356:  MOVWF  FF7
02358:  MOVLW  00
0235A:  MOVWF  FF8
0235C:  MOVLW  14
0235E:  MOVWF  x75
02360:  CALL   1A04
02364:  MOVLW  25
02366:  MOVWF  x82
02368:  CALL   1392
0236C:  MOVLW  C4
0236E:  MOVWF  FF6
02370:  MOVLW  11
02372:  MOVWF  FF7
02374:  MOVLW  00
02376:  MOVWF  FF8
02378:  MOVLW  04
0237A:  MOVWF  x75
0237C:  CALL   1A04
02380:  BRA    2382
....................    } 
....................    //Reinicia las variables 
....................    cont = duty = 0; 
02382:  CLRF   10
02384:  CLRF   0F
02386:  MOVFF  0F,6C
....................   } 
....................   } 
0238A:  BRA    2148
....................   //############################# Lectura del reloj y  #################### 
....................   char lastSeconds; 
....................   int1 Flag1[3],Flag2[3]; 
....................    for(;;){  
....................     read_ds1307(); //Obtener la hora  
0238C:  CALL   14C2
....................     if(DS1307[segundos] != lastSeconds){ 
02390:  MOVF   x70,W
02392:  SUBWF  12,W
02394:  BTFSC  FD8.2
02396:  BRA    25CC
....................        printHora(true); 
02398:  MOVLW  01
0239A:  MOVWF  x73
0239C:  BRA    1C18
....................        for(n=0;n<3;n++){ 
0239E:  CLRF   0E
023A0:  CLRF   0D
023A2:  MOVF   0E,F
023A4:  BTFSS  FD8.2
023A6:  BRA    25CC
023A8:  MOVF   0D,W
023AA:  SUBLW  02
023AC:  BTFSS  FD8.0
023AE:  BRA    25CC
....................        if(DS1307[horas] == onTime[horas][n] && DS1307[minutos] == onTime[minutos][n] && Flag1[n] == 0){ 
023B0:  MOVLW  58
023B2:  ADDWF  0D,W
023B4:  MOVWF  FE9
023B6:  MOVLW  00
023B8:  ADDWFC 0E,W
023BA:  MOVWF  FEA
023BC:  MOVF   FEF,W
023BE:  SUBWF  14,W
023C0:  BTFSS  FD8.2
023C2:  BRA    24CC
023C4:  MOVLW  55
023C6:  ADDWF  0D,W
023C8:  MOVWF  FE9
023CA:  MOVLW  00
023CC:  ADDWFC 0E,W
023CE:  MOVWF  FEA
023D0:  MOVF   FEF,W
023D2:  SUBWF  13,W
023D4:  BTFSS  FD8.2
023D6:  BRA    24CC
023D8:  MOVFF  0D,73
023DC:  CLRF   x75
023DE:  MOVLW  71
023E0:  MOVWF  x74
023E2:  RCALL  1CD2
023E4:  MOVLW  00
023E6:  BTFSC  01.0
023E8:  MOVLW  01
023EA:  ANDLW  01
023EC:  BTFSS  FD8.2
023EE:  BRA    24CC
....................        Flag1[n] = 1; 
023F0:  MOVFF  0D,73
023F4:  MOVLW  01
023F6:  MOVWF  x74
023F8:  CLRF   x76
023FA:  MOVLW  71
023FC:  MOVWF  x75
023FE:  RCALL  1D00
....................        Flag2[n] = 0; 
02400:  MOVFF  0D,73
02404:  CLRF   x74
02406:  CLRF   x76
02408:  MOVLW  72
0240A:  MOVWF  x75
0240C:  RCALL  1D00
....................        printf(lcd_putc_4bits,"\fEncendiendo...\n   Bombillo %Lu   ",n+1); 
0240E:  MOVLW  01
02410:  ADDWF  0D,W
02412:  MOVWF  x73
02414:  MOVLW  00
02416:  ADDWFC 0E,W
02418:  MOVWF  x74
0241A:  MOVLW  CA
0241C:  MOVWF  FF6
0241E:  MOVLW  11
02420:  MOVWF  FF7
02422:  MOVLW  00
02424:  MOVWF  FF8
02426:  MOVLW  1C
02428:  MOVWF  x75
0242A:  CALL   1A04
0242E:  MOVLW  10
02430:  MOVWF  FE9
02432:  MOVFF  74,76
02436:  MOVFF  73,75
0243A:  CALL   1A2A
0243E:  MOVLW  20
02440:  MOVWF  x82
02442:  CALL   1392
02446:  MOVLW  20
02448:  MOVWF  x82
0244A:  CALL   1392
0244E:  MOVLW  20
02450:  MOVWF  x82
02452:  CALL   1392
....................        switch(n){ 
02456:  MOVFF  0D,00
0245A:  MOVF   0E,W
0245C:  MOVWF  03
0245E:  BNZ   2464
02460:  MOVF   00,F
02462:  BZ    247A
02464:  MOVF   03,W
02466:  BNZ   246E
02468:  MOVLW  01
0246A:  SUBWF  00,W
0246C:  BZ    2490
0246E:  MOVF   03,W
02470:  BNZ   2478
02472:  MOVLW  02
02474:  SUBWF  00,W
02476:  BZ    24A6
02478:  BRA    24BC
....................        case 0: set_pwm5_duty (dutyUser[n]);  break; 
0247A:  MOVLW  64
0247C:  ADDWF  0D,W
0247E:  MOVWF  FE9
02480:  MOVLW  00
02482:  ADDWFC 0E,W
02484:  MOVWF  FEA
02486:  MOVFF  FEF,73
0248A:  MOVFF  73,F10
0248E:  BRA    24BC
....................        case 1: set_pwm6_duty (dutyUser[n]); break; 
02490:  MOVLW  64
02492:  ADDWF  0D,W
02494:  MOVWF  FE9
02496:  MOVLW  00
02498:  ADDWFC 0E,W
0249A:  MOVWF  FEA
0249C:  MOVFF  FEF,73
024A0:  MOVFF  73,F0D
024A4:  BRA    24BC
....................        case 2: set_pwm7_duty (dutyUser[n]); break; 
024A6:  MOVLW  64
024A8:  ADDWF  0D,W
024AA:  MOVWF  FE9
024AC:  MOVLW  00
024AE:  ADDWFC 0E,W
024B0:  MOVWF  FEA
024B2:  MOVFF  FEF,73
024B6:  MOVFF  73,F0A
024BA:  BRA    24BC
....................        } 
....................        delay_ms(900); 
024BC:  MOVLW  04
024BE:  MOVWF  x73
024C0:  MOVLW  E1
024C2:  MOVWF  x88
024C4:  CALL   120E
024C8:  DECFSZ x73,F
024CA:  BRA    24C0
....................        } 
....................        if(DS1307[horas] == offTime[horas][n] && DS1307[minutos] == offTime[minutos][n]  && Flag2[n] == 0 ){ 
024CC:  MOVLW  61
024CE:  ADDWF  0D,W
024D0:  MOVWF  FE9
024D2:  MOVLW  00
024D4:  ADDWFC 0E,W
024D6:  MOVWF  FEA
024D8:  MOVF   FEF,W
024DA:  SUBWF  14,W
024DC:  BTFSS  FD8.2
024DE:  BRA    25C4
024E0:  MOVLW  5E
024E2:  ADDWF  0D,W
024E4:  MOVWF  FE9
024E6:  MOVLW  00
024E8:  ADDWFC 0E,W
024EA:  MOVWF  FEA
024EC:  MOVF   FEF,W
024EE:  SUBWF  13,W
024F0:  BNZ   25C4
024F2:  MOVFF  0D,73
024F6:  CLRF   x75
024F8:  MOVLW  72
024FA:  MOVWF  x74
024FC:  CALL   1CD2
02500:  MOVLW  00
02502:  BTFSC  01.0
02504:  MOVLW  01
02506:  ANDLW  01
02508:  BNZ   25C4
....................        Flag2[n] = 1; 
0250A:  MOVFF  0D,73
0250E:  MOVLW  01
02510:  MOVWF  x74
02512:  CLRF   x76
02514:  MOVLW  72
02516:  MOVWF  x75
02518:  CALL   1D00
....................        Flag1[n] = 0; 
0251C:  MOVFF  0D,73
02520:  CLRF   x74
02522:  CLRF   x76
02524:  MOVLW  71
02526:  MOVWF  x75
02528:  CALL   1D00
....................        printf(lcd_putc_4bits,"\fApagando...\n   Bombillo %Lu   ",n+1); 
0252C:  MOVLW  01
0252E:  ADDWF  0D,W
02530:  MOVWF  x73
02532:  MOVLW  00
02534:  ADDWFC 0E,W
02536:  MOVWF  x74
02538:  MOVLW  EE
0253A:  MOVWF  FF6
0253C:  MOVLW  11
0253E:  MOVWF  FF7
02540:  MOVLW  00
02542:  MOVWF  FF8
02544:  MOVLW  19
02546:  MOVWF  x75
02548:  CALL   1A04
0254C:  MOVLW  10
0254E:  MOVWF  FE9
02550:  MOVFF  74,76
02554:  MOVFF  73,75
02558:  CALL   1A2A
0255C:  MOVLW  20
0255E:  MOVWF  x82
02560:  CALL   1392
02564:  MOVLW  20
02566:  MOVWF  x82
02568:  CALL   1392
0256C:  MOVLW  20
0256E:  MOVWF  x82
02570:  CALL   1392
....................        switch(n){ 
02574:  MOVFF  0D,00
02578:  MOVF   0E,W
0257A:  MOVWF  03
0257C:  BNZ   2582
0257E:  MOVF   00,F
02580:  BZ    2598
02582:  MOVF   03,W
02584:  BNZ   258C
02586:  MOVLW  01
02588:  SUBWF  00,W
0258A:  BZ    25A4
0258C:  MOVF   03,W
0258E:  BNZ   2596
02590:  MOVLW  02
02592:  SUBWF  00,W
02594:  BZ    25B0
02596:  BRA    25BC
....................        case 0: output_low(PIN_B5);  set_pwm5_duty (0); break; 
02598:  BCF    F93.5
0259A:  BCF    F8A.5
0259C:  MOVLB  F
0259E:  CLRF   x10
025A0:  MOVLB  0
025A2:  BRA    25BC
....................        case 1: output_low(PIN_B6);  set_pwm6_duty (0); break; 
025A4:  BCF    F93.6
025A6:  BCF    F8A.6
025A8:  MOVLB  F
025AA:  CLRF   x0D
025AC:  MOVLB  0
025AE:  BRA    25BC
....................        case 2: output_low(PIN_B7);  set_pwm7_duty (0); break; 
025B0:  BCF    F93.7
025B2:  BCF    F8A.7
025B4:  MOVLB  F
025B6:  CLRF   x0A
025B8:  MOVLB  0
025BA:  BRA    25BC
....................        } 
....................        delay_ms(200); 
025BC:  MOVLW  C8
025BE:  MOVWF  x88
025C0:  CALL   120E
....................        } 
....................         
....................        } 
025C4:  INCF   0D,F
025C6:  BTFSC  FD8.2
025C8:  INCF   0E,F
025CA:  BRA    23A2
....................       } 
....................       lastSeconds = DS1307[segundos]; 
025CC:  MOVFF  12,70
....................    }  
025D0:  BRA    238C
.................... } 
....................  
....................  
025D2:  SLEEP 

Configuration Fuses:
   Word  1: F79A   NOWDT PLL3 NOPLLEN NOSTVREN NOXINST NODEBUG NOCPUDIV NOPROTECT
   Word  2: FF3D   HSPLL SOSC_HIGH CLOCKOUT NOFCMEN NOIESO WDT32768
   Word  3: F861   DSWDTOSC_INT RTCOSC_INT NODSBOR NODSWDT DSWDT8192 NOIOL1WAY ADC12 MSSPMSK7
   Word  4: F980   NOWPFP NOWPCFG WPDIS WPEND LS48MHZ
