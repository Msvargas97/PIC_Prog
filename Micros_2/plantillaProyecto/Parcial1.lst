CCS PCH C Compiler, Version 4.120, 26417               26-Abr.-16 21:14

               Filename: C:\Users\Michael Vargas\Desktop\plantillaProyecto\Parcial1.lst

               ROM used: 4804 bytes (4%)
                         Largest free fragment is 65528
               RAM used: 42 (1%) at main() level
                         83 (2%) worst case
               Stack:    6 locations

*
01000:  GOTO   1DCC
.................... #include "Configurar_micro.h" 
.................... #ifndef _PLANTILLA_18F47J53_H 
.................... #define _PLANTILLA_18F47J53_H 
.................... #include <18F47J53.h> 
.................... //////// Standard Header file for the PIC18F47J53 device //////////////// 
.................... #device PIC18F47J53 
.................... #list 
....................  
....................  
....................  
.................... // Plantilla modificada por Michael Vargas 
.................... // Derechos de autor a Octoplus y PIC CCS 
....................  
.................... #device ADC=12 
.................... #FUSES NOWDT         //WDT disabled (enabled by SWDTEN bit)                     
.................... #FUSES PLL3          //Divide by 3 (12 MHz oscillator input)             
.................... #FUSES NOPLLEN       //PLL Disabled 
.................... #FUSES NOSTVREN      //stack overflow/underflow reset enabled                 
.................... #FUSES NOXINST       //Extended instruction set disabled             
.................... #FUSES NOCPUDIV      //No CPU system clock divide          
.................... #FUSES NOPROTECT     //Program memory is not code-protected           
.................... #FUSES HSPLL         //HS oscillator, PLL enabled, HSPLL used by USB            
.................... #FUSES SOSC_HIGH     //High Power T1OSC/SOSC circuit selected 
.................... #FUSES CLOCKOUT      //CLKO output enabled on the RA6 pin  
.................... #FUSES NOFCMEN       //Fail-Safe Clock Monitor disabled 
.................... #FUSES NOIESO        //Two-Speed Start-up disabled 
.................... #FUSES WDT32768      //Watchdog Postscaler 1:32768 
.................... #FUSES DSWDTOSC_INT  //DSWDT uses INTOSC/INTRC as clock 
.................... #FUSES RTCOSC_INT    //RTCC uses INTRC as clock 
.................... #FUSES NODSBOR       //Zero-Power BOR disabled in Deep Sleep 
.................... #FUSES NODSWDT       //Deep Sleep Watchdog Timer Disabled 
.................... #FUSES DSWDT8192     //Deep Sleep Watchdog Postscaler: 1:8,192 (8.5 seconds)    
.................... #FUSES NOIOL1WAY     //IOLOCK bit can be set and cleared 
.................... #FUSES ADC12         //ADC 10 or 12 Bit Select:12 - Bit ADC Enabed  
.................... #FUSES MSSPMSK7      //MSSP 7 Bit address masking 
.................... #FUSES NOWPFP        //Write Protect Program Flash Page 0 
.................... #FUSES NOWPCFG       //Write/Erase last page protect Disabled 
.................... #FUSES WPDIS         //WPFP[5:0], WPEND, and WPCFG bits ignored  
.................... #FUSES WPEND         //Start protection at page 0 
.................... #FUSES LS48MHZ       //Low Speed USB mode with 48 MHz System clock at 48 MHz USB CLKEN divide-by is set to 8  
.................... #use delay(clock=48000000) 
*
011DE:  CLRF   FEA
011E0:  MOVLW  38
011E2:  MOVWF  FE9
011E4:  MOVF   FEF,W
011E6:  BZ    1204
011E8:  MOVLW  0F
011EA:  MOVWF  01
011EC:  CLRF   00
011EE:  DECFSZ 00,F
011F0:  BRA    11EE
011F2:  DECFSZ 01,F
011F4:  BRA    11EC
011F6:  MOVLW  8F
011F8:  MOVWF  00
011FA:  DECFSZ 00,F
011FC:  BRA    11FA
011FE:  NOP   
01200:  DECFSZ FEF,F
01202:  BRA    11E8
01204:  RETURN 0
....................  
.................... #pin_select U2TX=PIN_D2 //Selecciona hardware UART2 
.................... #pin_select U2RX=PIN_D3 //Selecciona hardware UART2 
....................  
....................  
.................... #define LOADER_END   0xFFF                         
.................... #build(reset=LOADER_END+1, interrupt=LOADER_END+9)   //Protege posiciones de memoria desde la 0x0000 hasta la 0x1000    
.................... #org 0, LOADER_END {} 
....................  
.................... #bit PLLEN = 0xf9b.6 
.................... #bit INTCON2 = 0xff1.7 //Bit para activar la resistencia pull-up del puerto b 
....................  
.................... #define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt))) 
....................  
.................... int32 rule3(int32 value,int32 range,int32 new_range) 
.................... { 
....................   return (int32)(value*new_range) / (range); 
.................... } 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
015DE:  CLRF   2F
....................    sign = 0; 
015E0:  CLRF   2D
....................    base = 10; 
015E2:  MOVLW  0A
015E4:  MOVWF  2E
....................    result = 0; 
015E6:  CLRF   2C
015E8:  CLRF   2B
....................  
....................    if (!s) 
015EA:  MOVF   29,W
015EC:  IORWF  2A,W
015EE:  BNZ   15F8
....................       return 0; 
015F0:  MOVLW  00
015F2:  MOVWF  01
015F4:  MOVWF  02
015F6:  BRA    17C4
....................    c = s[index++]; 
015F8:  MOVF   2F,W
015FA:  INCF   2F,F
015FC:  CLRF   03
015FE:  ADDWF  29,W
01600:  MOVWF  FE9
01602:  MOVF   2A,W
01604:  ADDWFC 03,W
01606:  MOVWF  FEA
01608:  MOVFF  FEF,30
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0160C:  MOVF   30,W
0160E:  SUBLW  2D
01610:  BNZ   162C
....................    { 
....................       sign = 1;         // Set the sign to negative 
01612:  MOVLW  01
01614:  MOVWF  2D
....................       c = s[index++]; 
01616:  MOVF   2F,W
01618:  INCF   2F,F
0161A:  CLRF   03
0161C:  ADDWF  29,W
0161E:  MOVWF  FE9
01620:  MOVF   2A,W
01622:  ADDWFC 03,W
01624:  MOVWF  FEA
01626:  MOVFF  FEF,30
....................    } 
....................    else if (c == '+') 
0162A:  BRA    1646
0162C:  MOVF   30,W
0162E:  SUBLW  2B
01630:  BNZ   1646
....................    { 
....................       c = s[index++]; 
01632:  MOVF   2F,W
01634:  INCF   2F,F
01636:  CLRF   03
01638:  ADDWF  29,W
0163A:  MOVWF  FE9
0163C:  MOVF   2A,W
0163E:  ADDWFC 03,W
01640:  MOVWF  FEA
01642:  MOVFF  FEF,30
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
01646:  MOVF   30,W
01648:  SUBLW  2F
0164A:  BTFSC  FD8.0
0164C:  BRA    17A8
0164E:  MOVF   30,W
01650:  SUBLW  39
01652:  BTFSS  FD8.0
01654:  BRA    17A8
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
01656:  MOVF   30,W
01658:  SUBLW  30
0165A:  BNZ   169E
0165C:  CLRF   03
0165E:  MOVF   2F,W
01660:  ADDWF  29,W
01662:  MOVWF  FE9
01664:  MOVF   2A,W
01666:  ADDWFC 03,W
01668:  MOVWF  FEA
0166A:  MOVF   FEF,W
0166C:  SUBLW  78
0166E:  BZ    1684
01670:  CLRF   03
01672:  MOVF   2F,W
01674:  ADDWF  29,W
01676:  MOVWF  FE9
01678:  MOVF   2A,W
0167A:  ADDWFC 03,W
0167C:  MOVWF  FEA
0167E:  MOVF   FEF,W
01680:  SUBLW  58
01682:  BNZ   169E
....................       { 
....................          base = 16; 
01684:  MOVLW  10
01686:  MOVWF  2E
....................          index++; 
01688:  INCF   2F,F
....................          c = s[index++]; 
0168A:  MOVF   2F,W
0168C:  INCF   2F,F
0168E:  CLRF   03
01690:  ADDWF  29,W
01692:  MOVWF  FE9
01694:  MOVF   2A,W
01696:  ADDWFC 03,W
01698:  MOVWF  FEA
0169A:  MOVFF  FEF,30
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0169E:  MOVF   2E,W
016A0:  SUBLW  0A
016A2:  BNZ   16E6
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
016A4:  MOVF   30,W
016A6:  SUBLW  2F
016A8:  BC    16E4
016AA:  MOVF   30,W
016AC:  SUBLW  39
016AE:  BNC   16E4
....................             result = 10*result + (c - '0'); 
016B0:  CLRF   32
016B2:  MOVLW  0A
016B4:  MOVWF  31
016B6:  MOVFF  2C,34
016BA:  MOVFF  2B,33
016BE:  BRA    158C
016C0:  MOVLW  30
016C2:  SUBWF  30,W
016C4:  ADDWF  01,W
016C6:  MOVWF  2B
016C8:  MOVLW  00
016CA:  ADDWFC 02,W
016CC:  MOVWF  2C
....................             c = s[index++]; 
016CE:  MOVF   2F,W
016D0:  INCF   2F,F
016D2:  CLRF   03
016D4:  ADDWF  29,W
016D6:  MOVWF  FE9
016D8:  MOVF   2A,W
016DA:  ADDWFC 03,W
016DC:  MOVWF  FEA
016DE:  MOVFF  FEF,30
....................          } 
016E2:  BRA    16A4
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
016E4:  BRA    17A8
016E6:  MOVF   2E,W
016E8:  SUBLW  10
016EA:  BNZ   17A8
....................       { 
....................          c = toupper(c); 
016EC:  MOVF   30,W
016EE:  SUBLW  60
016F0:  BC    16FE
016F2:  MOVF   30,W
016F4:  SUBLW  7A
016F6:  BNC   16FE
016F8:  MOVF   30,W
016FA:  ANDLW  DF
016FC:  BRA    1700
016FE:  MOVF   30,W
01700:  MOVWF  30
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
01702:  MOVF   30,W
01704:  SUBLW  2F
01706:  BC    170E
01708:  MOVF   30,W
0170A:  SUBLW  39
0170C:  BC    171A
0170E:  MOVF   30,W
01710:  SUBLW  40
01712:  BC    17A8
01714:  MOVF   30,W
01716:  SUBLW  46
01718:  BNC   17A8
....................             if (c >= '0' && c <= '9') 
0171A:  MOVF   30,W
0171C:  SUBLW  2F
0171E:  BC    1752
01720:  MOVF   30,W
01722:  SUBLW  39
01724:  BNC   1752
....................                result = (result << 4) + (c - '0'); 
01726:  RLCF   2B,W
01728:  MOVWF  31
0172A:  RLCF   2C,W
0172C:  MOVWF  32
0172E:  RLCF   31,F
01730:  RLCF   32,F
01732:  RLCF   31,F
01734:  RLCF   32,F
01736:  RLCF   31,F
01738:  RLCF   32,F
0173A:  MOVLW  F0
0173C:  ANDWF  31,F
0173E:  MOVLW  30
01740:  SUBWF  30,W
01742:  ADDWF  31,W
01744:  MOVWF  01
01746:  MOVLW  00
01748:  ADDWFC 32,W
0174A:  MOVFF  01,2B
0174E:  MOVWF  2C
....................             else 
01750:  BRA    177E
....................                result = (result << 4) + (c - 'A' + 10); 
01752:  RLCF   2B,W
01754:  MOVWF  31
01756:  RLCF   2C,W
01758:  MOVWF  32
0175A:  RLCF   31,F
0175C:  RLCF   32,F
0175E:  RLCF   31,F
01760:  RLCF   32,F
01762:  RLCF   31,F
01764:  RLCF   32,F
01766:  MOVLW  F0
01768:  ANDWF  31,F
0176A:  MOVLW  41
0176C:  SUBWF  30,W
0176E:  ADDLW  0A
01770:  ADDWF  31,W
01772:  MOVWF  01
01774:  MOVLW  00
01776:  ADDWFC 32,W
01778:  MOVFF  01,2B
0177C:  MOVWF  2C
....................  
....................             c = s[index++];c = toupper(c); 
0177E:  MOVF   2F,W
01780:  INCF   2F,F
01782:  CLRF   03
01784:  ADDWF  29,W
01786:  MOVWF  FE9
01788:  MOVF   2A,W
0178A:  ADDWFC 03,W
0178C:  MOVWF  FEA
0178E:  MOVF   FEF,W
01790:  MOVWF  30
01792:  SUBLW  60
01794:  BC    17A2
01796:  MOVF   30,W
01798:  SUBLW  7A
0179A:  BNC   17A2
0179C:  MOVF   30,W
0179E:  ANDLW  DF
017A0:  BRA    17A4
017A2:  MOVF   30,W
017A4:  MOVWF  30
....................          } 
017A6:  BRA    1702
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
017A8:  MOVF   2E,W
017AA:  SUBLW  0A
017AC:  BNZ   17BC
017AE:  DECFSZ 2D,W
017B0:  BRA    17BC
....................       result = -result; 
017B2:  COMF   2B,F
017B4:  COMF   2C,F
017B6:  INCF   2B,F
017B8:  BTFSC  FD8.2
017BA:  INCF   2C,F
....................  
....................    return(result); 
017BC:  MOVFF  2B,01
017C0:  MOVFF  2C,02
.................... } 
017C4:  RETURN 0
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define mcu_init()\ 
.................... do{\ 
....................   PLLEN = 1;        /*Habilita PLL para generar 48MHz de oscilador*/\ 
....................   set_tris_a(0); \  
....................   set_tris_b(0); \ 
....................   set_tris_d(0); \ 
....................   set_tris_e(0); \ 
....................   set_tris_c(0); \ 
.................... }while(0) \ 
....................  
....................  
....................  
.................... #endif /*_PLANTILLA18F47J53_H  */ 
....................  
.................... #include "Configura_LCD_4-8_bits.c" 
.................... //Definicion de instruccion de la LCD 
.................... short bits_8_4; 
....................  
.................... #define LCD_LINEA2 0xC0    // Direccin de memoria para la segunda lnea 
.................... #define clear_display            1 
.................... #define home                     0b10 
.................... #define entry_mode_set           0b100 
.................... #define display_on_off_control   0b1100 
.................... #define cursorON                 0b1110 
.................... #define cursorOFF                0b1100 
.................... #define cursor_or_display_shift  0b1100 
.................... #define function_set             0b101000 
.................... //Sebastian 
.................... /*#define RS_LCD        PIN_D0 
.................... #define E_LCD         PIN_D2 
.................... #define LCD_D4        PIN_D4 
.................... #define LCD_D5        PIN_D5 
.................... #define LCD_D6        PIN_D6 
.................... #define LCD_D7        PIN_D7*/ 
....................  
.................... #define RS_LCD        PIN_D0 
.................... #define RW_LCD        PIN_D1 
.................... #define E_LCD         PIN_D2 
.................... #define LCD_D4        PIN_D3 
.................... #define LCD_D5        PIN_D4 
.................... #define LCD_D6        PIN_D5 
.................... #define LCD_D7        PIN_D6 
.................... #define DATOS        PORTD 
....................  
.................... //-------------- Funcion que envia byte a pantalla lcd -------------------- 
.................... void lcd_envia_byte_4bits(int1 operacion, char dato ) { 
.................... output_low(E_LCD); 
*
01206:  BCF    F95.2
01208:  BCF    F8C.2
.................... output_bit(RS_LCD,operacion); 
0120A:  MOVF   36,F
0120C:  BNZ   1212
0120E:  BCF    F8C.0
01210:  BRA    1214
01212:  BSF    F8C.0
01214:  BCF    F95.0
....................  
.................... if(bit_test(dato,4)==1)output_high (LCD_D4);else output_low (LCD_D4); 
01216:  BTFSS  37.4
01218:  BRA    1220
0121A:  BCF    F95.3
0121C:  BSF    F8C.3
0121E:  BRA    1224
01220:  BCF    F95.3
01222:  BCF    F8C.3
.................... if(bit_test(dato,5)==1)output_high (LCD_D5);else output_low (LCD_D5); 
01224:  BTFSS  37.5
01226:  BRA    122E
01228:  BCF    F95.4
0122A:  BSF    F8C.4
0122C:  BRA    1232
0122E:  BCF    F95.4
01230:  BCF    F8C.4
.................... if(bit_test(dato,6)==1)output_high (LCD_D6);else output_low (LCD_D6); 
01232:  BTFSS  37.6
01234:  BRA    123C
01236:  BCF    F95.5
01238:  BSF    F8C.5
0123A:  BRA    1240
0123C:  BCF    F95.5
0123E:  BCF    F8C.5
.................... if(bit_test(dato,7)==1)output_high (LCD_D7);else output_low (LCD_D7); 
01240:  BTFSS  37.7
01242:  BRA    124A
01244:  BCF    F95.6
01246:  BSF    F8C.6
01248:  BRA    124E
0124A:  BCF    F95.6
0124C:  BCF    F8C.6
.................... delay_us(10); 
0124E:  MOVLW  27
01250:  MOVWF  00
01252:  DECFSZ 00,F
01254:  BRA    1252
01256:  BRA    1258
....................  
.................... output_high(E_LCD); 
01258:  BCF    F95.2
0125A:  BSF    F8C.2
.................... delay_ms(1); 
0125C:  MOVLW  01
0125E:  MOVWF  38
01260:  RCALL  11DE
.................... output_low(E_LCD); 
01262:  BCF    F95.2
01264:  BCF    F8C.2
.................... delay_ms(1); 
01266:  MOVLW  01
01268:  MOVWF  38
0126A:  RCALL  11DE
....................  
.................... if(bit_test(dato,0)==1)output_high (LCD_D4);else output_low (LCD_D4); 
0126C:  BTFSS  37.0
0126E:  BRA    1276
01270:  BCF    F95.3
01272:  BSF    F8C.3
01274:  BRA    127A
01276:  BCF    F95.3
01278:  BCF    F8C.3
.................... if(bit_test(dato,1)==1)output_high (LCD_D5);else output_low (LCD_D5); 
0127A:  BTFSS  37.1
0127C:  BRA    1284
0127E:  BCF    F95.4
01280:  BSF    F8C.4
01282:  BRA    1288
01284:  BCF    F95.4
01286:  BCF    F8C.4
.................... if(bit_test(dato,2)==1)output_high (LCD_D6);else output_low (LCD_D6); 
01288:  BTFSS  37.2
0128A:  BRA    1292
0128C:  BCF    F95.5
0128E:  BSF    F8C.5
01290:  BRA    1296
01292:  BCF    F95.5
01294:  BCF    F8C.5
.................... if(bit_test(dato,3)==1)output_high (LCD_D7);else output_low (LCD_D7); 
01296:  BTFSS  37.3
01298:  BRA    12A0
0129A:  BCF    F95.6
0129C:  BSF    F8C.6
0129E:  BRA    12A4
012A0:  BCF    F95.6
012A2:  BCF    F8C.6
.................... delay_us(10); 
012A4:  MOVLW  27
012A6:  MOVWF  00
012A8:  DECFSZ 00,F
012AA:  BRA    12A8
012AC:  BRA    12AE
....................  
.................... output_high(E_LCD); 
012AE:  BCF    F95.2
012B0:  BSF    F8C.2
.................... delay_ms(1); 
012B2:  MOVLW  01
012B4:  MOVWF  38
012B6:  RCALL  11DE
.................... output_low(E_LCD); 
012B8:  BCF    F95.2
012BA:  BCF    F8C.2
.................... delay_ms(1); 
012BC:  MOVLW  01
012BE:  MOVWF  38
012C0:  RCALL  11DE
.................... } 
012C2:  RETURN 0
.................... //--------- Funcion que establece la posicion del cursor en la lcd ------------ 
.................... void lcd_ubicaxy_4bits(char columna,char fila) { 
.................... char posicion; 
....................      switch (fila) { 
012C4:  MOVLW  01
012C6:  SUBWF  34,W
012C8:  ADDLW  FC
012CA:  BC    12F2
012CC:  ADDLW  04
012CE:  GOTO   12FC
....................      case 1   : posicion=(0x7F+columna); 
012D2:  MOVLW  7F
012D4:  ADDWF  33,W
012D6:  MOVWF  35
....................      break; 
012D8:  BRA    12F2
....................      case 2   : posicion=(0xBF+columna); 
012DA:  MOVLW  BF
012DC:  ADDWF  33,W
012DE:  MOVWF  35
....................      break; 
012E0:  BRA    12F2
....................      case 3   : posicion=(0x8F+columna); 
012E2:  MOVLW  8F
012E4:  ADDWF  33,W
012E6:  MOVWF  35
....................      break; 
012E8:  BRA    12F2
....................      case 4   : posicion=(0xCF+columna); 
012EA:  MOVLW  CF
012EC:  ADDWF  33,W
012EE:  MOVWF  35
....................      break; 
012F0:  BRA    12F2
....................    } 
....................    lcd_envia_byte_4bits( 0,posicion); 
012F2:  CLRF   36
012F4:  MOVFF  35,37
012F8:  RCALL  1206
.................... } 
012FA:  RETURN 0
.................... //----------- Funcion que envia secuencia de inicializaciona lcd -------------- 
.................... void lcd_init_4bits() { 
....................    output_low(RW_LCD); 
*
01324:  BCF    F95.1
01326:  BCF    F8C.1
....................     delay_ms(50); 
01328:  MOVLW  32
0132A:  MOVWF  38
0132C:  RCALL  11DE
....................     lcd_envia_byte_4bits(0,0B00110011); 
0132E:  CLRF   36
01330:  MOVLW  33
01332:  MOVWF  37
01334:  RCALL  1206
....................     lcd_envia_byte_4bits(0,0B00110010); 
01336:  CLRF   36
01338:  MOVLW  32
0133A:  MOVWF  37
0133C:  RCALL  1206
....................     lcd_envia_byte_4bits(0,function_set); 
0133E:  CLRF   36
01340:  MOVLW  28
01342:  MOVWF  37
01344:  RCALL  1206
....................     lcd_envia_byte_4bits(0,display_on_off_control); 
01346:  CLRF   36
01348:  MOVLW  0C
0134A:  MOVWF  37
0134C:  RCALL  1206
....................     lcd_envia_byte_4bits(0,clear_display); 
0134E:  CLRF   36
01350:  MOVLW  01
01352:  MOVWF  37
01354:  RCALL  1206
....................     lcd_ubicaxy_4bits(1,1); 
01356:  MOVLW  01
01358:  MOVWF  33
0135A:  MOVWF  34
0135C:  RCALL  12C4
.................... } 
0135E:  GOTO   1E24 (RETURN)
.................... void lcdCursorOn(){ 
.................... lcd_envia_byte_4bits(0,cursorON); 
.................... } 
.................... void lcdCursorOff(){ 
.................... lcd_envia_byte_4bits(0,cursorOFF); 
.................... } 
.................... //---------------------- Escribe en la lcd la letra dada ---------------------- 
.................... void lcd_putc_4bits( char letra) { 
....................      switch (letra) { 
01362:  MOVF   32,W
01364:  XORLW  0C
01366:  BZ    136E
01368:  XORLW  06
0136A:  BZ    1380
0136C:  BRA    138A
....................      case '\f'   : lcd_envia_byte_4bits(0,1);       //Borra la pantalla LCD 
0136E:  CLRF   36
01370:  MOVLW  01
01372:  MOVWF  37
01374:  RCALL  1206
....................                    lcd_ubicaxy_4bits(1,1);         //Ubica cursor en fila 1 
01376:  MOVLW  01
01378:  MOVWF  33
0137A:  MOVWF  34
0137C:  RCALL  12C4
....................      break; 
0137E:  BRA    1396
....................  
....................      case '\n'   : lcd_ubicaxy_4bits(0,2);          //Busca la fila 2 
01380:  CLRF   33
01382:  MOVLW  02
01384:  MOVWF  34
01386:  RCALL  12C4
....................      break; 
01388:  BRA    1396
....................  
....................      default     : lcd_envia_byte_4bits(1,letra); 
0138A:  MOVLW  01
0138C:  MOVWF  36
0138E:  MOVFF  32,37
01392:  RCALL  1206
....................      break; 
01394:  BRA    1396
....................    } 
....................  
.................... } 
01396:  RETURN 0
.................... //************************************************************************************** 
.................... //************************************************************************************** 
.................... //************************************************************************************** 
.................... //************************************************************************************** 
.................... //************************************************************************************** 
.................... // Comandos para el funcionamiento a 8 bits 
.................... #define LCD_DATO    1 
.................... #define LCD_COMANDO 0 
....................  
.................... // instruccion de inicializacion 
.................... #define LCD_CLEAR          0x01 
.................... #define LCD_HOME          0x02 
....................  
.................... // Opciones para el display 
.................... #define LCD_DISPLAY_OFF  0x08 
.................... #define LCD_DISPLAY_ON   0x0C 
.................... #define LCD_CURSOR_ON    0x0E 
.................... #define LCD_CURSOR_BLINK 0x0F 
....................  
.................... // opciones epeciales del cursor 
.................... #define LCD_CURSOR_SHIFT_RIGHT  0x10 
.................... #define LCD_CURSOR_SHIFT_LEFT   0x14 
.................... #define LCD_DISPLAY_SHIFT_RIGHT 0x18 
.................... #define LCD_DISPLAY_SHIFT_LEFT  0x1C 
....................  
.................... // Configurar el hardware 
.................... #define LCD_DISPLAY_8_BITS   0x38  //0b00111000 
.................... #define LCD_DISPLAY_4_BITS   0x28  //0b00111000 
....................  
....................  
....................  
.................... void lcd_envia_8bits(int dir, int valor) 
.................... { 
....................     
....................      
....................     output_bit(RS_LCD,dir); 
....................     output_high(E_LCD); 
....................     output_d(valor);  // !!!!!Cambiar al puerto donde esten conectados los datos!!!!!! 
....................     delay_us(350); 
....................     output_low(E_LCD); 
....................     delay_us(350); 
....................     
....................       
.................... } 
....................  
....................  
.................... void lcd_init_8bits() 
.................... { 
....................   int dir,valor; 
....................   dir=LCD_COMANDO; 
....................   
....................   valor=LCD_DISPLAY_8_BITS;   //0x38 Inicia el modulo a 8 bits 
....................   bits_8_4=1; 
....................   
....................   lcd_envia_8bits(dir,valor); 
....................   delay_ms(1);    
....................   lcd_envia_8bits(dir,valor); 
....................  
....................   valor=LCD_DISPLAY_ON;    //0x0c activa display 
....................   lcd_envia_8bits(dir,valor); 
....................   valor=LCD_CLEAR;         //0x01 borra display 
....................   lcd_envia_8bits(dir,valor);  
....................   valor=0x06;               //selecciona mensaje fijo 
....................   lcd_envia_8bits(dir,valor); 
....................  
.................... } 
....................  
....................  
.................... void lcd_ubicaxy_8bits( char x, char y) { 
....................    char dir; 
....................  
....................    if(y!=1) 
....................      dir=LCD_LINEA2; 
....................    else 
....................      dir=0; 
....................    dir+=x-1; 
....................    lcd_envia_8bits(LCD_COMANDO,0x80|dir); 
.................... } 
....................  
....................  
.................... void lcd_putc_8bits( char c) 
.................... { 
....................    switch (c) 
....................    { 
....................      case '\f': 
....................          lcd_envia_8bits(LCD_COMANDO,0x01); 
....................          delay_ms(2); 
....................      break; 
....................      case '\n': 
....................          lcd_ubicaxy_8bits(1,2); 
....................      break; 
....................      case '\b': 
....................         lcd_envia_8bits(LCD_COMANDO,0x10); 
....................      break; 
....................      default : 
....................         lcd_envia_8bits(LCD_DATO,c); 
....................      break; 
....................    } 
.................... } 
....................  
....................  
....................  
.................... #define   F1  PIN_A5 
.................... #define   F2  PIN_E0 
.................... #define   F3  PIN_E1  
.................... #define   F4  PIN_E2 
....................                    
.................... #define   C4  PIN_A3 
.................... #define   C3  PIN_A2 
.................... #define   C2  PIN_A1  
.................... #define   C1  PIN_A0 
....................  
.................... //########################ESPACIO PARA VARIABLES GLOBALES 
....................  
.................... unsigned int16 i,j,dato_analogo, temp, hum, luz; 
.................... unsigned char tecla; 
.................... char BUFFER[4]; 
.................... int1 limit,Flag,Flag1; 
.................... unsigned int16 limitTemp,limitHum,limitLuz; 
.................... unsigned int8 pwmTemp,pwmHum,pwmLuz; 
.................... // Vector multidimensional con los caracteres del teclado 
.................... const char keypad[4][4]={ 
.................... {'1','2','3','A'}, 
.................... {'4','5','6','B'}, 
.................... {'7','8','9','C'}, 
.................... {'*','0','#','D'} 
.................... }; 
.................... //Vector con los pines de fila 
.................... const char pinFilas[4] = { F1,F2,F3,F4 }; 
.................... unsigned char barrer_teclado (void) //Esta funcion retorna la tecla presionada 
.................... {        
....................         static unsigned char tecla; 
....................         tecla=0; //Reinicia el valor de la tecla 
*
01424:  CLRF   25
....................         delay_ms(10); 
01426:  MOVLW  0A
01428:  MOVWF  38
0142A:  RCALL  11DE
....................         for(i=0;i<4;i++){ 
0142C:  CLRF   0C
0142E:  CLRF   0B
01430:  MOVF   0C,F
01432:  BTFSS  FD8.2
01434:  BRA    1584
01436:  MOVF   0B,W
01438:  SUBLW  03
0143A:  BTFSS  FD8.0
0143C:  BRA    1584
....................         output_low(pinFilas[i]); //Pone en bajo la fila 
0143E:  MOVFF  0C,03
01442:  MOVF   0B,W
01444:  RCALL  102C
01446:  MOVWF  29
01448:  MOVWF  2A
0144A:  CLRF   2B
0144C:  MOVLW  0F
0144E:  MOVWF  2D
01450:  MOVLW  89
01452:  MOVWF  2C
01454:  RCALL  13E6
01456:  MOVFF  29,2A
0145A:  CLRF   2B
0145C:  MOVLW  0F
0145E:  MOVWF  2D
01460:  MOVLW  92
01462:  MOVWF  2C
01464:  RCALL  13E6
....................         tecla = ~(input_a()) & 0x0F; //Invierte los bits para leerlos de 1-8 
01466:  SETF   F92
01468:  MOVF   F80,W
0146A:  XORLW  FF
0146C:  ANDLW  0F
0146E:  MOVWF  25
....................         if(tecla > 0){ 
01470:  MOVF   25,F
01472:  BTFSC  FD8.2
01474:  BRA    1552
....................         output_high(pinFilas[i]); 
01476:  MOVFF  0C,03
0147A:  MOVF   0B,W
0147C:  RCALL  102C
0147E:  MOVWF  29
01480:  MOVWF  2A
01482:  MOVLW  01
01484:  MOVWF  2B
01486:  MOVLW  0F
01488:  MOVWF  2D
0148A:  MOVLW  89
0148C:  MOVWF  2C
0148E:  RCALL  13E6
01490:  MOVFF  29,2A
01494:  CLRF   2B
01496:  MOVLW  0F
01498:  MOVWF  2D
0149A:  MOVLW  92
0149C:  MOVWF  2C
0149E:  RCALL  13E6
....................         delay_ms(200); 
014A0:  MOVLW  C8
014A2:  MOVWF  38
014A4:  RCALL  11DE
....................         switch(tecla){ 
014A6:  MOVF   25,W
014A8:  XORLW  01
014AA:  BZ    14BA
014AC:  XORLW  03
014AE:  BZ    14DA
014B0:  XORLW  06
014B2:  BZ    1502
014B4:  XORLW  0C
014B6:  BZ    152A
014B8:  BRA    1552
....................         case 1:  return keypad[i][0]; break; 
014BA:  RLCF   0B,W
014BC:  MOVWF  29
014BE:  RLCF   0C,W
014C0:  MOVWF  2A
014C2:  RLCF   29,F
014C4:  RLCF   2A,F
014C6:  MOVLW  FC
014C8:  ANDWF  29,F
014CA:  MOVFF  2A,03
014CE:  MOVF   29,W
014D0:  RCALL  1008
014D2:  MOVWF  01
014D4:  MOVWF  01
014D6:  BRA    1588
014D8:  BRA    1552
....................         case 2:  return keypad[i][1]; break;  
014DA:  RLCF   0B,W
014DC:  MOVWF  29
014DE:  RLCF   0C,W
014E0:  MOVWF  2A
014E2:  RLCF   29,F
014E4:  RLCF   2A,F
014E6:  MOVLW  FC
014E8:  ANDWF  29,F
014EA:  MOVLW  01
014EC:  ADDWF  29,W
014EE:  MOVWF  01
014F0:  MOVLW  00
014F2:  ADDWFC 2A,W
014F4:  MOVWF  03
014F6:  MOVF   01,W
014F8:  RCALL  1008
014FA:  MOVWF  01
014FC:  MOVWF  01
014FE:  BRA    1588
01500:  BRA    1552
....................         case 4:  return keypad[i][2]; break; 
01502:  RLCF   0B,W
01504:  MOVWF  29
01506:  RLCF   0C,W
01508:  MOVWF  2A
0150A:  RLCF   29,F
0150C:  RLCF   2A,F
0150E:  MOVLW  FC
01510:  ANDWF  29,F
01512:  MOVLW  02
01514:  ADDWF  29,W
01516:  MOVWF  01
01518:  MOVLW  00
0151A:  ADDWFC 2A,W
0151C:  MOVWF  03
0151E:  MOVF   01,W
01520:  RCALL  1008
01522:  MOVWF  01
01524:  MOVWF  01
01526:  BRA    1588
01528:  BRA    1552
....................         case 8:  return keypad[i][3]; break; 
0152A:  RLCF   0B,W
0152C:  MOVWF  29
0152E:  RLCF   0C,W
01530:  MOVWF  2A
01532:  RLCF   29,F
01534:  RLCF   2A,F
01536:  MOVLW  FC
01538:  ANDWF  29,F
0153A:  MOVLW  03
0153C:  ADDWF  29,W
0153E:  MOVWF  01
01540:  MOVLW  00
01542:  ADDWFC 2A,W
01544:  MOVWF  03
01546:  MOVF   01,W
01548:  RCALL  1008
0154A:  MOVWF  01
0154C:  MOVWF  01
0154E:  BRA    1588
01550:  BRA    1552
....................         } 
....................         } 
....................         output_high(pinFilas[i]); 
01552:  MOVFF  0C,03
01556:  MOVF   0B,W
01558:  RCALL  102C
0155A:  MOVWF  29
0155C:  MOVWF  2A
0155E:  MOVLW  01
01560:  MOVWF  2B
01562:  MOVLW  0F
01564:  MOVWF  2D
01566:  MOVLW  89
01568:  MOVWF  2C
0156A:  RCALL  13E6
0156C:  MOVFF  29,2A
01570:  CLRF   2B
01572:  MOVLW  0F
01574:  MOVWF  2D
01576:  MOVLW  92
01578:  MOVWF  2C
0157A:  RCALL  13E6
....................         }    
0157C:  INCF   0B,F
0157E:  BTFSC  FD8.2
01580:  INCF   0C,F
01582:  BRA    1430
....................  return 0; 
01584:  MOVLW  00
01586:  MOVWF  01
.................... } 
01588:  GOTO   1896 (RETURN)
....................  
.................... //Prototipado de funciones 
.................... int32 regladeTres(int32  x, int32  in_min, int32  in_max, int32  out_min, int32  out_max) 
.................... { 
....................    return(x-in_min)*(out_max-out_min)/(in_max-in_min)+out_min; 
*
01CEC:  MOVF   2D,W
01CEE:  SUBWF  29,W
01CF0:  MOVWF  3D
01CF2:  MOVF   2E,W
01CF4:  SUBWFB 2A,W
01CF6:  MOVWF  3E
01CF8:  MOVF   2F,W
01CFA:  SUBWFB 2B,W
01CFC:  MOVWF  3F
01CFE:  MOVF   30,W
01D00:  SUBWFB 2C,W
01D02:  MOVWF  40
01D04:  MOVF   35,W
01D06:  SUBWF  39,W
01D08:  MOVWF  00
01D0A:  MOVF   36,W
01D0C:  SUBWFB 3A,W
01D0E:  MOVWF  01
01D10:  MOVF   37,W
01D12:  SUBWFB 3B,W
01D14:  MOVWF  02
01D16:  MOVF   38,W
01D18:  SUBWFB 3C,W
01D1A:  MOVWF  03
01D1C:  MOVWF  44
01D1E:  MOVFF  02,43
01D22:  MOVFF  01,42
01D26:  MOVFF  00,41
01D2A:  MOVFF  40,48
01D2E:  MOVFF  3F,47
01D32:  MOVFF  3E,46
01D36:  MOVFF  3D,45
01D3A:  MOVWF  4C
01D3C:  MOVFF  02,4B
01D40:  MOVFF  01,4A
01D44:  MOVFF  00,49
01D48:  BRA    1C06
01D4A:  MOVFF  03,40
01D4E:  MOVFF  02,3F
01D52:  MOVFF  01,3E
01D56:  MOVFF  00,3D
01D5A:  MOVF   2D,W
01D5C:  SUBWF  31,W
01D5E:  MOVWF  00
01D60:  MOVF   2E,W
01D62:  SUBWFB 32,W
01D64:  MOVWF  01
01D66:  MOVF   2F,W
01D68:  SUBWFB 33,W
01D6A:  MOVWF  02
01D6C:  MOVF   30,W
01D6E:  SUBWFB 34,W
01D70:  MOVWF  03
01D72:  MOVWF  44
01D74:  MOVFF  02,43
01D78:  MOVFF  01,42
01D7C:  MOVFF  00,41
01D80:  BCF    FD8.1
01D82:  MOVFF  40,48
01D86:  MOVFF  3F,47
01D8A:  MOVFF  3E,46
01D8E:  MOVFF  3D,45
01D92:  MOVWF  4C
01D94:  MOVFF  02,4B
01D98:  MOVFF  01,4A
01D9C:  MOVFF  00,49
01DA0:  BRA    1C5C
01DA2:  MOVFF  03,40
01DA6:  MOVFF  02,3F
01DAA:  MOVFF  01,3E
01DAE:  MOVFF  00,3D
01DB2:  MOVF   35,W
01DB4:  ADDWF  00,W
01DB6:  MOVWF  00
01DB8:  MOVF   36,W
01DBA:  ADDWFC 01,W
01DBC:  MOVWF  01
01DBE:  MOVF   37,W
01DC0:  ADDWFC 02,W
01DC2:  MOVWF  02
01DC4:  MOVF   38,W
01DC6:  ADDWFC 03,W
01DC8:  MOVWF  03
.................... } 
01DCA:  RETURN 0
.................... void asignarLimites(void); 
....................  
.................... void main(void){ 
01DCC:  CLRF   FF8
01DCE:  BCF    FD0.7
01DD0:  MOVLB  E
01DD2:  MOVLW  55
01DD4:  MOVWF  FA7
01DD6:  MOVLW  AA
01DD8:  MOVWF  FA7
01DDA:  BCF    xBF.0
01DDC:  MOVLW  14
01DDE:  MOVWF  xF7
01DE0:  MOVLW  06
01DE2:  MOVWF  xD3
01DE4:  MOVLW  55
01DE6:  MOVWF  FA7
01DE8:  MOVLW  AA
01DEA:  MOVWF  FA7
01DEC:  BSF    xBF.0
01DEE:  CLRF   FEA
01DF0:  CLRF   FE9
01DF2:  MOVLW  03
01DF4:  MOVWF  28
01DF6:  MOVLB  1
01DF8:  CLRF   x88
01DFA:  MOVLW  FF
01DFC:  MOVLB  F
01DFE:  MOVWF  x48
01E00:  BCF    FC2.6
01E02:  BCF    FC2.7
01E04:  MOVF   x49,W
01E06:  ANDLW  E0
01E08:  IORLW  1F
01E0A:  MOVWF  x49
01E0C:  CLRF   x25
01E0E:  CLRF   FD1
01E10:  CLRF   FD2
01E12:  CLRF   04
01E14:  CLRF   05
01E16:  CLRF   25
01E18:  CLRF   26
01E1A:  CLRF   27
....................   PLLEN = 1; //Inicializa el microcontrolador 
01E1C:  BSF    F9B.6
....................   lcd_init_4bits (); //Inicializa la LCD 
01E1E:  MOVLB  0
01E20:  GOTO   1324
....................   setup_adc(  ADC_CLOCK_INTERNAL  );                
01E24:  MOVF   FC1,W
01E26:  ANDLW  C0
01E28:  IORLW  03
01E2A:  MOVWF  FC1
01E2C:  BSF    FC1.7
01E2E:  BSF    FC2.0
01E30:  BSF    FC2.7
01E32:  BSF    FC2.1
01E34:  BTFSC  FC2.1
01E36:  BRA    1E34
01E38:  BCF    FC2.7
....................   setup_adc_ports(sAN12|sAN10|sAN9,VSS_VDD); 
01E3A:  MOVLW  FF
01E3C:  MOVLB  F
01E3E:  MOVWF  x48
01E40:  BCF    FC2.6
01E42:  BCF    FC2.7
01E44:  MOVF   x49,W
01E46:  ANDLW  E0
01E48:  IORLW  09
01E4A:  MOVWF  x49
....................     printf(lcd_putc_4bits,"\fTEMP     C LUZ\nHUME    %%     lm");  
01E4C:  MOVLW  44
01E4E:  MOVWF  FF6
01E50:  MOVLW  10
01E52:  MOVWF  FF7
01E54:  MOVLW  00
01E56:  MOVWF  FF8
01E58:  MOVLW  18
01E5A:  MOVWF  29
01E5C:  MOVLB  0
01E5E:  CALL   1398
01E62:  MOVLW  25
01E64:  MOVWF  32
01E66:  CALL   1362
01E6A:  MOVLW  5E
01E6C:  MOVWF  FF6
01E6E:  MOVLW  10
01E70:  MOVWF  FF7
01E72:  MOVLW  00
01E74:  MOVWF  FF8
01E76:  MOVLW  07
01E78:  MOVWF  29
01E7A:  CALL   1398
....................   while(1){ 
....................    
....................   } 
01E7E:  BRA    1E7E
....................   //Ajusta Periodo de seal PWM 
.................... //Formula para calcular Periodo de seal PWM (1/clock)*4*mode*(period+1) 
.................... //          >opciones mode< 
.................... //            T2_DIV_BY_1 
.................... //            T2_DIV_BY_4 
.................... //            T2_DIV_BY_16 
....................  
.................... //         >opciones period< 
.................... //              0...255 
.................... // setup_timer_2(mode,        period,  postscale) 
....................   setup_timer_2(T2_DIV_BY_16,255,1);   // 2929 Hz 
01E80:  MOVLW  00
01E82:  IORLW  06
01E84:  MOVWF  FCA
01E86:  MOVLW  FF
01E88:  MOVWF  FCB
....................   setup_ccp4(CCP_PWM);       
01E8A:  BCF    F93.4
01E8C:  BCF    F8A.4
01E8E:  MOVLW  0C
01E90:  MOVLB  F
01E92:  MOVWF  x12
01E94:  MOVLW  FC
01E96:  ANDWF  x51,F
01E98:  MOVLW  00
01E9A:  IORWF  x51,F
....................   setup_ccp5(CCP_PWM); 
01E9C:  BCF    F93.5
01E9E:  BCF    F8A.5
01EA0:  MOVLW  0C
01EA2:  MOVWF  x0F
01EA4:  BCF    x51.2
....................   setup_ccp6(CCP_PWM);   
01EA6:  BCF    F93.6
01EA8:  BCF    F8A.6
01EAA:  MOVWF  x0C
01EAC:  BCF    x51.4
....................   set_pwm4_duty(0);  //Inicializar PWM 
01EAE:  CLRF   x13
....................   set_pwm5_duty(0);  
01EB0:  CLRF   x10
....................   set_pwm6_duty(0);  
01EB2:  CLRF   x0D
....................   printf(lcd_putc_4bits,"\f    WELCOME!   "); 
01EB4:  MOVLW  66
01EB6:  MOVWF  FF6
01EB8:  MOVLW  10
01EBA:  MOVWF  FF7
01EBC:  MOVLW  00
01EBE:  MOVWF  FF8
01EC0:  MOVLB  0
01EC2:  CALL   13BE
....................   delay_ms(2000); 
01EC6:  MOVLW  08
01EC8:  MOVWF  29
01ECA:  MOVLW  FA
01ECC:  MOVWF  38
01ECE:  CALL   11DE
01ED2:  DECFSZ 29,F
01ED4:  BRA    1ECA
....................   printf(lcd_putc_4bits,"\f(#)Save (D)Clear\n(*)Exit"); 
01ED6:  MOVLW  78
01ED8:  MOVWF  FF6
01EDA:  MOVLW  10
01EDC:  MOVWF  FF7
01EDE:  MOVLW  00
01EE0:  MOVWF  FF8
01EE2:  CALL   13BE
....................   delay_ms(3000); 
01EE6:  MOVLW  0C
01EE8:  MOVWF  29
01EEA:  MOVLW  FA
01EEC:  MOVWF  38
01EEE:  CALL   11DE
01EF2:  DECFSZ 29,F
01EF4:  BRA    1EEA
....................   printf(lcd_putc_4bits,"\fAsignar Limites:\n"); 
01EF6:  MOVLW  92
01EF8:  MOVWF  FF6
01EFA:  MOVLW  10
01EFC:  MOVWF  FF7
01EFE:  MOVLW  00
01F00:  MOVWF  FF8
01F02:  CALL   13BE
....................   printf(lcd_putc_4bits,"A.Tmp B.Hm C.Luz"); 
01F06:  MOVLW  A6
01F08:  MOVWF  FF6
01F0A:  MOVLW  10
01F0C:  MOVWF  FF7
01F0E:  MOVLW  00
01F10:  MOVWF  FF8
01F12:  CALL   13BE
....................   asignarLimites(); 
01F16:  BRA    1894
....................   printf(lcd_putc_4bits,"\fTEMP     C LUZ\nHUME    %%     lm");  
01F18:  MOVLW  B8
01F1A:  MOVWF  FF6
01F1C:  MOVLW  10
01F1E:  MOVWF  FF7
01F20:  MOVLW  00
01F22:  MOVWF  FF8
01F24:  MOVLW  18
01F26:  MOVWF  29
01F28:  CALL   1398
01F2C:  MOVLW  25
01F2E:  MOVWF  32
01F30:  CALL   1362
01F34:  MOVLW  D2
01F36:  MOVWF  FF6
01F38:  MOVLW  10
01F3A:  MOVWF  FF7
01F3C:  MOVLW  00
01F3E:  MOVWF  FF8
01F40:  MOVLW  07
01F42:  MOVWF  29
01F44:  CALL   1398
....................   limit=0; 
01F48:  BCF    0A.1
.................... while(1){ 
....................  set_adc_channel(12); 
01F4A:  MOVLW  30
01F4C:  MOVWF  01
01F4E:  MOVF   FC2,W
01F50:  ANDLW  C3
01F52:  IORWF  01,W
01F54:  MOVWF  FC2
....................  delay_ms(10); 
01F56:  MOVLW  0A
01F58:  MOVWF  38
01F5A:  CALL   11DE
....................  dato_analogo=read_adc(); 
01F5E:  BSF    FC2.1
01F60:  BTFSC  FC2.1
01F62:  BRA    1F60
01F64:  MOVFF  FC3,0F
01F68:  MOVFF  FC4,10
....................  temp=(dato_analogo*0.03663003663); //  valor dato analogo PIN AN0 
01F6C:  MOVFF  10,2A
01F70:  MOVFF  0F,29
01F74:  RCALL  1AA6
01F76:  MOVFF  03,2C
01F7A:  MOVFF  02,2B
01F7E:  MOVFF  01,2A
01F82:  MOVFF  00,29
01F86:  MOVLW  61
01F88:  MOVWF  30
01F8A:  MOVLW  09
01F8C:  MOVWF  2F
01F8E:  MOVLW  16
01F90:  MOVWF  2E
01F92:  MOVLW  7A
01F94:  MOVWF  2D
01F96:  RCALL  1ADC
01F98:  MOVFF  03,2C
01F9C:  MOVFF  02,2B
01FA0:  MOVFF  01,2A
01FA4:  MOVFF  00,29
01FA8:  RCALL  1BCE
01FAA:  MOVFF  02,12
01FAE:  MOVFF  01,11
....................  set_adc_channel(10); 
01FB2:  MOVLW  28
01FB4:  MOVWF  01
01FB6:  MOVF   FC2,W
01FB8:  ANDLW  C3
01FBA:  IORWF  01,W
01FBC:  MOVWF  FC2
....................  delay_ms(10); 
01FBE:  MOVLW  0A
01FC0:  MOVWF  38
01FC2:  CALL   11DE
....................  dato_analogo=read_adc(); 
01FC6:  BSF    FC2.1
01FC8:  BTFSC  FC2.1
01FCA:  BRA    1FC8
01FCC:  MOVFF  FC3,0F
01FD0:  MOVFF  FC4,10
....................   
....................  hum=(dato_analogo*0.02442002442); //  valor dato analogo PIN AN1 
01FD4:  MOVFF  10,2A
01FD8:  MOVFF  0F,29
01FDC:  RCALL  1AA6
01FDE:  MOVFF  03,2C
01FE2:  MOVFF  02,2B
01FE6:  MOVFF  01,2A
01FEA:  MOVFF  00,29
01FEE:  MOVLW  81
01FF0:  MOVWF  30
01FF2:  MOVLW  0C
01FF4:  MOVWF  2F
01FF6:  MOVLW  48
01FF8:  MOVWF  2E
01FFA:  MOVLW  79
01FFC:  MOVWF  2D
01FFE:  RCALL  1ADC
02000:  MOVFF  03,2C
02004:  MOVFF  02,2B
02008:  MOVFF  01,2A
0200C:  MOVFF  00,29
02010:  RCALL  1BCE
02012:  MOVFF  02,14
02016:  MOVFF  01,13
....................   
....................  set_adc_channel(9); 
0201A:  MOVLW  24
0201C:  MOVWF  01
0201E:  MOVF   FC2,W
02020:  ANDLW  C3
02022:  IORWF  01,W
02024:  MOVWF  FC2
....................  delay_ms(10); 
02026:  MOVLW  0A
02028:  MOVWF  38
0202A:  CALL   11DE
....................  dato_analogo=read_adc(); 
0202E:  BSF    FC2.1
02030:  BTFSC  FC2.1
02032:  BRA    2030
02034:  MOVFF  FC3,0F
02038:  MOVFF  FC4,10
....................   
....................  luz=(dato_analogo*0.2442002442); //  valor dato analogo PIN AN2 
0203C:  MOVFF  10,2A
02040:  MOVFF  0F,29
02044:  RCALL  1AA6
02046:  MOVFF  03,2C
0204A:  MOVFF  02,2B
0204E:  MOVFF  01,2A
02052:  MOVFF  00,29
02056:  MOVLW  A1
02058:  MOVWF  30
0205A:  MOVLW  0F
0205C:  MOVWF  2F
0205E:  MOVLW  7A
02060:  MOVWF  2E
02062:  MOVLW  7C
02064:  MOVWF  2D
02066:  RCALL  1ADC
02068:  MOVFF  03,2C
0206C:  MOVFF  02,2B
02070:  MOVFF  01,2A
02074:  MOVFF  00,29
02078:  RCALL  1BCE
0207A:  MOVFF  02,16
0207E:  MOVFF  01,15
....................  
.................... if(temp > limitTemp){ 
02082:  MOVF   1D,W
02084:  SUBWF  12,W
02086:  BNC   20B4
02088:  BNZ   2090
0208A:  MOVF   11,W
0208C:  SUBWF  1C,W
0208E:  BC    20B4
.................... limit=1; 
02090:  BSF    0A.1
.................... Flag=0; 
02092:  BCF    0A.2
.................... if(!Flag1){ 
02094:  BTFSC  0A.3
02096:  BRA    20B2
.................... printf(lcd_putc_4bits,"\fTemp Fuera\n de limite"); 
02098:  MOVLW  DA
0209A:  MOVWF  FF6
0209C:  MOVLW  10
0209E:  MOVWF  FF7
020A0:  MOVLW  00
020A2:  MOVWF  FF8
020A4:  CALL   13BE
.................... delay_ms(200); 
020A8:  MOVLW  C8
020AA:  MOVWF  38
020AC:  CALL   11DE
.................... Flag1=1; 
020B0:  BSF    0A.3
.................... } 
.................... }else if(hum > limitHum){ 
020B2:  BRA    22C4
020B4:  MOVF   1F,W
020B6:  SUBWF  14,W
020B8:  BNC   20E6
020BA:  BNZ   20C2
020BC:  MOVF   13,W
020BE:  SUBWF  1E,W
020C0:  BC    20E6
.................... limit=1; 
020C2:  BSF    0A.1
.................... Flag=0; 
020C4:  BCF    0A.2
.................... if(!Flag1){ 
020C6:  BTFSC  0A.3
020C8:  BRA    20E4
.................... printf(lcd_putc_4bits,"\fHumedad Fuera\n de limite"); 
020CA:  MOVLW  F2
020CC:  MOVWF  FF6
020CE:  MOVLW  10
020D0:  MOVWF  FF7
020D2:  MOVLW  00
020D4:  MOVWF  FF8
020D6:  CALL   13BE
.................... delay_ms(200); 
020DA:  MOVLW  C8
020DC:  MOVWF  38
020DE:  CALL   11DE
.................... Flag1=1; 
020E2:  BSF    0A.3
.................... } 
....................  
.................... }else if(luz > limitLuz){ 
020E4:  BRA    22C4
020E6:  MOVF   21,W
020E8:  SUBWF  16,W
020EA:  BNC   2118
020EC:  BNZ   20F4
020EE:  MOVF   15,W
020F0:  SUBWF  20,W
020F2:  BC    2118
.................... limit=1; 
020F4:  BSF    0A.1
.................... Flag=0; 
020F6:  BCF    0A.2
.................... if(!Flag1){ 
020F8:  BTFSC  0A.3
020FA:  BRA    2116
.................... printf(lcd_putc_4bits,"\fLuz fuera \nde limite"); 
020FC:  MOVLW  0C
020FE:  MOVWF  FF6
02100:  MOVLW  11
02102:  MOVWF  FF7
02104:  MOVLW  00
02106:  MOVWF  FF8
02108:  CALL   13BE
.................... delay_ms(200); 
0210C:  MOVLW  C8
0210E:  MOVWF  38
02110:  CALL   11DE
.................... Flag1=1; 
02114:  BSF    0A.3
.................... } 
.................... }else{ 
02116:  BRA    22C4
.................... if(limit==1){ 
02118:  BTFSS  0A.1
0211A:  BRA    2156
.................... if(!Flag){ 
0211C:  BTFSC  0A.2
0211E:  BRA    2154
.................... Flag1=0; 
02120:  BCF    0A.3
.................... printf(lcd_putc_4bits,"\fTEMP     C LUZ\nHUME    %%     lm");  
02122:  MOVLW  22
02124:  MOVWF  FF6
02126:  MOVLW  11
02128:  MOVWF  FF7
0212A:  MOVLW  00
0212C:  MOVWF  FF8
0212E:  MOVLW  18
02130:  MOVWF  29
02132:  CALL   1398
02136:  MOVLW  25
02138:  MOVWF  32
0213A:  CALL   1362
0213E:  MOVLW  3C
02140:  MOVWF  FF6
02142:  MOVLW  11
02144:  MOVWF  FF7
02146:  MOVLW  00
02148:  MOVWF  FF8
0214A:  MOVLW  07
0214C:  MOVWF  29
0214E:  CALL   1398
.................... Flag=1; 
02152:  BSF    0A.2
.................... } 
.................... limit=0; 
02154:  BCF    0A.1
.................... } 
.................... pwmTemp = (unsigned int8) regladeTres(temp,0,limitTemp,0,255); 
02156:  CLRF   2C
02158:  CLRF   2B
0215A:  MOVFF  12,2A
0215E:  MOVFF  11,29
02162:  CLRF   30
02164:  CLRF   2F
02166:  CLRF   2E
02168:  CLRF   2D
0216A:  CLRF   34
0216C:  CLRF   33
0216E:  MOVFF  1D,32
02172:  MOVFF  1C,31
02176:  CLRF   38
02178:  CLRF   37
0217A:  CLRF   36
0217C:  CLRF   35
0217E:  CLRF   3C
02180:  CLRF   3B
02182:  CLRF   3A
02184:  SETF   39
02186:  RCALL  1CEC
02188:  MOVFF  00,22
.................... pwmHum =  (unsigned int8) regladeTres(hum,0,limitHum,0,255);  
0218C:  CLRF   2C
0218E:  CLRF   2B
02190:  MOVFF  14,2A
02194:  MOVFF  13,29
02198:  CLRF   30
0219A:  CLRF   2F
0219C:  CLRF   2E
0219E:  CLRF   2D
021A0:  CLRF   34
021A2:  CLRF   33
021A4:  MOVFF  1F,32
021A8:  MOVFF  1E,31
021AC:  CLRF   38
021AE:  CLRF   37
021B0:  CLRF   36
021B2:  CLRF   35
021B4:  CLRF   3C
021B6:  CLRF   3B
021B8:  CLRF   3A
021BA:  SETF   39
021BC:  RCALL  1CEC
021BE:  MOVFF  00,23
.................... pwmLuz =  (unsigned int8) regladeTres(luz,0,limitLuz,0,255); 
021C2:  CLRF   2C
021C4:  CLRF   2B
021C6:  MOVFF  16,2A
021CA:  MOVFF  15,29
021CE:  CLRF   30
021D0:  CLRF   2F
021D2:  CLRF   2E
021D4:  CLRF   2D
021D6:  CLRF   34
021D8:  CLRF   33
021DA:  MOVFF  21,32
021DE:  MOVFF  20,31
021E2:  CLRF   38
021E4:  CLRF   37
021E6:  CLRF   36
021E8:  CLRF   35
021EA:  CLRF   3C
021EC:  CLRF   3B
021EE:  CLRF   3A
021F0:  SETF   39
021F2:  RCALL  1CEC
021F4:  MOVFF  00,24
....................  
.................... set_pwm4_duty(pwmTemp);   
021F8:  MOVFF  22,F13
.................... set_pwm5_duty(pwmHum);  
021FC:  MOVFF  23,F10
.................... set_pwm6_duty(pwmLuz);  
02200:  MOVFF  24,F0D
....................  
.................... lcd_ubicaxy_4bits(5,1);    // POSICION EN LA PANTALLA X,Y 
02204:  MOVLW  05
02206:  MOVWF  33
02208:  MOVLW  01
0220A:  MOVWF  34
0220C:  CALL   12C4
.................... printf(LCD_PUTC_4bits, "    "); /// TEMPERATURA PIN AN0 
02210:  MOVLW  44
02212:  MOVWF  FF6
02214:  MOVLW  11
02216:  MOVWF  FF7
02218:  MOVLW  00
0221A:  MOVWF  FF8
0221C:  CALL   13BE
.................... lcd_ubicaxy_4bits(5,1);    // POSICION EN LA PANTALLA X,Y 
02220:  MOVLW  05
02222:  MOVWF  33
02224:  MOVLW  01
02226:  MOVWF  34
02228:  CALL   12C4
.................... printf(LCD_PUTC_4bits, " %lu", temp); /// TEMPERATURA PIN AN0 
0222C:  MOVLW  20
0222E:  MOVWF  32
02230:  CALL   1362
02234:  MOVLW  10
02236:  MOVWF  FE9
02238:  MOVFF  12,2A
0223C:  MOVFF  11,29
02240:  CALL   17C6
....................  
.................... lcd_ubicaxy_4bits(6,2);    // POSICION EN LA PANTALLA X,Y 
02244:  MOVLW  06
02246:  MOVWF  33
02248:  MOVLW  02
0224A:  MOVWF  34
0224C:  CALL   12C4
.................... printf(LCD_PUTC_4bits, "   "); /// HUMEDAD PIN AN1 
02250:  MOVLW  20
02252:  MOVWF  32
02254:  CALL   1362
02258:  MOVLW  20
0225A:  MOVWF  32
0225C:  CALL   1362
02260:  MOVLW  20
02262:  MOVWF  32
02264:  CALL   1362
.................... lcd_ubicaxy_4bits(6,2);    // POSICION EN LA PANTALLA X,Y 
02268:  MOVLW  06
0226A:  MOVWF  33
0226C:  MOVLW  02
0226E:  MOVWF  34
02270:  CALL   12C4
.................... printf(LCD_PUTC_4bits, "%lu",hum); /// HUMEDAD PIN AN1 
02274:  MOVLW  10
02276:  MOVWF  FE9
02278:  MOVFF  14,2A
0227C:  MOVFF  13,29
02280:  CALL   17C6
....................  
....................  
.................... lcd_ubicaxy_4bits(11,2);    // POSICION EN LA PANTALLA X,Y 
02284:  MOVLW  0B
02286:  MOVWF  33
02288:  MOVLW  02
0228A:  MOVWF  34
0228C:  CALL   12C4
.................... printf(LCD_PUTC_4bits,"    "); /// LUZ PIN AN2 
02290:  MOVLW  4A
02292:  MOVWF  FF6
02294:  MOVLW  11
02296:  MOVWF  FF7
02298:  MOVLW  00
0229A:  MOVWF  FF8
0229C:  CALL   13BE
.................... lcd_ubicaxy_4bits(11,2);    // POSICION EN LA PANTALLA X,Y 
022A0:  MOVLW  0B
022A2:  MOVWF  33
022A4:  MOVLW  02
022A6:  MOVWF  34
022A8:  CALL   12C4
.................... printf(LCD_PUTC_4bits,"%lu",luz); /// LUZ PIN AN2 
022AC:  MOVLW  10
022AE:  MOVWF  FE9
022B0:  MOVFF  16,2A
022B4:  MOVFF  15,29
022B8:  CALL   17C6
.................... delay_ms(100); 
022BC:  MOVLW  64
022BE:  MOVWF  38
022C0:  CALL   11DE
.................... } 
....................  
....................  
.................... } 
022C4:  BRA    1F4A
.................... } 
.................... //Funciones  
.................... void asignarLimites(void){ 
.................... while(true){ 
022C6:  SLEEP 
....................   static char teclaMenu,save; 
....................   static char numDigits=3; 
....................   tecla=barrer_teclado(); 
*
01894:  BRA    1424
01896:  MOVFF  01,17
....................   if(tecla=='*'){ 
0189A:  MOVF   17,W
0189C:  SUBLW  2A
0189E:  BNZ   18A2
....................   break; 
018A0:  BRA    1AA2
....................   } 
....................   if(tecla >= 'A' || tecla >= 'B' || tecla >= 'C' || tecla == '#'  ){ 
018A2:  MOVF   17,W
018A4:  SUBLW  40
018A6:  BNC   18BC
018A8:  MOVF   17,W
018AA:  SUBLW  41
018AC:  BNC   18BC
018AE:  MOVF   17,W
018B0:  SUBLW  42
018B2:  BNC   18BC
018B4:  MOVF   17,W
018B6:  SUBLW  23
018B8:  BTFSS  FD8.2
018BA:  BRA    1A56
....................    switch(tecla){ 
018BC:  MOVF   17,W
018BE:  XORLW  41
018C0:  BZ    18D6
018C2:  XORLW  03
018C4:  BZ    18EE
018C6:  XORLW  01
018C8:  BZ    1906
018CA:  XORLW  60
018CC:  BZ    191E
018CE:  XORLW  67
018D0:  BTFSC  FD8.2
018D2:  BRA    19FE
018D4:  BRA    1A40
....................          case 'A': j=0; numDigits=3;  printf(lcd_putc_4bits,"\fLimite Temp:\n"); break; 
018D6:  CLRF   0E
018D8:  CLRF   0D
018DA:  MOVLW  03
018DC:  MOVWF  28
018DE:  MOVLW  50
018E0:  MOVWF  FF6
018E2:  MOVLW  11
018E4:  MOVWF  FF7
018E6:  MOVLW  00
018E8:  MOVWF  FF8
018EA:  RCALL  13BE
018EC:  BRA    1A40
....................          case 'B': j=0; numDigits=3;  printf(lcd_putc_4bits,"\fLimite Humedad:\n");   break; 
018EE:  CLRF   0E
018F0:  CLRF   0D
018F2:  MOVLW  03
018F4:  MOVWF  28
018F6:  MOVLW  60
018F8:  MOVWF  FF6
018FA:  MOVLW  11
018FC:  MOVWF  FF7
018FE:  MOVLW  00
01900:  MOVWF  FF8
01902:  RCALL  13BE
01904:  BRA    1A40
....................          case 'C': j=0; numDigits=4;  printf(lcd_putc_4bits,"\fLimite Luz:\n"); break; 
01906:  CLRF   0E
01908:  CLRF   0D
0190A:  MOVLW  04
0190C:  MOVWF  28
0190E:  MOVLW  72
01910:  MOVWF  FF6
01912:  MOVLW  11
01914:  MOVWF  FF7
01916:  MOVLW  00
01918:  MOVWF  FF8
0191A:  RCALL  13BE
0191C:  BRA    1A40
....................          case '#':  
....................          if(save == 'A'){ 
0191E:  MOVF   27,W
01920:  SUBLW  41
01922:  BNZ   195A
....................          limitTemp = atol(BUFFER);  printf(lcd_putc_4bits,"\fTemp Maxima:%Lu ",limitTemp); 
01924:  CLRF   2A
01926:  MOVLW  18
01928:  MOVWF  29
0192A:  RCALL  15DE
0192C:  MOVFF  02,1D
01930:  MOVFF  01,1C
01934:  MOVLW  80
01936:  MOVWF  FF6
01938:  MOVLW  11
0193A:  MOVWF  FF7
0193C:  MOVLW  00
0193E:  MOVWF  FF8
01940:  MOVLW  0D
01942:  MOVWF  29
01944:  RCALL  1398
01946:  MOVLW  10
01948:  MOVWF  FE9
0194A:  MOVFF  1D,2A
0194E:  MOVFF  1C,29
01952:  RCALL  17C6
01954:  MOVLW  20
01956:  MOVWF  32
01958:  RCALL  1362
....................          } 
....................          if(save =='B'){ 
0195A:  MOVF   27,W
0195C:  SUBLW  42
0195E:  BNZ   1996
....................          limitHum = atol(BUFFER);  printf(lcd_putc_4bits,"\fHum Maxima:%Lu ",limitHum); 
01960:  CLRF   2A
01962:  MOVLW  18
01964:  MOVWF  29
01966:  RCALL  15DE
01968:  MOVFF  02,1F
0196C:  MOVFF  01,1E
01970:  MOVLW  92
01972:  MOVWF  FF6
01974:  MOVLW  11
01976:  MOVWF  FF7
01978:  MOVLW  00
0197A:  MOVWF  FF8
0197C:  MOVLW  0C
0197E:  MOVWF  29
01980:  RCALL  1398
01982:  MOVLW  10
01984:  MOVWF  FE9
01986:  MOVFF  1F,2A
0198A:  MOVFF  1E,29
0198E:  RCALL  17C6
01990:  MOVLW  20
01992:  MOVWF  32
01994:  RCALL  1362
....................          } 
....................          if(save =='C'){ 
01996:  MOVF   27,W
01998:  SUBLW  43
0199A:  BNZ   19D2
....................          limitLuz = atol(BUFFER);  printf(lcd_putc_4bits,"\fLuz Maxima:%Lu ",limitLuz); 
0199C:  CLRF   2A
0199E:  MOVLW  18
019A0:  MOVWF  29
019A2:  RCALL  15DE
019A4:  MOVFF  02,21
019A8:  MOVFF  01,20
019AC:  MOVLW  A4
019AE:  MOVWF  FF6
019B0:  MOVLW  11
019B2:  MOVWF  FF7
019B4:  MOVLW  00
019B6:  MOVWF  FF8
019B8:  MOVLW  0C
019BA:  MOVWF  29
019BC:  RCALL  1398
019BE:  MOVLW  10
019C0:  MOVWF  FE9
019C2:  MOVFF  21,2A
019C6:  MOVFF  20,29
019CA:  RCALL  17C6
019CC:  MOVLW  20
019CE:  MOVWF  32
019D0:  RCALL  1362
....................          } 
....................          delay_ms(1000); 
019D2:  MOVLW  04
019D4:  MOVWF  29
019D6:  MOVLW  FA
019D8:  MOVWF  38
019DA:  RCALL  11DE
019DC:  DECFSZ 29,F
019DE:  BRA    19D6
....................          printf(lcd_putc_4bits,"\fAsignar Limites:\n"); 
019E0:  MOVLW  B6
019E2:  MOVWF  FF6
019E4:  MOVLW  11
019E6:  MOVWF  FF7
019E8:  MOVLW  00
019EA:  MOVWF  FF8
019EC:  RCALL  13BE
....................          printf(lcd_putc_4bits,"A.Tmp B.Hm C.Luz"); 
019EE:  MOVLW  CA
019F0:  MOVWF  FF6
019F2:  MOVLW  11
019F4:  MOVWF  FF7
019F6:  MOVLW  00
019F8:  MOVWF  FF8
019FA:  RCALL  13BE
....................          break; 
019FC:  BRA    1A40
....................          case 'D': if( j > 0){lcd_ubicaxy_4bits(j,2); lcd_putc_4bits(" "); lcd_ubicaxy_4bits(j,2); j--; buffer[j]=0x00;} break; 
019FE:  MOVF   0D,F
01A00:  BNZ   1A06
01A02:  MOVF   0E,F
01A04:  BZ    1A3E
01A06:  MOVFF  0D,33
01A0A:  MOVLW  02
01A0C:  MOVWF  34
01A0E:  RCALL  12C4
01A10:  MOVLW  DC
01A12:  MOVWF  FF6
01A14:  MOVLW  11
01A16:  MOVWF  FF7
01A18:  MOVLW  00
01A1A:  MOVWF  FF8
01A1C:  RCALL  13BE
01A1E:  MOVFF  0D,33
01A22:  MOVLW  02
01A24:  MOVWF  34
01A26:  RCALL  12C4
01A28:  MOVF   0D,W
01A2A:  BTFSC  FD8.2
01A2C:  DECF   0E,F
01A2E:  DECF   0D,F
01A30:  MOVLW  18
01A32:  ADDWF  0D,W
01A34:  MOVWF  FE9
01A36:  MOVLW  00
01A38:  ADDWFC 0E,W
01A3A:  MOVWF  FEA
01A3C:  CLRF   FEF
01A3E:  BRA    1A40
....................   } 
....................   if(tecla=='A' || tecla=='B' || tecla=='C'){ 
01A40:  MOVF   17,W
01A42:  SUBLW  41
01A44:  BZ    1A52
01A46:  MOVF   17,W
01A48:  SUBLW  42
01A4A:  BZ    1A52
01A4C:  MOVF   17,W
01A4E:  SUBLW  43
01A50:  BNZ   1A56
....................   save=tecla; 
01A52:  MOVFF  17,27
....................   } 
....................   } 
....................    if(tecla>= '0' && tecla <= '9' && j < numDigits){ 
01A56:  MOVF   17,W
01A58:  SUBLW  2F
01A5A:  BC    1A88
01A5C:  MOVF   17,W
01A5E:  SUBLW  39
01A60:  BNC   1A88
01A62:  MOVF   0E,F
01A64:  BNZ   1A88
01A66:  MOVF   28,W
01A68:  SUBWF  0D,W
01A6A:  BC    1A88
....................     printf(lcd_putc_4bits,"%c",tecla); //Muestra el numero presionado 
01A6C:  MOVFF  17,32
01A70:  RCALL  1362
....................    BUFFER[j]=tecla; 
01A72:  MOVLW  18
01A74:  ADDWF  0D,W
01A76:  MOVWF  FE9
01A78:  MOVLW  00
01A7A:  ADDWFC 0E,W
01A7C:  MOVWF  FEA
01A7E:  MOVFF  17,FEF
....................    j++; 
01A82:  INCF   0D,F
01A84:  BTFSC  FD8.2
01A86:  INCF   0E,F
....................    }   
....................    if(j==0){ 
01A88:  MOVF   0D,F
01A8A:  BNZ   1AA0
01A8C:  MOVF   0E,F
01A8E:  BNZ   1AA0
....................    memset(BUFFER,0x0,4); //Borra lo que haya en el vector 
01A90:  CLRF   FEA
01A92:  MOVLW  18
01A94:  MOVWF  FE9
01A96:  CLRF   29
01A98:  CLRF   2B
01A9A:  MOVLW  04
01A9C:  MOVWF  2A
01A9E:  BRA    1878
....................    } 
....................    
....................  
....................    
....................   } 
01AA0:  BRA    1894
.................... } 
01AA2:  GOTO   1F18 (RETURN)

Configuration Fuses:
   Word  1: F79A   NOWDT PLL3 NOPLLEN NOSTVREN NOXINST NODEBUG NOCPUDIV NOPROTECT
   Word  2: FF3D   HSPLL SOSC_HIGH CLOCKOUT NOFCMEN NOIESO WDT32768
   Word  3: F861   DSWDTOSC_INT RTCOSC_INT NODSBOR NODSWDT DSWDT8192 NOIOL1WAY ADC12 MSSPMSK7
   Word  4: F980   NOWPFP NOWPCFG WPDIS WPEND LS48MHZ
