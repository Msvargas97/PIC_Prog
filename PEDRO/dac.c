/* Main.c file generated by New Project wizard
 *
 * Created:   sáb nov 16 2013
 * Processor: PIC18F47J53
 * Compiler:  CCS for PIC
 */

#include <18F47J53.h>
#include <math.h>


#FUSES NOWDT         //WDT disabled (enabled by SWDTEN bit)                    
#FUSES PLL3          //Divide by 3 (12 MHz oscillator input)            
#FUSES NOPLLEN       //PLL Disabled
#FUSES NOSTVREN      //stack overflow/underflow reset enabled                
#FUSES NOXINST       //Extended instruction set disabled            
#FUSES NOCPUDIV      //No CPU system clock divide         
#FUSES NOPROTECT     //Program memory is not code-protected          
#FUSES HSPLL         //HS oscillator, PLL enabled, HSPLL used by USB           
#FUSES SOSC_HIGH     //High Power T1OSC/SOSC circuit selected
#FUSES CLOCKOUT      //CLKO output enabled on the RA6 pin 
#FUSES NOFCMEN       //Fail-Safe Clock Monitor disabled
#FUSES NOIESO        //Two-Speed Start-up disabled
#FUSES WDT32768      //Watchdog Postscaler 1:32768
#FUSES DSWDTOSC_INT  //DSWDT uses INTOSC/INTRC as clock
#FUSES RTCOSC_INT    //RTCC uses INTRC as clock
#FUSES NODSBOR       //Zero-Power BOR disabled in Deep Sleep
#FUSES NODSWDT       //Deep Sleep Watchdog Timer Disabled
#FUSES DSWDT8192     //Deep Sleep Watchdog Postscaler: 1:8,192 (8.5 seconds)   
#FUSES NOIOL1WAY     //IOLOCK bit can be set and cleared
#FUSES ADC12         //ADC 10 or 12 Bit Select:12 - Bit ADC Enabed 
#FUSES MSSPMSK7      //MSSP 7 Bit address masking
#FUSES NOWPFP        //Write Protect Program Flash Page 0
#FUSES NOWPCFG       //Write/Erase last page protect Disabled
#FUSES WPDIS         //WPFP[5:0], WPEND, and WPCFG bits ignored 
#FUSES WPEND         //Start protection at page 0
#FUSES LS48MHZ       //Low Speed USB mode with 48 MHz System clock at 48 MHz USB CLKEN divide-by is set to 8 
#use delay(clock=48000000)

#pin_select U2TX=PIN_D2 //Selecciona hardware UART2
#pin_select U2RX=PIN_D3 //Selecciona hardware UART2


#define LOADER_END   0xFFF                        
#build(reset=LOADER_END+1, interrupt=LOADER_END+9)   //Protege posiciones de memoria desde la 0x0000 hasta la 0x1000   
#org 0, LOADER_END {}

#bit PLLEN = 0xf9b.6

#use  rs232(baud=9600,parity=N,UART1,bits=8,timeout=30)
/********************************************************/
/*------- Espacio para declaracion de constantes  ------*/
/********************************************************/
#define DAC_CS     PIN_E2
#define DAC_CLK    PIN_E1
#define DAC_DI     PIN_E0
#define DAC_LDAC   PIN_B1

#define SAMPLES 16

#include "Configura_LCD_4-8_bits.c"
/********************************************************/
/*--- Espacio para declaracion de variables globales  --*/
/********************************************************/
unsigned int16 i,j;
float Fs=0,frequency; 
int16 datos[100]={0};
int16 period;
/********************************************************/
/********************************************************/
/*-------------- Espacio para funciones  ---------------*/
/********************************************************/
               
void senox(float freq){
static float x;
Fs = (float)(1/(double)(SAMPLES*freq)); 
for(j=0;j<SAMPLES;j++){
 x=2*pi*freq*j*Fs;
 datos[j]= 2047*sin(x)+ 2047;
 if(datos[j] > 4095 ) datos[j] = 4095;
}
}
void sawTooth(float freq){
static int16 saw;
for(j=0;j<SAMPLES;j++){
   if(saw>4095) saw = 0;
   else saw+=(4095/SAMPLES);
   datos[j] = saw;
}
}
void triangular(float freq){
static int16 trian=0;
for(j=0;j<(SAMPLES/2);j++)
{
datos[trian] = j*(4095/(SAMPLES*0.5));
trian++;
}
for(j=(SAMPLES/2);j>0;j--)
{
datos[trian] = j*(4095/(SAMPLES*0.5));
trian++;
}
}
void square(float freq){
static int16 sq=0;
for(j=0;j<(SAMPLES/2);j++)
{
datos[sq] = 4095;
sq++;
}
for(j=0;j<(SAMPLES/2);j++)
{
datos[sq] = 0;
sq++;
}
}

void init_dac()
{
   output_high(DAC_CS);
   output_high(DAC_LDAC);
   output_high(DAC_CLK);
   output_high(DAC_DI);
}
void write_dac(int16 data) {
   BYTE cmd[3];
   BYTE i;

   cmd[0]=data;
   cmd[1]=(data>>8);
   cmd[2]=0x01;                           
   
   output_high(DAC_LDAC);
   output_low(DAC_CLK);
   output_low(DAC_CS);

   for(i=0; i<=23; ++i)
   {
      if(i<4 || (i>7 && i<12))
         shift_left(cmd,3,0);
      else
      {
         output_bit(DAC_DI, shift_left(cmd,3,0));

         output_high(DAC_CLK);
         output_low(DAC_CLK);
      }
   }
   output_high(DAC_CS);
   output_low(DAC_LDAC); 
   output_HIGH(DAC_LDAC);
}               


/******************************************************************************/
/******************************************************************************/
/*--------------------- Espacio de codigo principal --------------------------*/
/******************************************************************************/ 
#zero_ram
void main(){
PLLEN = 1;          //Habilita PLL para generar 48MHz de oscilador*/\ 
frequency = 670;
if(frequency >= 500 && frequency <= 1000 ) frequency -= 1;
triangular(frequency);
init_dac();
lcd_init_4bits();
//Calcula el periodo teniendo en cuenta el tiempo que le toma al microcontrolador enviar los bits al DAC y el numero de muestras
period = (((1/frequency) - 0.000870f )*1e+6) / SAMPLES;
printf(lcd_putc_4bits,"\fFs:%8f\nT:%Lu",Fs,period);
while(1){   
if(i==SAMPLES){
 i = 0;
}
 write_dac(datos[i]);
 delay_us(period);
 i++;
}   
}//end main
     
